<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JVM垃圾回收入门</title>
      <link href="WindShadow/JVM/Garbage-Collection/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%85%A5%E9%97%A8/"/>
      <url>WindShadow/JVM/Garbage-Collection/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM垃圾回收入门"><a href="#JVM垃圾回收入门" class="headerlink" title="JVM垃圾回收入门"></a>JVM垃圾回收入门</h1><p>本文JVM以常用的Hotspot虚拟机为例。</p><h2 id="JVM内存分区"><a href="#JVM内存分区" class="headerlink" title="JVM内存分区"></a>JVM内存分区</h2><p>Java垃圾回收也叫GC（Garbage Collection），了解GC之前先了解JVM内存分区。</p><p>JVM将内存分为5大部分：方法区、堆、虚拟机栈、程序计数器、本地方法栈</p><p>如图（图片来自互联网）</p><p><img src="/WindShadow/JVM/Garbage-Collection/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%85%A5%E9%97%A8/jvm%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.png" alt="JVM内存分区"></p><p>垃圾回就是释放垃圾占用的空间，防止内存泄露。有效的使用可以使用的内存，Java中主要对内存<strong>堆（Heap）</strong>中已经死亡的或者长时间没有使用的对象进行清除和回收。 </p><p>下文《分代回收模型与分代回收算法》小节着重讲方法区和堆，此处先照个面。</p><h2 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h2><p>知道垃圾回收大体概念后，那么什么是垃圾呢？或者说什么样的对象才能称之为垃圾？</p><p>定义：没有任何引用指向的一个对象或多个对象（循环引用，见下文）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User a = <span class="keyword">new</span> User(<span class="string">&quot;admin&quot;</span>);<span class="comment">// new 了一个名为&quot;admin&quot;的User对象，其引用给到了变量a</span></span><br><span class="line">a = <span class="keyword">null</span>; <span class="comment">// 此时名为&quot;admin&quot;的User对象没有被引用了，成为了垃圾，GC被触发时会被回收</span></span><br></pre></td></tr></table></figure><h2 id="如何定位垃圾"><a href="#如何定位垃圾" class="headerlink" title="如何定位垃圾"></a>如何定位垃圾</h2><h3 id="引用计数法（reference-count）"><a href="#引用计数法（reference-count）" class="headerlink" title="引用计数法（reference count）"></a>引用计数法（reference count）</h3><p>给每个对象添加一个计数器，当有地方引用该对象时计数器加1，当引用失效时计数器减1。用对象计数器是否为0来判断对象是否可被回收。 </p><p><img src="/WindShadow/JVM/Garbage-Collection/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%85%A5%E9%97%A8/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95.svg"></p><p>缺点：无法解决循环引用。</p><p>显然循环引用的多个对象也要被认为是垃圾，但是引用计数法无法定位到它们。</p><p><img src="/WindShadow/JVM/Garbage-Collection/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%85%A5%E9%97%A8/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95%E7%BC%BA%E7%82%B9.svg"></p><h3 id="根可达算法（roots-searching）"><a href="#根可达算法（roots-searching）" class="headerlink" title="根可达算法（roots searching）"></a>根可达算法（roots searching）</h3><p>顾名思义，一种以某种对象为起点的搜索算法，可以被搜索到（可达性）的对象就不认为是垃圾，反之不可达对象就是垃圾，这种作为起点的对象称之为GC Roots。</p><p>GC Roots主要有：线程栈变量、静态变量、常量池、JNI指针等</p><p><img src="/WindShadow/JVM/Garbage-Collection/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%85%A5%E9%97%A8/%E6%A0%B9%E5%8F%AF%E8%BE%BE%E7%AE%97%E6%B3%95.svg"></p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记清除（Mark-Sweep）"><a href="#标记清除（Mark-Sweep）" class="headerlink" title="标记清除（Mark - Sweep）"></a>标记清除（Mark - Sweep）</h3><p>优点：快</p><p>缺点：可用内存位置不连续，产生碎片</p><p><img src="/WindShadow/JVM/Garbage-Collection/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%85%A5%E9%97%A8/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.svg"></p><h3 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h3><p>优点：不产生内存碎片</p><p>缺点：浪费空间（8G的内存实际只能用4G）</p><p><img src="/WindShadow/JVM/Garbage-Collection/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%85%A5%E9%97%A8/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.svg"></p><h3 id="标记压缩（Mark-Compact）"><a href="#标记压缩（Mark-Compact）" class="headerlink" title="标记压缩（Mark - Compact）"></a>标记压缩（Mark - Compact）</h3><p>标记清除之后再进行一次压缩。</p><p>缺点：效率偏低</p><p><img src="/WindShadow/JVM/Garbage-Collection/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%85%A5%E9%97%A8/%E6%A0%87%E8%AE%B0%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95.svg"></p><h2 id="分代回收模型与分代回收算法"><a href="#分代回收模型与分代回收算法" class="headerlink" title="分代回收模型与分代回收算法"></a>分代回收模型与分代回收算法</h2><h3 id="JVM方法区（Method-Area）"><a href="#JVM方法区（Method-Area）" class="headerlink" title="JVM方法区（Method Area）"></a>JVM方法区（Method Area）</h3><p>JVM方法区中存在roots searching算法所需的GC Roots，所以还是要提一提。</p><p><strong>方法区只是一个逻辑概念（jvm规范中有言），对应1.7的永久代和1.8的元空间</strong></p><p><img src="/WindShadow/JVM/Garbage-Collection/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%85%A5%E9%97%A8/jvm%E6%96%B9%E6%B3%95%E5%8C%BA.svg"></p><p>永久代和元空间：</p><ul><li>永久代必须指定大小限制，元空间可设置也可不设置，无上限（受限于物理内存）</li><li>字符串常量1.7时存在于永久代，1.8后存在于堆中</li></ul><h3 id="JVM堆（Heap）"><a href="#JVM堆（Heap）" class="headerlink" title="JVM堆（Heap）"></a>JVM堆（Heap）</h3><p>JVM将堆内存区域分成新生代 + 老年代，各区域默认比例如图所示（可通过启动参数配置）</p><p><img src="/WindShadow/JVM/Garbage-Collection/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%85%A5%E9%97%A8/GC%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E6%A8%A1%E5%9E%8B.svg"></p><h3 id="Young-GC、Full-GC"><a href="#Young-GC、Full-GC" class="headerlink" title="Young GC、Full GC"></a>Young GC、Full GC</h3><p>在新生代触发的GC叫Young GC，即YGC，也叫Minor GC，在老年代触发的GC叫Full GC，即FGC，也叫Major GC。</p><h3 id="Eden区"><a href="#Eden区" class="headerlink" title="Eden区"></a>Eden区</h3><p>大多数情况下，对象会在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机会发起一次YGC。</p><h3 id="Survivor区"><a href="#Survivor区" class="headerlink" title="Survivor区"></a>Survivor区</h3><p>Survivor区相当于是Eden区和Tenured区的一个缓冲区，Survivor区又分为2个区，一个是From区，一个是To区。每次执行YGC时，会将Eden区中存活的对象放到Survivor的From区，在From区中仍存活的对象会移动到To区。From区和To区的逻辑关系会发生交换： From变To，To变From，目的是保证有连续的空间存放对方，避免内存碎片化。</p><h3 id="Tenured区（老年代）"><a href="#Tenured区（老年代）" class="headerlink" title="Tenured区（老年代）"></a>Tenured区（老年代）</h3><p>JVM给每个对象定义了一个对象年龄（Age）计数器；</p><p>如果对象在Eden出生并经过第一次YGC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每经历一次YGC（正常情况下，对象经历YGC后存活下来的时，会不断在Survivor的From与To区之间移动），年龄就增加1岁，当它的年龄增加到阈值（默认15岁，可以通过参数 <code>XX:MaxPretenuringThreshold</code> 设置 ），就将会晋升到老年代中。</p><h3 id="对象内存分配规则"><a href="#对象内存分配规则" class="headerlink" title="对象内存分配规则"></a>对象内存分配规则</h3><p>大多数情况下，对象会在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机会发起一次YGC。YGC相比FGC更频繁，回收速度也更快。而较大的对象（需要大量连续内存空间的Java对象 ）直接进入老年代。</p><p>通过YGC之后，Eden区中绝大部分对象会被回收，而那些存活对象，将会送到Survivor的From区，若From区空间不够，则直接进入老年代 。</p><h3 id="分代回收算法"><a href="#分代回收算法" class="headerlink" title="分代回收算法"></a>分代回收算法</h3><p>分代回收算法是融合上述3种基础垃圾回收算法的思想，而产生针对分代回收模型中不同代采用不同算法的一套组合拳。</p><ul><li>在新生代中，每次YGC都会有大批对象死去，少量对象存活，选用复制算法（Copying）来回收垃圾，只需复制出少量存活对象就可完成收集。复制成本低，效率高。</li><li>在老年代触发的FGC，虽然触发了GC，但是对象存活率高，没有额外空间对它进行分配担保，一般使用标记压缩（Mark - Compact）来进行回收，保证可用空间的连续性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> Garbage Collection </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>何为Java线程中断</title>
      <link href="WindShadow/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%BD%95%E4%B8%BAJava%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/"/>
      <url>WindShadow/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%BD%95%E4%B8%BAJava%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="何为Java线程中断"><a href="#何为Java线程中断" class="headerlink" title="何为Java线程中断"></a>何为Java线程中断</h1><p>Java线程中断是一个大多熟人不太关心的知识点，有的人可能一辈子也用不到，这是一位网络上的大牛说的。</p><p>Java线程的中断其实非常简单，说白了就是一个中断标志位的改变。先来看<code>Thread</code>类3个关于中断的方法：</p><ul><li><p>interrupt()：</p><p>实例方法，中断该线程；意思就是把中断标志位改为true。</p></li><li><p>isInterrupted()</p><p>实例方法，测试该线程是否被中断；显然，根据中断标志位返回true或false。</p></li><li><p>Thread.interrupted()</p><p>静态方法，测试当前线程是否中断；该方法与isInterrupted()类似，只不过，如果线程发生了中断，则把中断标志清除，也就是改为false。</p></li></ul><p>与中断相关的自然就是中断异常<code>InterruptedException</code>，当线程执行某些方法时不希望被中断，若被中断则抛出中断异常，如Thread.sleep()方法、Object#wait()方法。</p><h2 id="中断线程sleep休眠"><a href="#中断线程sleep休眠" class="headerlink" title="中断线程sleep休眠"></a>中断线程sleep休眠</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadInterruptedTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">currentTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">int</span> second)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(second * <span class="number">1000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;sleep中断异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建子线程 t 并启动</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程start - &quot;</span> + currentTime());</span><br><span class="line">            sleep(<span class="number">10</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;线程end - &quot;</span> + currentTime());</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程在2s后中断子线程 t</span></span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线程start - 16:13:53</span><br><span class="line">sleep中断异常</span><br><span class="line">线程end - 16:13:55</span><br></pre></td></tr></table></figure><h2 id="中断线程因调用Object-wait-方法进入等待的状态"><a href="#中断线程因调用Object-wait-方法进入等待的状态" class="headerlink" title="中断线程因调用Object#wait()方法进入等待的状态"></a>中断线程因调用Object#wait()方法进入等待的状态</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadInterruptedTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">currentTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object COMMON = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">waitOfCommon</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (COMMON) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                COMMON.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;等待COMMON被中断&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建子线程 t 并启动</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程start - &quot;</span> + currentTime());</span><br><span class="line">            waitOfCommon();</span><br><span class="line">            System.out.println(<span class="string">&quot;线程end - &quot;</span> + currentTime());</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程在2s后中断子线程 t</span></span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线程start - 16:20:43</span><br><span class="line">等待COMMON被中断</span><br><span class="line">线程end - 16:20:45</span><br></pre></td></tr></table></figure><p>如果不执行中断线程t，由于COMMON没有其它线程调用notify()方法或notifyAll()方法，线程 t 永远不会醒来。</p><p>我们知道，线程调用Object#wait()方法时，会释放该对象的锁，当其他线程拿到该对象的锁时，是否可以中断调用Object#wait()方法的线程？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadInterruptedTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">currentTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">int</span> second)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(second * <span class="number">1000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;sleep中断异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object COMMON = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建子线程 t1 并启动</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (COMMON) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1 start - &quot;</span> + currentTime());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    COMMON.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1 等待COMMON被中断&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1 end - &quot;</span> + currentTime());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">2</span>);<span class="comment">// 主线程休眠2s确保线程1 进入等待状态</span></span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (COMMON) &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;线程2 start - &quot;</span> + currentTime());</span><br><span class="line">                <span class="comment">// 每过一秒打印数字，打印6次</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;println &quot;</span> + i);</span><br><span class="line">                    sleep(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                COMMON.notifyAll(); <span class="comment">// 最后唤醒其它线程</span></span><br><span class="line">                System.out.println(<span class="string">&quot;线程2 end - &quot;</span> + currentTime());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程在2s后中断子线程 t1</span></span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;main end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">线程1 start - 16:56:10</span><br><span class="line">线程2 start - 16:56:12</span><br><span class="line">println 0</span><br><span class="line">println 1</span><br><span class="line">main end</span><br><span class="line">println 2</span><br><span class="line">println 3</span><br><span class="line">println 4</span><br><span class="line">println 5</span><br><span class="line">线程2 end - 16:56:18</span><br><span class="line">线程1 等待COMMON被中断</span><br><span class="line">线程1 end - 16:56:18</span><br></pre></td></tr></table></figure><p>可以看出，线程t 在等待状态时，虽然被中断，但此时 COMMON 对象的锁被线程2 持有，所以没有响应中断，当线程2 调用COMMON.notifyAll()方法，线程 1获得 COMMON 对象的锁，发现自己被中断了。</p><p><strong>推测线程在调用Object#wait()方法时，并没有立即让出锁，此时锁还在自己手上，但允许其它线程过来抢，直到有其它线程拿走锁后，才真正的失去锁。</strong></p><p><strong>所以对于Object#wait()方法，线程只有在获得监视对象的锁时才能响应该方法的中断。</strong></p><h2 id="中断线程因调用LockSupport-park-方法进入等待的状态"><a href="#中断线程因调用LockSupport-park-方法进入等待的状态" class="headerlink" title="中断线程因调用LockSupport.park()方法进入等待的状态"></a>中断线程因调用LockSupport.park()方法进入等待的状态</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 创建子线程 t 并启动</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;线程 start - &quot;</span> + currentTime());</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 end - &quot;</span> + currentTime());</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程在2s后中断子线程 t</span></span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        t.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;main end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线程1 start - 17:16:23</span><br><span class="line">main end</span><br><span class="line">线程1 end - 17:16:27</span><br></pre></td></tr></table></figure><p>当线程调用LockSupport.park()使cpu对其不再进行调度时，可以通过中断的方式唤醒（当然LockSupport.unpark(Thread)也可以），继续执行该线程。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>说了这么多，一般开发中线程中断用到的场景少之又少，更多的是出现在线程调度相关的操作中，如AQS，都是大佬们玩的。</p><p>似乎线程中断的设计就是为线程调度而设计的。开发中就算强行为了用而用，用其作为线程通信的手段，也会有更好的方案代替。</p>]]></content>
      
      
      <categories>
          
          <category> Java多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java线程池原理（二）</title>
      <link href="WindShadow/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>WindShadow/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Java线程池原理（二）"><a href="#Java线程池原理（二）" class="headerlink" title="Java线程池原理（二）"></a>Java线程池原理（二）</h1><p>承接上文，我们知道了线程池可以复用线程去执行任务，<code>Executors</code>工具类通过设置不同的参数来得到一些特性的线程池，那么继续深入，了解线程池是如何实现线程复用、核心线程的维持、非核心线程的存活控制，这些核心功能整体是如何运作的。</p><h2 id="线程复用、核心线程的维持、非核心线程的存活控制"><a href="#线程复用、核心线程的维持、非核心线程的存活控制" class="headerlink" title="线程复用、核心线程的维持、非核心线程的存活控制"></a>线程复用、核心线程的维持、非核心线程的存活控制</h2><h3 id="线程复用"><a href="#线程复用" class="headerlink" title="线程复用"></a>线程复用</h3><p>此小节重点讲线程池线程复用的机制，遇到一些影不易读懂的代码我们可以跳过。</p><p>首先，线程池executor方法是线程池的入口，顺着该方法分析，不难发现一个关键的方法：<code>addWorker(Runnable firstTask, boolean core)</code>，这个方法是负责添加Worker以执行任务的。</p><p>那么我们目的很明确，在此只需要关心3个点：1、具体添加了什么。2、任务怎么被执行的。3、firstTask和core参数怎么运用的。</p><h4 id="ThreadPoolExecutor的addWorker方法"><a href="#ThreadPoolExecutor的addWorker方法" class="headerlink" title="ThreadPoolExecutor的addWorker方法"></a>ThreadPoolExecutor的addWorker方法</h4><p><strong>这里我们先入为主一波：</strong></p><p>猜测该方法添加了一个叫Worker的东西，Worker内部使用一个boolean变量标识其内部Thread的性质是核心还是非核心线程，按照我们的常规的编程思路确实容易这样想。</p><p>接下来分析addWorker方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">        retry:<span class="comment">/// java 类似goto语句的语法，此处不重要</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                   firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                   ! workQueue.isEmpty()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">                <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">break</span> retry;</span><br><span class="line">                c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">                <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">                <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/// 0.1、前半段的代码的作用是通过cas进行自旋，先不必关心自旋干啥</span></span><br><span class="line">    <span class="comment">/// 0.2、只需知道 core 参数的作用也是参与到了其中，到此 core 参数的使命已经完成！后面已经用不到了</span></span><br><span class="line">        <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;<span class="comment">/// 1、标识worker是否启动的变量</span></span><br><span class="line">        <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;<span class="comment">/// 2、标识worker是否已经添加的变量</span></span><br><span class="line">        Worker w = <span class="keyword">null</span>;<span class="comment">/// 3、声明一个worker</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            w = <span class="keyword">new</span> Worker(firstTask);<span class="comment">/// 4、new 一个worker</span></span><br><span class="line">            <span class="keyword">final</span> Thread t = w.thread;<span class="comment">/// 5、拿到 worker 内的线程</span></span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">                mainLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                    <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                    <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                    <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                        workers.add(w);<span class="comment">/// 6、经过一系列状态等判断后，添加worker到workers中，阅读源码发现workers是ThreadPoolExecutor内部的一个保存worker的HashSet</span></span><br><span class="line">                        <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line">                        workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                    t.start();<span class="comment">/// 7、worker添加成功，启动worker内的线程</span></span><br><span class="line">                    workerStarted = <span class="keyword">true</span>;<span class="comment">/// 8、worker启动成功</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> workerStarted;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>总结：addWorker方法添加一个<code>Worker</code>到<code>ThreadPoolExecutor</code>保存worker的一个HashSet中，之后<code>Worker</code>内的Thread被启动。而firstTask参数作为<code>Worker</code>构造参数被使用，core参数仅参与了一个cas自旋操作，和<code>Worker</code>没啥关系。</p><p>显然，<strong>我们先入为主的想法并不正确</strong>。</p><p>前文讲到线程池内是通过<code>Worker</code>干活的，其内部有一个Thread在工作，<code>Worker</code>是线程池实现线程复用的关键。要了解线程池线程复用等原理势必要先了解<code>Worker</code>对象如何工作的。</p><h4 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h4><p><code>Worker</code>类是<code>ThreadPoolExecutor</code>的私有非静态内部类，继承了AQS且实现了<code>Runnable</code>接口，Java中的AQS在此不展开讲，到这里我们只需知道<code>Worker</code>继承了AQS使自身可对外提供加解锁的方法，外部的合理编码保证并发访问的安全性即可，即使不太了解AQS也没关系。通过<code>Worker</code>类的方法名也可大致知道是干什么的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/// 内部维护了一个线程，该线程通过线程池的线程工厂创建</span></span><br><span class="line">       <span class="keyword">final</span> Thread thread;</span><br><span class="line">       <span class="comment">/// 第一个任务</span></span><br><span class="line">       Runnable firstTask;</span><br><span class="line">       <span class="comment">/// 该参数保存已经完成的任务的数量</span></span><br><span class="line">       <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/// 构造方法，传入第一个任务，</span></span><br><span class="line">       Worker(Runnable firstTask) &#123;</span><br><span class="line">           setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">           <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">           <span class="comment">/// 将自身引用传入，通过线程池的线程工厂创建线程，</span></span><br><span class="line">           <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，<code>Worker</code>内部的Thread运行时，会调用<code>Worker</code>自身的run方法，看看<code>Worker</code>的run方法做了哪些事。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            runWorker(<span class="keyword">this</span>);<span class="comment">/// 调用外部ThreadPoolExecutor实例的runWorker方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ThreadPoolExecutor的runWorker方法"><a href="#ThreadPoolExecutor的runWorker方法" class="headerlink" title="ThreadPoolExecutor的runWorker方法"></a>ThreadPoolExecutor的runWorker方法</h4><p>来到<code>ThreadPoolExecutor</code>的runWorker方法，这个方法极其关键！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">        Thread wt = Thread.currentThread();<span class="comment">/// 1、获取当前线程，也就是worker内的线程</span></span><br><span class="line">        Runnable task = w.firstTask;<span class="comment">/// 2、获取worker内的firstTask，第一个任务</span></span><br><span class="line">        w.firstTask = <span class="keyword">null</span>;<span class="comment">/// 3、worker内的firstTask置空</span></span><br><span class="line">        w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">        <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;<span class="comment">/// 4、worker内的线程是否突然结束的标志</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;<span class="comment">/// 5、判断任务是否为空，否则通过getTask方法从工作队列获取任务</span></span><br><span class="line">                w.lock();</span><br><span class="line">                <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">                <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">                <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">                <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforeExecute(wt, task);<span class="comment">/// 6、调用任务之前的通知，空实现，子类可覆盖实现</span></span><br><span class="line">                    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        task.run();<span class="comment">/// 7、调用任务的run方法执行任务！！！</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        afterExecute(task, thrown);<span class="comment">/// 8、调用任务结束之后的通知，空实现，子类可覆盖实现</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;<span class="comment">/// 9、任务执行结束后，置空</span></span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly = <span class="keyword">false</span>;<span class="comment">/// 10、worker执行任务期间没有抛异常，worker内的线程正常结束工作</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            processWorkerExit(w, completedAbruptly); <span class="comment">/// 11、处理worker的退出逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>到这里，线程复用的机制很明了了：<strong>通过循环不断从工作队列中获取任务并执行</strong>；</p><p>不难总结出<code>Worker</code>的工作机制：<strong>worker通过实现Runnable接口，内部维护一个Thread线程对象，将自身作为“跳板”，优先执行自身初始化时携带的任务，之后不断消费（执行）线程池工作队列中的任务，直到队列中任务没有任务为止，worker的任务就结束了。</strong></p><p>用图表示<code>ThreadPoolExecutor</code>的runWorker方法主要的执行过程如下：</p><p><img src="/WindShadow/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/%E7%BA%BF%E7%A8%8B%E6%B1%A0runWorker%E6%96%B9%E6%B3%95.svg"></p><p>不过目前为止，我们还是没发现和核心线程与非核心线程相关的痕迹，带着疑问继续往下走。</p><h3 id="核心线程的维持、非核心线程的存活控制"><a href="#核心线程的维持、非核心线程的存活控制" class="headerlink" title="核心线程的维持、非核心线程的存活控制"></a>核心线程的维持、非核心线程的存活控制</h3><p>阅读<code>ThreadPoolExecutor</code>的runWorker方法，不难发现，每个<code>Worker</code>对象结束使命后，都会走到<code>ThreadPoolExecutor</code>的processWorkerExit方法执行退出逻辑。该方法入参除了<code>Worker</code>对象以外还需要传入一个boolean类型的completedAbruptly参数，见明之意，该参数表示该<code>Worker</code>对象是否是“突然结束”，不难发现只有任务task执行期间抛出异常或error，<code>Worker</code>对象才算是“突然结束”，completedAbruptly为true，反之正常结束，completedAbruptly为false。</p><h4 id="ThreadPoolExecutor的processWorkerExit方法"><a href="#ThreadPoolExecutor的processWorkerExit方法" class="headerlink" title="ThreadPoolExecutor的processWorkerExit方法"></a>ThreadPoolExecutor的processWorkerExit方法</h4><p>综上所述，processWorkerExit方法职责就是处理<code>Worker</code>对象正常与非正常的结束，也可以理解为对<code>Worker</code>的回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">            decrementWorkerCount();<span class="comment">/// 1、从上一行的英文注释和该方法的意义可知，对于非正常的结束的worker，需要调整当前线程池记录的worker数量，这里暂时不必关心如何调整</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            completedTaskCount += w.completedTasks;<span class="comment">/// 2、记录worker完成的任务数量到总完成数上</span></span><br><span class="line">            workers.remove(w);<span class="comment">/// 3、从HashSet中移除该worker</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tryTerminate();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;<span class="comment">/// 4、如果此时线程池状态不是结束状态</span></span><br><span class="line">            <span class="keyword">if</span> (!completedAbruptly) &#123;<span class="comment">/// 5、如果worker正常结束，if 内的逻辑可不关心</span></span><br><span class="line">                <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">                <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                    min = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">            &#125;</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);<span class="comment">/// 6、worker非正常结束，说明执行任务时抛了异常，需要补充一个新的worker，因为是补充的，其firstTask是null，而且是以非核心线程的设置去补充的</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>小总结一下processWorkerExit主要干了几件事：</p><ol><li>记录<code>Worker</code>对象完成的任务数到总记录中</li><li>移除该<code>Worker</code>对象</li><li>处理非正常结束<code>Worker</code>对象时，调整线程池记录的worker数量，补充一个新的worker且是以非核心线程的设定去补充的</li></ol><p>提一下为什么<code>Worker</code>非正常结束时要补充新的<code>Worker</code>：</p><ul><li>再仔细看runWorker方法，因为<code>Worker</code>非正常结束说明任务task的run方法抛出了异常（或error），尽管做了try-catch处理，作者的做法是把异常继续往抛出，而处理<code>Worker</code>的回收工作processWorkerExit方法是在finally块执行的，也就是说processWorkerExit方法执行完之后，异常就要被抛出去了，虚拟机接受到异常之后，就会销毁该线程，也就是销毁<code>Worker</code>内的Thread（线程死亡），此时需要补充新的<code>Worker</code>继续干活。</li><li><em>此处给读者留下一个小思考：既然runWorker方法catch到了异常或error，可以不抛出去吗？</em></li></ul><p>不过跟踪到这里还是没发现核心线程与非核心线程相关的操作，而且在补充新的worker时，还是以非核心线程去补充的，这也是疑问点，并且如果每个<code>Worker</code>使命结束后都要移除了，<code>Worker</code>内的线程也执行完代码也要结束生命了，说好的核心线程不会被销毁呢？</p><h4 id="ThreadPoolExecutor的getTask方法"><a href="#ThreadPoolExecutor的getTask方法" class="headerlink" title="ThreadPoolExecutor的getTask方法"></a>ThreadPoolExecutor的getTask方法</h4><p>回过头看，我们还差一个方法没有分析，那就是<code>ThreadPoolExecutor</code>的getTask方法，在runWorker方法中<code>Worker</code>通过getTask从工作队列中获取任务，不难得出：<strong>如果获取的任务为null，Worker将被回收</strong>。而工作队列是阻塞队列，所以如果<code>Worker</code>在获取任务时被阻塞，那么就不会被回收，从而实现<code>Worker</code>内Thread的“常驻”效果，这确实是个思路。话不多说进源码。</p><p>下列代码笔者将保留原生的官方英文注释，增加自己的注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 1、超时的标记变量，官方注释很明了：是否是因为上一次执行阻塞队列poll 方法导致的超时</span></span><br><span class="line">        <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// 2、注意这里的判断，如果为true，说明线程池状态不处于running，如果是shutdow，则再判断工作队列是否为空，为空则返回null，其余的状态也返回null，worker将被回收</span></span><br><span class="line">            <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">                decrementWorkerCount();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);<span class="comment">/// 3、获取当前worker数量</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/// 4、当允许核心线程超时（默认是不允许false）或当前worker数量大于核心线程数时，表示该worker可能需要回收，这里利用一个boolean来标记</span></span><br><span class="line">            <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">            <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"><span class="comment">/// 5、满足指定条件（注意两个逻辑或运算以及逻辑或运算的特点），说明该worker的确需要回收</span></span><br><span class="line">            <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">                &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))<span class="comment">/// 6、尝试比较并将worker总记录数减1，成功返回null，失败则进入下一次循环</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Runnable r = timed ? </span><br><span class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<span class="comment">/// 7、该worker可能需要回收，则调用 poll 方法等待一定时间</span></span><br><span class="line">                    workQueue.take();<span class="comment">/// 8、该worker不需要回收，take 方法一直等待直到获取到任务</span></span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                timedOut = <span class="keyword">true</span>;<span class="comment">/// 9、如果为null，那一定是调用 poll 方法超时了</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;<span class="comment">/// 10、捕获队列出队时可能的中断异常，暂时不必关系</span></span><br><span class="line">                timedOut = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码比较短但是比较精妙，需要反复揣摩，下面贴出笔者制作的流程图</p><p><img src="/WindShadow/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/ThreadPoolExecutor%E7%9A%84getTask%E6%96%B9%E6%B3%95.svg"></p><p>到此，终于看到线程池七八成左右的真身了：runWorker方法使worker不断执行任务和任务通知，processWorkerExit方法负责worker的回收工作，而<strong>getTask方法负责从工作队列获取任务进一步控制worker内Thread的阻塞等待，进一步控制worker的回收，从而实现核心线程的常驻效果和非核心线程的存活控制。</strong></p><h2 id="提交优先级与执行优先级"><a href="#提交优先级与执行优先级" class="headerlink" title="提交优先级与执行优先级"></a>提交优先级与执行优先级</h2><p>有如下程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>,<span class="number">20</span>,</span><br><span class="line">               <span class="number">300L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">               <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>),</span><br><span class="line">               <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">           System.out.println(<span class="string">&quot;execute: &quot;</span> + i);</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> n = i;</span><br><span class="line">           executor.execute(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">               System.out.println(<span class="string">&quot;start run number: &quot;</span> + n);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   TimeUnit.SECONDS.sleep(<span class="number">100000L</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问：提交到第几个任务（i = ?）时，线程池拒绝执行任务而抛出异常？</p><p>答：i = 31时。</p><p>线程池可接受的最大任务数量为：最大线程数+工作队列容量=30。上述每个任务都进行了一次长时间睡眠，显然for循环体积任务执行完之前，线程池内没有一个任务执行完。</p><p>值得注意的是，控制台打印的“start run number: {n}”字符串，应该是1<del>10左右先被打印，其次是21</del>30后被打印，最后是11~20区间的数字被打印，而不是我们生活中任务认为的“先提交就先得到执行”。</p><p>于是结合addWorker方法得出线程池<strong>提交优先级</strong>：</p><p>核心线程 &gt; 工作队列 &gt; 非核心线程</p><p>于是结合getTask方法得出线程池<strong>执行优先级</strong>：</p><p>核心线程 &gt; 非核心线程 &gt; 工作队列</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过以上4个方法的解读，我们可以重新认识worker对象：</p><ul><li>通俗的说每个worker被创建之后，其使命就是不断从工作队列领取任务去执行，在<strong>无任务可执行</strong>（不是任务全部执行完毕，两者概念差别很大），即领取不到任务之后，就要被回收。</li></ul><p>不仅如此，核心线程与非核心线程也要重新理解：</p><ul><li>核心线程：worker对象内的线程在获取任务前，线程池状态处于running，此时若当前worker数（反应线程池内的线程数）小于等于设置的核心线程数，该线程以<strong>poll</strong>方式方式获取任务，若工作队列无任务，则该线程将一直等待新的任务提交进来，该线程也就顺理成章的成为线程池常驻线程，也就是核心线程</li><li>非核心线程：worker对象内的线程在获取任务前，线程池状态处于running，此时若当前worker数（反应线程池内的线程数）大于设置的核心线程数，该线程以<strong>take</strong>方式方式获取任务，若工作队列无任务，则该线程将等待新的任务提交进来，等待时长为<strong>keepAliveTime</strong>，超时之后便会被对应worker被回收，等待期间该线程也就成为线程池非核心线程。</li></ul><p>所以每个worker内的线在启动工作期间都是相同的性质，不分核心与非核心，只有工作队列<strong>无任务可执行</strong>时，才能明确线程的性质是核心还是非核心，同时也决定了worker的回收与否（既分高下，也决生死？！）。</p><p>回过头来看addWorker方法中表示线程类型的core参数，也只是参与了当前worker数与核心线程数或非核心线程数的比较，再无他用，这也说的通了。</p><p>在阅读这些方法中，我们跳过了一些“影响阅读”的代码，如worker自身的lock和unlock究是为了防止啥，<code>ThreadPoolExecutor</code>成员变量中<code>ReentrantLock</code>的mainLock保证了什么的线程安全，以及线程池自身的其它功能，如线程池的worker数量和状态等如何感知的……请听下回合分解。</p>]]></content>
      
      
      <categories>
          
          <category> Java多线程 </category>
          
          <category> Java线程池原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySql索引详解</title>
      <link href="WindShadow/MySql/MySql%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/"/>
      <url>WindShadow/MySql/MySql%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>了解索引之前先了解一下约束。</p><h2 id="约束（constraint）"><a href="#约束（constraint）" class="headerlink" title="约束（constraint）"></a>约束（constraint）</h2><p>约束实际上就是表中数据的限制条件 ，表在设计的时候加入约束的目的就是为了保证表中的记录完整和有效 ，常见约束如下</p><h3 id="非空约束（not-null）"><a href="#非空约束（not-null）" class="headerlink" title="非空约束（not null）"></a>非空约束（not null）</h3><p>约束的字段不能为null</p><h3 id="唯一性约束（unique）"><a href="#唯一性约束（unique）" class="headerlink" title="唯一性约束（unique）"></a>唯一性约束（unique）</h3><p>约束的字段是唯一的（可以为null），Mysql会为该字段会自动创建索引。</p><p>唯一性约束也称<strong>列级约束</strong>。</p><h3 id="主健约束（primary-key-简称PK-）"><a href="#主健约束（primary-key-简称PK-）" class="headerlink" title="主健约束（primary key(简称PK)）"></a>主健约束（primary key(简称PK)）</h3><p>表中的某个字段添加主键约束后，该字段为主键字段，主键字段中出现的每一个数据都称为主键值，必须唯一且不能为null，即primary key = unique + not null。当一个字段同时被非空约束和唯一性约束时，自动成为主键。<strong>但oracle并不如此。</strong></p><p>主键约束也称<strong>表级约束</strong>。</p><ul><li>单一主键：给一个字段添加主键约束</li><li>复合主键：给多个字段联合添加一个主键约束(只能用表级定义)，用的少</li></ul><h3 id="外键约束（foreign-key-简称FK-）"><a href="#外键约束（foreign-key-简称FK-）" class="headerlink" title="外键约束（foreign key (简称FK)）"></a>外键约束（foreign key (简称FK)）</h3><p>若有两个表A、B，id是A的主键，而B中也有id字段，则id就是表B的外键，外键约束主要用来维护两个表之间数据的一致性。</p><p>某个字段添加外键约束之后，该字段称为外键字段，外键字段中每个数据都是外键值。</p><ul><li>外键必须至少是受唯一性约束的。</li><li>外键值可以为null。</li><li>一张表可以有多个外键字段。</li></ul><h3 id="检查约束（check-mysql不支持，oracle支持））"><a href="#检查约束（check-mysql不支持，oracle支持））" class="headerlink" title="检查约束（check (mysql不支持，oracle支持））"></a>检查约束（check (mysql不支持，oracle支持））</h3><p>略</p><h2 id="索引概念"><a href="#索引概念" class="headerlink" title="索引概念"></a>索引概念</h2><p>MySql官方对索引的定义为：索引（Index)）是帮助MySql高效获取数据的数据结构。</p><p>提取句子主干，就可以得到索引的本质：索引是数据结构。</p><p>在mysql当中，使用<code>explain</code>关键字查看一个SQL语句是否使用了索引进行检索</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_user</span><br></pre></td></tr></table></figure><p>观察查询结果<code>key</code>列中是否列出了显示MySQL实际决定使用的键(索引) ，未使用则为null。</p><p>同时，<strong>索引是各种数据库进行优化的重要手段</strong>。</p><h2 id="索引实现原理"><a href="#索引实现原理" class="headerlink" title="索引实现原理"></a>索引实现原理</h2><ul><li>在MySql当中，索引是一个单独的对象，不同的存储引擎以不同的形式存在。</li><li>在MyISAM存储引擎中，索引存储在一个.MYI文件中。</li><li>在InnoDB存储引擎中索引存储在表空间（tablespace）中。</li><li>在MEMORY存储引擎当中索引被存储在内存当中。</li><li>不管索引存储在哪里，索引在mysql当中都是一个<strong>B+树</strong>的形式存在。</li></ul><p><em>（至于为啥MySql使用B+树作为存储的数据结构，一时半会也说不明白，笔者也是略知一二，不想在这强行装X，目前知道B+树的结构就好了）</em></p><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><p>是最基本的索引，它没有任何限制。</p><p>创建示例：</p><ul><li><p>直接创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name ON table(column(length));</span><br></pre></td></tr></table></figure></li><li><p>修改表结构创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD INDEX index_name ON (column(length));</span><br></pre></td></tr></table></figure></li><li><p>创建表时创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;table&#96; (</span><br><span class="line">    &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">    &#96;org&#96; char(255) CHARACTER NOT NULL ,</span><br><span class="line">    PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">    INDEX index_name (org(length))</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><p>删除索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX index_name ON table</span><br></pre></td></tr></table></figure><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>与普通索引类似，不同之处在于：索引列的值必须唯一，但允许有空值，即列受<strong>唯一性约束（unique</strong>）；显然的，一张表可以有多个唯一索引。</p><p>创建唯一索引：</p><ul><li><p>直接创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX index_name ON table(column(length));</span><br></pre></td></tr></table></figure></li><li><p>修改表结构创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD UNIQUE index_name ON (column(length));</span><br></pre></td></tr></table></figure></li><li><p>创建表时创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;table&#96; (</span><br><span class="line">    &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">    &#96;org&#96; char(255) CHARACTER NOT NULL ,</span><br><span class="line">    PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">    UNIQUE  index_name (org(length))</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>一种特殊的唯一索引。</p><ul><li>主键不可重复，只能有一个列作为主键</li><li>一张表中主键索引只能存在一个</li></ul><p>一般是在建表的时候同时创建主键索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;table_name&#96; (</span><br><span class="line">    &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">    &#96;org&#96; char(255) CHARACTER NOT NULL ,</span><br><span class="line">    PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="组合（复合、联合）索引"><a href="#组合（复合、联合）索引" class="headerlink" title="组合（复合、联合）索引"></a>组合（复合、联合）索引</h3><p>指多个字段上创建的索引</p><ul><li>组合索引中，列值的组合必须唯一。</li><li>只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。</li><li>使用组合索引时遵循最左前缀集合</li></ul><p>创建方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD INDEX fa_fb_fc (fa,fb,fc); </span><br></pre></td></tr></table></figure><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p> InnoDB 存储引擎在MySql 5.6 之后才支持。</p><p>只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD FULLTEXT INDEX index_name (column1,column2,...);</span><br></pre></td></tr></table></figure><p>跟普通索引稍有不同，使用全文索引的格式<code>MATCH (columnName) AGAINST (&#39;string&#39;)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &#96;table_name&#96; WHERE MATCH(&#96;name&#96;) AGAINST(&#39;马&#39;)</span><br></pre></td></tr></table></figure><p>match() 函数中指定的列必须和全文索引中指定的列完全相同，否则就会报错，无法使用全文索引，这是因为全文索引不会记录关键字来自哪一列。如果想要对某一列使用全文索引，需要单独为该列创建全文索引。</p><h2 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h2><p>常见的索引失效情况：</p><ol><li><p>以”%”开头进行模糊查询，索引失效（后缀有%时 不失效）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 有索引</span><br><span class="line">ALTER TABLE tableName ADD INDEX （col); </span><br><span class="line">select * from tableName where col like &#39;%T&#39;;</span><br></pre></td></tr></table></figure><p>尽量避免模糊查询的时候以”%”开始,这是一种优化的手段/策略。</p></li><li><p>or 操作两边未同时使用索引，索引失效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 有索引</span><br><span class="line">ALTER TABLE tableName ADD INDEX （col1); </span><br><span class="line"># or 查询</span><br><span class="line">select * from tableName where col1 &#x3D; 100 or col2 &#x3D; &#39;tom&#39;;</span><br></pre></td></tr></table></figure><p>如果使用or那么要求or两边的条件字段都要有索引，才会走索引，如果其中一边有一个字段没有索引，那么另一个字段上的索引也会失效。</p></li><li><p>使用组合（复合）索引时，未使用左侧的列，索引失效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 有索引</span><br><span class="line">ALTER TABLE tableName ADD INDEX fa_fb_fc (fa,fb,fc); </span><br><span class="line"># 查询时未使用左侧的列</span><br><span class="line">select * from tableName where fc &#x3D; 100;</span><br></pre></td></tr></table></figure><p>遵循最左前缀集合。</p></li><li><p>数据类型出现隐式转化。如varchar不加单引号的话可能会自动转换为int型，使索引无效，产生全表扫描</p></li><li><p>在索引字段上使用not，&lt;&gt;，!=。不等于操作符是永远不会用到索引，对它的处理只会产生全表扫描。 优化方法： key&lt;&gt;0 改为 key&gt;0 or key&lt;0。很显然，索引是想知道你要什么而不是你不要什么，你品你细品。</p></li><li><p>索引的列参加了运算，索引失效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 有索引</span><br><span class="line">ALTER TABLE tableName ADD INDEX fa_fb_fc (fa,fb,fc); </span><br><span class="line"># 查询</span><br><span class="line">select * from tableName where fa + 1 &#x3D; 101;</span><br></pre></td></tr></table></figure><p>说实话，没人写这种sql吧。</p></li><li><p>索引的列使用了函数，索引失效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 有索引</span><br><span class="line">ALTER TABLE tableName ADD INDEX fa_fb_fc (fa,fb,fc); </span><br><span class="line"># 查询</span><br><span class="line">select * from tableName where lower(fb)&#x3D; &#39;tom&#39;;</span><br></pre></td></tr></table></figure></li></ol><p>还有一点要注意的是：当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效。</p><p>说白了就一句话：索引是想要你直接告诉它你想要什么，而不是你不要什么，也不是你把这个东西（字段）包装之后，说包装完就是这样子，给我找。<code>┐(´-｀)┌</code>  </p><h2 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h2><p>mysql的索引分为两大类：<strong>聚簇索引、非聚簇索引</strong>，<strong>它们不是一种单独的索引类型，而是一种数据存储方式</strong></p><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>将数据存储与索引放到了一块，找到索引也就找到了<strong>数据（严格来说这里的数据指的是行的物理位置</strong>），由于聚簇索引是将数据跟索引结构放到一块，因此一个表仅有一个聚簇索引。</p><p>如果表中没有定义主键，则第一个not NULL unique列是聚集索引。如果没有这样的索引，InnoDB 会隐式定义一个主键来作为聚簇索引。</p><p>下面是聚簇索引B+树的结构示意图</p><p><img src="/WindShadow/MySql/MySql%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/MySql%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.svg"></p><h3 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h3><p>非聚簇索引也叫辅助索引或二级索引，非聚簇索引叶子节点存储的不再是<strong>数据（行的物理位置</strong>），而是主键值</p><p>下面是非聚簇索引B+树的结构示意图</p><p><img src="/WindShadow/MySql/MySql%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/MySql%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.svg"></p><h3 id="回表-1"><a href="#回表-1" class="headerlink" title="回表"></a>回表</h3><p>先通过非聚簇索引定位到主键值，在通过聚簇索引定位到行记录，这就是所谓的<strong>回表或回表查询</strong>，先定位主键值，再定位行记录，它的性能较扫一遍索引树更低。</p><h2 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h2><p>MySql官网类似的说法是：使用explain查询计划时，explain的输出结果Extra字段为Using index时，能够触发索引覆盖。</p><p>也就是如果触发了索引覆盖，那么explain输出的Extra字段为Using index。</p><p>一般的说法是：索引中已经包含所有需要读取的列的查询称为覆盖索引。</p><p>就是利用优化器的优化机制，只搜索了非聚簇索引，不进行回表操作，然后达到select的目的。一般主要适用于select出的字段很少的情况。</p><p>举例：</p><p>有张user表（PK id,name, age, email, address，……），我们的模板是<code>select name, age</code> ，然后只需要建立一个name和age的复合索引，然后这个非聚簇索引的叶子节点有了这两个字段和主键字段（虽然主键在这里没啥用）。然后执行器只需要搜索这个二级索引即可，不需要回表操作就完成了select查询操作。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>主键上以及unique字段是上都会自动添加索引</li><li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行insert、update和delete时。因为更新表时，不仅要保存数据，还要保存一下索引文件。</li><li>建立索引会占用磁盘空间的索引文件。一般情况影响不大，但如果在一个大的表上创建了多种组合索引，索引文件大小会增长的很快。</li><li>索引只是提高效率的一个因素，如果有大数据量的表，就需要花时间研究建立最优的索引，或优化查询语句。 </li></ul>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySql事务</title>
      <link href="WindShadow/MySql/MySql%E4%BA%8B%E5%8A%A1/"/>
      <url>WindShadow/MySql/MySql%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>前提摘要：MySql只有使用InnoDB 引擎时才支持事务，MyISAM 引擎不支持事务</p><p><strong>存储引擎</strong>：存储引擎是MySql中特有的一个术语，其它数据库中没有，比如oracle中有，但是不叫这个名字。</p><p>存储引擎听着高端大气上档次，实际上存储引擎是一个表存储/组织数据的方式。不同的存储引擎，表存储数据的方式不同。</p><h2 id="事务的基础知识点"><a href="#事务的基础知识点" class="headerlink" title="事务的基础知识点"></a>事务的基础知识点</h2><ul><li><strong>只有DM语句（insert、delete、update）才会有事务这一说</strong>，其它语句和事务无关! ! !因为只有以上的三个语句是数据库表中数据进行增、删、改的。只要操作一旦涉及到数据的增、删、改，那么就一定要考虑安全问题。</li><li><strong>InnoDB存储引擎提供一组用来记录事务性活动的日志文件</strong></li><li>MySql默认开启自动提交<code>auto commit</code>，开启MySql的事务<code>start transcation</code>可关闭自动提交，需要手动提交会回滚事务。</li><li>提交事务（commit）：清空事务性活动的日志文件，将数据全部彻底持久化到数据库表中。提交事务标志着，事务的结束。并且是一种全部成功的结束。</li><li>回滚事务(rollback)：将之前所有的DML操作全部撤销，并且清空事务性活动的日志文件。回滚事务标志着，事务的结束。并且是一种全部失败的结束。</li></ul><h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><p>ACID：</p><ul><li>A（Atomicity）原子性：指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</li><li>C（Consistency）一致性：事务前后数据的<strong>完整性</strong>必须保持一致。</li><li>I（Isolation）隔离性：事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。</li><li>D（Durability）持久性：持久性是指一个事务一旦被提交，它对数据库中数据的改变应该永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</li></ul><h2 id="MySql事务隔离级别"><a href="#MySql事务隔离级别" class="headerlink" title="MySql事务隔离级别"></a>MySql事务隔离级别</h2><p>4个隔离级别，从低到高</p><h3 id="1-读未提交（-read-uncommitted）"><a href="#1-读未提交（-read-uncommitted）" class="headerlink" title="1. 读未提交（ read uncommitted）"></a>1. 读未提交（ read uncommitted）</h3><p>描述：事务A可读取到事务B的未提交的数据；</p><p>存在问题：<strong>脏读</strong></p><p>这种隔离级别一般都是理论上的，大多数的数据库隔离级别都是2档起步！</p><h3 id="2-读已提交（-read-committed）"><a href="#2-读已提交（-read-committed）" class="headerlink" title="2. 读已提交（ read committed）"></a>2. 读已提交（ read committed）</h3><p>描述：事务A只能读取到事务B的提交后的数据；</p><p>解决了脏读问题；</p><p>存在问题：<strong>不可重复读</strong></p><p>这种隔离级别是比较真实的数据，每一次读到的数据是绝对的真实。oracle数据库默认的隔离级别是: read committed。</p><h3 id="3-可重复读（repeatable-read）"><a href="#3-可重复读（repeatable-read）" class="headerlink" title="3. 可重复读（repeatable read）"></a>3. 可重复读（repeatable read）</h3><p>描述：事务A开启之后，不管是多久，每一次在事务A中读取到的数据都是一致的。即使事务B将数据已经修改，并且提交了，事务A读取到的数据还是没有发生改变，这就是可重复读。</p><p>存在问题：<strong>幻读</strong></p><p>mysql中默认的事务隔离级别是：repeatable read。</p><h3 id="4-串行化（serializable）"><a href="#4-串行化（serializable）" class="headerlink" title="4. 串行化（serializable）"></a>4. 串行化（serializable）</h3><p>事务最高隔离级别，效率最低，类似Java中使用synchronize进行线程同步，此处便是事务同步，将事务串行化执行。</p><h3 id="事务并发问题"><a href="#事务并发问题" class="headerlink" title="事务并发问题"></a>事务并发问题</h3><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据。</p><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>事务 A 多次读取同一条数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致（不能重复读）。</p><p>举例，有事务T1、T2</p><p>T1：1、根据条件X查询一组数据；2、对该组的每条记录进行修改；3、根据条件X查询一组数据；</p><p>T2：1、插入满足条件X的一条记录；</p><p>当T2的步骤1在T1的步骤1之后执行，提交之后，T1的步骤3再次查询时，发现有一条记录没有被更改，这就是不可重复读。</p><p>不可重复读通常针对数据更新（UPDATE）操作来说的。</p><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>举例，有两个事务T1、T2</p><p>T1：1、查询主键id为1001的数据，结果为不存在；2、插入id为1001的数据；</p><p>T2：1、插入id为1001的数据；</p><p>当T2的步骤1在T1的步骤1之后执行，提交之后，T1的步骤2因为主键冲突将无法执行。就好比T1“见鬼”了，明明查询不存在但是插入失败。</p><p>幻读更针对于对数据插入（INSERT）操作和删除（DELETE）来说的。</p><p><strong>不可重复读和幻读的区别</strong></p><p>网上有很多幻读的例子，但是讲的都略微牵强，经笔者查阅和理解，不可重复的侧重于两次读的操作，即：读-读。而幻读侧重于：读-写。上述幻读的例子中，T1的步骤1不能支持其步骤2的进行。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交（read uncommitted）</td><td>是</td><td>是</td><td>是</td></tr><tr><td>读已提交（read committed）</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读（repeatable read）</td><td>否</td><td>否</td><td>是</td></tr><tr><td>串行化（serializable）</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><p>隔离级别越高，越能保证数据的完整性和一致性，对并发性能的影响也越大。</p>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java线程池原理（一）</title>
      <link href="WindShadow/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>WindShadow/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Java线程池原理（一）"><a href="#Java线程池原理（一）" class="headerlink" title="Java线程池原理（一）"></a>Java线程池原理（一）</h1><p>众所周知<strong>Executor</strong>框架中的<code>ExecutorService</code>接口的实现就是<code>ThreadPoolExecutor</code>线程池，本文《Java线程池原理》系列从源码角度捋一捋线程池的重点实现。</p><p>在此之前先聊聊<code>ThreadPoolExecutor</code>的作者：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Doug%20Lea/6319404?fr=aladdin">Doug Lea</a></p><p><img src="/WindShadow/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/Doug.jpg" alt="Doug Lea"></p><p>Doug Lea是 java.util.concurrent 包（JUC）的作者，不少网友评价Doug Lea是JDK史上最牛*的程序员，甚至有人感叹：“编程不识Doug Lea，写尽java也枉然”。</p><p><img src="/WindShadow/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/nb.gif"></p><p>接下来盘点<code>ThreadPoolExecutor</code>线程池的基本工作原理和<code>Executors</code>工具类提供的几种常见线程池的效果，简单入个门。</p><h2 id="线程池存在的意义"><a href="#线程池存在的意义" class="headerlink" title="线程池存在的意义"></a>线程池存在的意义</h2><p>我们知道当下常见的jvm使用的线程都是内核级线程（KLT）。显然，线程是稀缺资源，它的创建与销般是一个相对偏重且耗资源的操作，而Java线程依赖于内核线程，创建线程需要进行操作系统状态切换，<strong>为避免资源过度消耗需要设法重用线程执行多个任务</strong>。</p><p>所以线程池就是一个线程缓存，负责对线程进行统一分配、调优与监控。</p><p>一般什么时候使用线程池？</p><ul><li>单个任务处理时间比较短</li><li>需要处理的任务数量很大</li><li>比较耗时的任务不建议使用线程池，因为容易造成任务的堆积</li></ul><h2 id="线程池基本工作原理"><a href="#线程池基本工作原理" class="headerlink" title="线程池基本工作原理"></a>线程池基本工作原理</h2><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>jdk提供的线程池实现为<code>ThreadPoolExecutor</code>类（常用就这个类）</p><p><img src="/WindShadow/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/ThreadPoolExecutor.png" alt="ThreadPoolExecutor"></p><p>其中前3个构造方法都依赖最后一个构造方法，其含义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, /// 核心线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize, /// 最大线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime, /// 非核心线程空闲后的存活时间的数量值</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit, /// 非核心线程空闲后的存活时间的单位</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue, /// 工作队列（阻塞队列）</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory, /// 线程工厂，主要负责创建线程</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123; <span class="comment">/// 拒绝策略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拓扑如下</p><p><img src="/WindShadow/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BB%84%E6%88%90.svg" alt="Java 线程池 ThreadPoolExecutor "></p><ul><li><p>线程工厂：负责创建线程</p></li><li><p>工作队列：一个保存任务的阻塞队列（阻塞队列：多线程下保证队列的FIFO特性）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过Runnable对象创建线程</span></span><br><span class="line">    <span class="function">Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Worker：线程池实现线程复用以执行任务的核心对象（见下文），自身实现了<code>Runnable</code>接口且内部维护了一个<code>Thread</code>线程对象</p></li><li><p>核心线程：Worker对象内的线程，线程池常驻线程，成为核心线程的线程不会被销毁</p></li><li><p>非核心线程：Worker对象内的线程，成为非核心线程的线程进入空闲后，只会存活一定时间（keepAliveTime），之后便正常结束线程。</p></li><li><p>拒绝策略：任务无法添加时，线程池执行拒绝策略。<code>ThreadPoolExecutor</code>提供四种如图所示的拒绝策略，实现<code>RejectedExecutionHandler</code>接口自身定义拒绝策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h3><p>类似线程的状态，线程池也有自己的状态</p><ul><li><p>Running：运行状态，接受新任务，也能处理工作队列里的任务</p></li><li><p>Shutdown：关闭状态，不接受新任务，但是处理工作队列里的任务</p></li><li><p>Stop：停止状态，不接受新任务，不处理工作队列里的任务，中断正在处理中的任务</p></li><li><p>Tidying：整理状态，当所有的任务都执行完了，当前线程池已经没有工作线程，这时线程池将会转换为Tidying状态，并且将要调用terminated方法。terminated方法调用完毕之后，线程池进入Terminated状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123; &#125; <span class="comment">/// ThreadPoolExecutor terminated方法为空实现，子类可覆盖实现</span></span><br></pre></td></tr></table></figure></li><li><p>Terminated：终止状态，terminated方法调用完毕之后，线程池进入Terminated状态。</p></li></ul><p>其关系如图（对线程池工作原理有所了解后再回头看此状态转换图会更好）。</p><p><img src="/WindShadow/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81.svg"></p><h3 id="线程池添加任务流程"><a href="#线程池添加任务流程" class="headerlink" title="线程池添加任务流程"></a>线程池添加任务流程</h3><p>我相信大多数人都比较清楚线程池添加任务的流程，各种博客网图巴拉巴拉，这里再哔哔一下线程池提交任务的流程，如下：</p><p><img src="/WindShadow/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E6%B5%81%E7%A8%8B.svg" alt="线程池执行任务流程"></p><p>我们通常通过执行<code>ThreadPoolExecutor</code>实现<code>Executor</code>接口的execute方法（<code>Executor#execute(Runnable)</code>）来提交任务，这个流程就是来自该方法的实现！！！</p><p>贴一下源码，官方注释给你讲的明明白白，代码也很清晰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">         * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">         * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">         * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">         * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">         * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">         * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">         * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">         * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">         * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">         * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">         * and so reject the task.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123; <span class="comment">/// 1、核心线程是否已经满</span></span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))<span class="comment">/// 2、添加worker，以核心线程消费任务(第二个参数为true)</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<span class="comment">/// 3、添加到工作队列是否可行</span></span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))<span class="comment">/// 4、添加worker，以非核心线程消费任务(第二个参数为false)</span></span><br><span class="line">            reject(command);<span class="comment">/// 5、如果添加失败，说明非核心线程是否已经满，执行拒绝策略</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Executors工具类提供的常见线程池"><a href="#Executors工具类提供的常见线程池" class="headerlink" title="Executors工具类提供的常见线程池"></a>Executors工具类提供的常见线程池</h2><h3 id="可缓存线程池Executors-newCachedThreadPool"><a href="#可缓存线程池Executors-newCachedThreadPool" class="headerlink" title="可缓存线程池Executors.newCachedThreadPool()"></a>可缓存线程池Executors.newCachedThreadPool()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：核心线程数为0，最大线程数为<code>Integer.MAX_VALUE</code>，工作队列为<strong>同步移交队列</strong>；</p><p>新增任务：核心线程数为0 =&gt; 任务提交到工作队列 =&gt; 工作队列提交时阻塞直到有线程从队列获取任务。</p><p>很显然，每个任务都会交由非核心线程来完成。而非核心线程在任务全部执行完毕后只会存在一定时间（60s），所以这是具有缓存效果的线程池（Cached）。</p><h3 id="固定线程数量线程池Executors-newFixedThreadPool"><a href="#固定线程数量线程池Executors-newFixedThreadPool" class="headerlink" title="固定线程数量线程池Executors.newFixedThreadPool()"></a>固定线程数量线程池Executors.newFixedThreadPool()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>分析：核心线程数为固定值，最大线程数与核心线程数相同，工作队列为<strong>无界队列</strong>；</p><p>无界队列：队列可存储的元素没有上限，概念上是如此，但实际受数据类型值范围限制，所以无界队列在Java中指可存放元素的最大值为<code>Integer.MAX_VALUE</code>的队列。</p><p><code>LinkedBlockingQueue</code>无参构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(Integer.MAX_VALUE);<span class="comment">// 队列元素最大数量为Integer.MAX_VALUE</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>新增任务：当核心线程数已满时，任务都存到工作队列，由于工作队列是无界的，所以队列永远不会满（概念上不会满），所以非核心线程没有存在的必要，即maximumPoolSize - corePoolSize = 0。</p><p>很显然，在固定线程数量线程池中，提交的每个任务都会交由核心线程来完成，核心线程数量固定，非核心线程数量为0，线程池常驻线程数量固定，所以称之为拥有固定线程数量的线程池（Fixed）。</p><h3 id="单线程线程池Executors-newSingleThreadExecutor"><a href="#单线程线程池Executors-newSingleThreadExecutor" class="headerlink" title="单线程线程池Executors.newSingleThreadExecutor()"></a>单线程线程池Executors.newSingleThreadExecutor()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">           (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                   <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                   <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>FinalizableDelegatedExecutorService</code>，仅重写了finalize方法，调用父类<code>DelegatedExecutorService</code>线程池shutdown方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizableDelegatedExecutorService</span> <span class="keyword">extends</span> <span class="title">DelegatedExecutorService</span> </span>&#123;</span><br><span class="line">      FinalizableDelegatedExecutorService(ExecutorService executor) &#123;</span><br><span class="line">          <span class="keyword">super</span>(executor);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">super</span>.shutdown();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>DelegatedExecutorService</code>，该类实现的线程池内部维护了一个实际真正工作的线程池对象，实质是对线程池<code>ExecutorService</code>的一个静态代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatedExecutorService</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService e;<span class="comment">/// 我才是干活的线程池</span></span><br><span class="line">    DelegatedExecutorService(ExecutorService executor) &#123; e = executor; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123; e.execute(command); &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>分析：阅读源码后，不难发现该种线程池最终工作的线程池还是<code>ThreadPoolExecutor</code>的实例，而<code>ThreadPoolExecutor</code>实例的核心线程数为1，最大线程数也为1，工作队列为<strong>无界队列</strong>；</p><p>单线程线程池无非就是数量为1的固定数量线程池（Fixed，corePoolSize = maximumPoolSize = 1），与Fixed线程池不同的是，Single线程池对象在被GC回收时可自动关闭，比较安全，而Fixed线程池的关闭依赖于第三方调用者。</p><p>Single线程池更像一个“孤儿”，干活都是同一个Worker，自生自灭。</p><h2 id="定时任务线程池"><a href="#定时任务线程池" class="headerlink" title="定时任务线程池"></a>定时任务线程池</h2><hr><p>PS：在下博客里的图绝大部分都是自己通过<a target="_blank" rel="noopener" href="https://processon.com/">ProcessOn</a>做的，均带有**@WindShadow**水印，这么认真的开发人员哪里找哦</p><p><code>（ ’ - ’ * )</code> </p>]]></content>
      
      
      <categories>
          
          <category> Java多线程 </category>
          
          <category> Java线程池原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线程基础与Executor</title>
      <link href="WindShadow/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8EExecutor/"/>
      <url>WindShadow/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8EExecutor/</url>
      
        <content type="html"><![CDATA[<h2 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h2><p>线程在现代操作系统中的大致分两种（参考来源：<a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/641914">https://developer.aliyun.com/article/641914</a>）</p><ol><li><p>内核级线程（KLT，Kernel Level Thread）</p><p>线程管理的所有工作（创建和撤销）由操作系统内核完成；操作系统内核提供一个应用程序设计接口API，供开发者使用KLT；</p><p>线程交给内核管理，内核需要维护线程表，线程表保存了寄存器、状态和其他信息。当然每个线程所属进程的进程表也是维护在内核的，内核创建和销毁线程的代价是比较大的。</p></li><li><p>用户级线程（ULT，User Level Thread）</p><p>应用程序可以通过使用用户空间运行线程库被设计成多线程程序。线程的创建，消息传递，调度，保存/恢复上下文都有线程库来完成。内核感知不到多线程的存在。内核继续以进程为调度单位，并且给该进程指定一个执行状态（就绪、运行、阻塞等）。</p><p>对照一下，就是将线程的调度放在用户态执行，对于内核来说就像是单线程一样。</p></li></ol><p>而<strong>Java线程创建是依赖于系统内核，通过JVM调用系统库创建内核线程，内核线程与Java-Thread是1:1的映射关系</strong>，当然也有其它映射关系如1：N、N：N，如go语言使用的就是1：N，所以常常go语言被硬吹并发比java高很多就归功于其线程模型。</p><p>KLT与ULT（图片来自于网络）</p><p><img src="/WindShadow/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8EExecutor/ULT%E4%B8%8EKLT.webp" alt="KLT与ULT"></p><h2 id="Java线程基础"><a href="#Java线程基础" class="headerlink" title="Java线程基础"></a>Java线程基础</h2><h3 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h3><ol><li><p>继承<code>Thread</code>类，重写<code>run</code>方法，新建<code>Thread</code>类对象，使用该对象调用<code>Thread</code>类的<code>start</code>方法启动线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWorker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread myWorker = <span class="keyword">new</span> MyWorker();</span><br><span class="line">    myWorker.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现<code>Runnable</code>接口，使用<code>Runnable</code>的实例作为构造方法的参数新建<code>Thread</code>类对象，调用<code>Thread</code>对象的<code>start</code>方法创建线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyRunner myRunner = <span class="keyword">new</span> MyRunner();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(myRunner);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现<code>Callable</code>接口，将<code>Callable</code>实例提交到一个线程池（见下文）<code>ExecutorService</code>中执行任务；准确的说这并不算是创建线程的一个方式，因为<code>ExecutorService</code>接收任务后并不一定创建线程去执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCaller</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;call end&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyCaller myCaller = <span class="keyword">new</span> MyCaller();</span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(myCaller);</span><br><span class="line">        String result = future.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="Callable接口出现的必然性"><a href="#Callable接口出现的必然性" class="headerlink" title="Callable接口出现的必然性"></a>Callable接口出现的必然性</h4><p><code>Callable</code>接口与<code>Runnable</code>接口：<code>Callable</code>的<code>call</code>方法有返回值的，且允许抛出异常，<code>Runnable</code>接口的<code>run</code>方法无返回值，不允许抛出异常（这里的异常肯定是检查型异常）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk提供<code>Runnable</code>接口，我们可以在当前线程之外开启子线程去干一些事情（异步），根据<code>Runnable</code>接口的<code>run</code>方法的特点，这个子线程执行了就执行了，我们不清楚这个线程允许情况如何，有时候我们希望子线程执行结束后，我们能拿到些东西，<code>Runnable</code>接口显然并不能满足，于是<code>Callable</code>接口出现了。</p><p>显然“<strong>任务</strong>”这个概念更适合我们对子线程的描述，我们可以这样理解：</p><p><code>Runnable</code>是一个不期望有结果的任务，执行了就执行了，自己做好异常处理；<code>Callable</code>是一个期望有结果的任务，我们可以关心它抛出的异常。</p><p>下文《Executor框架》将会讲解任务相关的管理。</p><h3 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h3><p>网上众多讲java线程生命周期时想必都会贴出下面这么一张图，然后就人云亦云</p><p><img src="/WindShadow/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8EExecutor/OS%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.svg"></p><p>准确的说，上述这5个状态是从cpu角度看操作系统的线程各个阶段的状态。前文说到Java中的线程是KLT，所以Java线程在cpu角度看也是有这5个状态，但是不代表Java就是如此定义线程状态的！！！</p><p>Java<code>Thread</code>类使用内部枚举<code>State</code>来标识线程的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        NEW,</span><br><span class="line"></span><br><span class="line">        RUNNABLE,</span><br><span class="line"></span><br><span class="line">        BLOCKED,</span><br><span class="line"></span><br><span class="line">        WAITING,</span><br><span class="line"></span><br><span class="line">        TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到总共有6个状态，下面一一举例</p><ol><li><p>NEW：新生态，线程对象被创建时处于该状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread();</span><br><span class="line">        System.out.println(t.getState());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>RUNNABLE：运行态，线程正在运行其线程栈内代码（指令）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (System.currentTimeMillis() - start &gt; <span class="number">1000</span> * <span class="number">3</span>) <span class="comment">// 循环3秒以上</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);<span class="comment">// sleep 1秒</span></span><br><span class="line">        System.out.println(t.getState());<span class="comment">// 此时线程t未结束，正在执行其循环代码</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>BLOCKED：阻塞状态，线程想获取不到synchronized同步锁时，进入阻塞状态，如下线程t2获取target对象的锁时，因为线程t1还未释放，所以t2进入阻塞状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Object target = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (target) &#123;<span class="comment">// 获取target的锁</span></span><br><span class="line">                <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (System.currentTimeMillis() - start &gt; <span class="number">1000</span> * <span class="number">3</span>) <span class="comment">// 循环3秒</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">    </span><br><span class="line">    Thread.sleep(<span class="number">100L</span>);<span class="comment">// 等t1线程启动</span></span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (target) &#123;<span class="comment">// 获取target的锁</span></span><br><span class="line">                System.out.println(<span class="string">&quot;--- run ---&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);<span class="comment">// 等两个线程都启动</span></span><br><span class="line">        System.out.println(t2.getState());<span class="comment">// 此时线程t1 t2 都未结束</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>WAITING：等待状态，准确的说是死等，线程调用object.wait()方法，等待其它线程调用object.notify()或object. notifyall()方法，此时该线程进入等待状态。或调用<code>LockSupport.park()</code>方法线程也会进入该状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Object target = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (target) &#123;<span class="comment">// 获取target的锁</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    target.wait();<span class="comment">// 调用wait()方法</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        System.out.println(t1.getState());<span class="comment">// 由于没有线程调用target.notifyAll()或target.notify()，此时线程t1一直处于等待状态，</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>TIMED_WAITING： 等待未超时，线程调用object.wait(long)方法，等待其它线程调用object.notify()或object. notifyall()方法，不过只会等待指定的时间，未超时之前该线程进入等待未超时状态。或线程进入通过sleep方法进行“睡眠”时，也会进入等待未超时状态。或调用<code>LockSupport.parkNanos(Object, long)</code>方法、<code>LockSupport.parkUntil(Object, long)</code>方法线程也会进入该状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Object target = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (target) &#123;<span class="comment">// 获取target的锁</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    target.wait(<span class="number">3000L</span>);<span class="comment">// 调用wait()方法，等待其它线程调用target.notifyAll()或target.notify()，不过只等待3秒</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        <span class="comment">// 由于没有线程调用target.notifyAll()或target.notify()，3秒内（此时过去了1秒）线程t1一直处于等待未超时状态</span></span><br><span class="line">        System.out.println(t1.getState());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        <span class="comment">// 线程t1依旧在睡眠，其处于等待未超时状态</span></span><br><span class="line">        System.out.println(t1.getState());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>TERMINATED：终止（死亡）状态，代码执行结束或外部干涉导致线程终止，进入死亡状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">           System.out.println(<span class="string">&quot;--- run ---&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);<span class="comment">//</span></span><br><span class="line">        <span class="comment">// 过了1秒，线程t1已经执行完，其处于死亡状态</span></span><br><span class="line">        System.out.println(t1.getState());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="线程状态的获取"><a href="#线程状态的获取" class="headerlink" title="线程状态的获取"></a>线程状态的获取</h3><p>通过调用<code>Thread#getState</code>方法获取到当前线程的状态。</p><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>java线程优先级范围：1~10，优先级从低到高。</p><p>优先级越高，越容易得到cpu时间片。</p><p>相关方法：</p><ul><li>获取线程的优先级：<code>Thread#getPriority</code></li><li>设置线程优先级：<code>Thread#setPriority</code></li></ul><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><ul><li>java中线程分为<strong>用户线程（User Thread ）</strong>和<strong>守护线程（Daemon Thread ）</strong></li><li>虚拟机必须确保用户线程执行完毕</li><li>虚拟机可以不等待守护线程执行完毕</li><li>通过调用<code>Thread#setDaemon(true)</code>方法将线程设置为守护线程</li></ul><p>守护线程最典型的应用就是 GC (垃圾回收器)。用户线程和守护线程两者几乎没有区别，唯一的不同之处就在于，当用户线程全部执行结束，只剩下守护线程存在了，虚拟机也就退出了， 因为没有了被守护者，守护线程也就没有工作可做了，也就没有继续运行程序的必要了。</p><h3 id="停止线程的方法"><a href="#停止线程的方法" class="headerlink" title="停止线程的方法"></a>停止线程的方法</h3><ul><li><p><code>Thread#stop</code>方法，过时，不建议使用</p></li><li><p><code>Thread#destroy</code>方法，废弃</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置某种标志位，结束线程代码的执行，正常停止线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;运行&quot;</span>);</span><br><span class="line">            <span class="comment">//... do something</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 对外提供停止方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        <span class="keyword">new</span> Thread(myRunnable).start();</span><br><span class="line">        Thread.sleep(<span class="number">800</span>);</span><br><span class="line">        myRunnable.doStop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h3><p>调用<code>Thread.sleep</code>方法使当前线程进入阻塞状态，线程结束休眠后进入就绪态；</p><p><strong>线程通过<code>Thread.sleep</code>方法进入休眠时，不会释放对象锁</strong></p><h3 id="线程礼让"><a href="#线程礼让" class="headerlink" title="线程礼让"></a>线程礼让</h3><p>调用<code>Thread.yield()</code>方法使当前线程让出cpu时间片，使线程从运行态重新进入就绪态。值得注意的是：A线程让出cpu时间片，不代表B线程就可以获取到cpu时间片，下一次获取cpu时间片的线程可能还是A。</p><h3 id="线程“插队”"><a href="#线程“插队”" class="headerlink" title="线程“插队”"></a>线程“插队”</h3><p>如在线程A的代码中，调用B线程对象的<code>Thread#join</code>方法，将B线程加入到A线程，A线程需要等待B线程执行完之后才能继续执行自己的代码。好比插队，可传入等待时间表示允许插队的最长时间，超过该时间，B线程还未执行结束，则不再等待。</p><h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><p>下面一一引出Executor框架相关的类或接口</p><h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>前文我们将<code>Runnable</code> 和<code>Callable</code>称之为任务，那么任务有了，就要有对应的任务执行者和管理者，如果不进行管理，直接使用new Thread()的方法创建线程有很多缺点：</p><ul><li>new Thread()耗费性能</li><li>调用new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制创建，之间相互竞争，会导致过多占用系统资源</li><li>不利于扩展，比如如定时执行、定期执行、线程中断等</li></ul><p>所以任务（线程）的管理是必须的。</p><p>对于<code>Runnable</code>，我们不期望有结果（无返回值），只管执行，所以<code>Executor</code>接口出现了。</p><p><img src="/WindShadow/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8EExecutor/Executor%E6%8E%A5%E5%8F%A3.png"></p><p>通过<code>Executor</code>的<code>executor</code>方法来启动任务（子线程），更加便捷，并且可以避免“<strong>this逃逸</strong>”问题</p><h4 id="this逃逸问题"><a href="#this逃逸问题" class="headerlink" title="this逃逸问题"></a>this逃逸问题</h4><p>this逃逸是指在构造函数返回之前其他线程就持有该对象的引用，调用尚未构造完全的对象的方法可能引发奇怪的错误。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 在构造方法创建并启动线程</span></span><br><span class="line">        EscapeRunnable er = <span class="keyword">new</span> EscapeRunnable();</span><br><span class="line">        <span class="keyword">new</span> Thread(er).start();<span class="comment">// 危险，构造可能未完成，但是 er 对象已经能调用正在构造的Woker对象的doWork方法</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//... do something</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapeRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            Worker.<span class="keyword">this</span>.doWork();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 可修改如下规避this逃逸</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Thread thread;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在构造方法创建创建但未启动线程</span></span><br><span class="line">        thread = <span class="keyword">new</span> Thread(<span class="keyword">this</span>.<span class="function">new <span class="title">EscapeRunnable</span><span class="params">()</span>)</span>;</span><br><span class="line">         <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 给外部调用者提供初始化操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//... do something</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapeRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            Worker.<span class="keyword">this</span>.doWork();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h3><p>对于<code>Callable</code>，也需要有一个执行者和管理者，于是<code>ExecutorService</code>出现了，无论是<code>Callable</code>还是<code>Runnable</code>，这些任务都涉及管理和扩展方面的优化，<code>ExecutorService</code>索性直接扩展<code>Executor</code>增加对<code>Callable</code>支持。</p><p><code>ExecutorService</code>提供了任务生命周期管理等功能 ，实际开发中用的更多的是<code>ExecutorService</code>，它的底层实现就是<strong>线程池</strong>。</p><p><img src="/WindShadow/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8EExecutor/Executor.png"></p><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>任务提交后，我们肯定需要知道任务执行得怎么样了，而<code>ExecutorService</code>使用<code>Future</code>来跟踪任务，通过<code>ExecutorService</code>提交任务后就可以得到<code>Future</code>对象。</p><p><code>Future</code>接口的主要方法如下：</p><ul><li><p><code>boolean cancel(boolean mayInterruptIfRunning);</code></p><p>尝试取消任务，成功则返回true，失败false（任务已经完成、已经被取消或由于其他原因无法取消）</p><p>mayInterruptIfRunning 参数：是否中断任务，true，中断任务且取消任务，false，允许任务继续执行到结束，但是获取结果时会抛异常。</p></li><li><p><code>boolean isCancelled();</code></p><p>任务是否已经取消</p></li><li><p><code>boolean isDone();</code></p><p>任务是否执行结束</p></li><li><p><code>V get() throws InterruptedException, ExecutionException;</code></p><p>获取任务执行结果，获取不到结果之前会一直等待，如果任务已经取消了则抛出异常</p></li><li><p><code>V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;</code></p><p>获取任务执行结果，但只会等待指定的时间，超时则抛出异常。</p><p>timeout 参数：时间数量</p><p>unit 参数：时间单位</p></li></ul><h3 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h3><p><code>Executors</code>类是<code>Executor</code>体系相关的工具类，通过它可以很方便的操作<code>Executor</code>体系相关的接口示例，如创建线程池。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上就是Executor框架的主要知识点，总结一下，Executor框架要由三大部分组成：</p><ol><li>任务(Runnable /Callable)</li><li>任务的执行(Executor)</li><li>异步计算的结果(Future)</li></ol><p>Executor 框架的使用</p><p>主线程首先要创建实现<code>Runnable</code>或者<code>Callable</code>接口的任务对象，把任务对象交给<code>ExecutorService</code>执行，得到结果对象<code>Future</code>，最后，主线程可以通过对象<code>Future</code>来获取任务结果或取消任务。</p><hr><p><strong>本文参考B站UP主“狂神说Java”<a target="_blank" rel="noopener" href="https://space.bilibili.com/95256449/%E7%9A%84Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%95%99%E5%AD%A6%E8%A7%86%E9%A2%91%E8%BF%9B%E8%A1%8C%E6%95%B4%E7%90%86%E3%80%82">https://space.bilibili.com/95256449/的Java多线程教学视频进行整理。</a></strong></p><p><strong>感谢成长路上为在下传道受业解惑之人</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis源码一 MyBatis执行器与缓存实现</title>
      <link href="WindShadow/MyBatis/MyBatis%E6%BA%90%E7%A0%81/MyBatis%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/"/>
      <url>WindShadow/MyBatis/MyBatis%E6%BA%90%E7%A0%81/MyBatis%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>开门见山，上菜：MyBatis执行器脑图，阅读过程中反复食用即可理解<code>（ ’ - ’ * )</code> </p><p><img src="/WindShadow/MyBatis/MyBatis%E6%BA%90%E7%A0%81/MyBatis%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/MyBatis%E6%89%A7%E8%A1%8C%E5%99%A8%E8%84%91%E5%9B%BE.svg" alt="MyBatis执行器脑图"></p><h2 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h2><p><code>SqlSession</code>接口上的注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The primary Java interface for working with MyBatis. Through this interface you can execute</span></span><br><span class="line"><span class="comment"> * commands, get mappers and manage transactions.</span></span><br><span class="line"><span class="comment"> * Author: Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SqlSession</span> <span class="keyword">extends</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>翻译一下：使用MyBatis的主要Java接口。通过这个接口，您可以执行命令、获取映射器和管理事务</p><p><code>SqlSession</code>接口定义了如：<code>&lt;T&gt; T selectOne(String statement);</code>、<code>&lt;E&gt; List&lt;E&gt; selectList(String statement);</code>、<code>&lt;K, V&gt; Map&lt;K, V&gt; selectMap(String statement, String mapKey);</code>、<code>int insert(String statement);</code>、<code>int update(String statement);</code>、<code>int delete(String statement, Object parameter);</code>、<code>void commit();</code>等的一系列增删改查和事务提交/回滚接口，方便开发者调用，MyBatis提供的<code>SqlSession</code>接口实现之一是<code>DefaultSqlSession</code>，实际工作干活的就是它。</p><p>根据MyBatis执行器脑图可知其内部又是通过<code>Executor</code>执行器去干活的<img src="/WindShadow/MyBatis/MyBatis%E6%BA%90%E7%A0%81/MyBatis%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/sqlsession%E6%89%A7%E8%A1%8C%E5%99%A8.png"></p><p><code>SqlSession</code>的增删改查无论是怎么查，怎么改，怎么删、怎么加，最终都是调用<code>Executor</code>的“<code>update</code>改”和“<code>query</code>查”两个接口（见下文），这就是<code>SqlSession</code>使用的设计模式：<strong>门面模式</strong>，对外提供友好的api方法，内部屏蔽了调用<code>Executor</code>方法的复杂性。</p><h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><p>Executor（<code>org.apache.ibatis.executor.Executor</code>）是一个接口，称之为sql执行器。</p><p>其定义update(增、改、删)、query(查)、commit(提交事务)、rollback(回滚事务)等操作。</p><p>几个重要的方法：</p><ul><li><p>增、改、删</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增、改、删</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException</span></span><br></pre></td></tr></table></figure><p>参数含义如下</p><ul><li><code>MappedStatement ms</code>：SQL映射语句（Mapper.xml文件每一个方法对应一个MappedStatement对象）</li><li><code>Object parameter</code>：参数，通常是List</li></ul></li><li><p>查询方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询方法</span></span><br><span class="line">&lt; E&gt; List&lt; E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span><br></pre></td></tr></table></figure><p>参数含义（不赘述出现过的参数类型）如下</p><ul><li><code>RowBounds</code>：行边界，主要保存分页参数（limit、offset）</li><li><code>ResultHandler resultHandler</code>：结果处理器，入参时一般为null，实际的结果处理器由<code>Configuration</code>配置对象和<code>MappedStatement</code>对象生成</li></ul></li><li><p>可提供缓存key的查询方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可提供缓存key的查询方法</span></span><br><span class="line">&lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey cacheKey, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure><p>参数含义（不赘述出现过的参数类型）如下：</p><ul><li><code>CacheKey</code>：缓存的key对象</li><li><code>BoundSql boundSql</code>：可以通过该对象获取SQL语句，MyBatis保存sql语句的对象。</li></ul></li><li><p>创建缓存Key（MyBatis一二级缓存的缓存Key）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建缓存Key（MyBatis一二级缓存的缓存Key）</span></span><br><span class="line"><span class="function">CacheKey <span class="title">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObj, RowBounds bounds, BoundSql bSql)</span></span></span><br></pre></td></tr></table></figure><p>可以看出缓存Key由上述参数（SQL映射语句<code>MappedStatement</code>、参数<code>Object</code>、行边界<code>RowBounds</code>、sql语句对象<code>BoundSql</code>）来决定。</p></li></ul><p>下面一一介绍Executor的实现类：<code>BaseExecutor</code>、<code>SimpleExecutor</code>、<code>ReuseExecutor</code>、<code>BatchExecutor</code>、<code>CachingExecutor</code>，其实还有一个<code>ClosedExecutor</code>，代表已经关闭的<code>Executor</code>，是<code>ResultLoaderMap</code>的私有内部类，此处不展开阐述。</p><h3 id="BaseExecutor"><a href="#BaseExecutor" class="headerlink" title="BaseExecutor"></a>BaseExecutor</h3><p><code>Executor</code>的抽象实现，实现执行器的公共操作：<strong>一级缓存、连接获取</strong>等，<strong>查询、更新具体的实现由其子类来实现</strong></p><ul><li>具体的查询操作：<code>doQuery</code>方法</li><li>具体的更新操作：<code>doUpdate</code>方法（包括增删改）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新操作，抽象方法，子类实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="comment">// 查询操作，抽象方法，子类实现</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure><h3 id="SimpleExecutor"><a href="#SimpleExecutor" class="headerlink" title="SimpleExecutor"></a>SimpleExecutor</h3><p>简单执行器，继承<code>BaseExecutor</code>，无论执行的sql如何，每次都会生成预编译<code>java.sql.PreparedStatement</code>对象。</p><p><img src="/WindShadow/MyBatis/MyBatis%E6%BA%90%E7%A0%81/MyBatis%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/simpleExecutor.png"></p><h3 id="ReuseExecutor"><a href="#ReuseExecutor" class="headerlink" title="ReuseExecutor"></a>ReuseExecutor</h3><p>可重用执行器，继承<code>BaseExecutor</code>，相同的sql（肯定是带占位符的）只进行一次预编译（缓存），即预编译对象可重用。</p><p>缓存大致原理：</p><p>内部维护一个map（key: sql, value: Statement对象）作为预编译对象的缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReuseExecutor</span> <span class="keyword">extends</span> <span class="title">BaseExecutor</span> </span>&#123;</span><br><span class="line"><span class="comment">// 缓存 Statement 的 map，【key: sql, value: Statement对象】</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Statement&gt; statementMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行<code>doUpdate</code>或<code>doQuery</code>方法时先查缓存，为命中则生成新的预编译对象且加入缓存map中（如图）<img src="/WindShadow/MyBatis/MyBatis%E6%BA%90%E7%A0%81/MyBatis%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/reuseExecutor%E7%BC%93%E5%AD%98.png"><img src="/WindShadow/MyBatis/MyBatis%E6%BA%90%E7%A0%81/MyBatis%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/reuseExecutor%E7%BC%93%E5%AD%982.png"></p><h3 id="BatchExecutor"><a href="#BatchExecutor" class="headerlink" title="BatchExecutor"></a>BatchExecutor</h3><p>批处理执行器，继承<code>BaseExecutor</code>，该执行器专为批处理场景设计；</p><p><em>（解释一下批处理场景：</em></p><p><em>假设我们需要遍历一个用户对象集合，对每个用户年龄进行加1操作然后更新，假设我们使用<code>ReuseExecutor</code>，那么每个用户的更新操作都会向数据库发送一次sql，而批处理操作便是一次性向数据库发送多条sql。）</em></p><p><code>BatchExecutor</code>属性成员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchExecutor</span> <span class="keyword">extends</span> <span class="title">BaseExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BATCH_UPDATE_RETURN_VALUE = Integer.MIN_VALUE + <span class="number">1002</span>;</span><br><span class="line">  <span class="comment">// Statement集合，批处理的sql对应的Statement都会存在这里</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Statement&gt; statementList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// 批处理执行的结果集合</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;BatchResult&gt; batchResultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// 当前维护的sql（肯定带占位符的）</span></span><br><span class="line">  <span class="keyword">private</span> String currentSql;</span><br><span class="line">  <span class="comment">// 当前维护的MappedStatement</span></span><br><span class="line">  <span class="keyword">private</span> MappedStatement currentStatement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是：</p><ol><li>对查询操作，同简单执行器<code>SimpleExecutor</code>一样，批处理执行器每次都会生成预编译对象</li><li>对于更新操作(增删改)，<code>BatchExecutor</code>对象本身会记录当前的sql和<code>MappedStatement</code>，如果下一次更新操作的sql和<code>MappedStatement</code>与维护的sql和<code>MappedStatement</code>都相同，则直接复用，否则替换掉当前维护的sql和<code>MappedStatement</code></li><li><strong><code>BatchExecutor</code>需要调用<code>flushStatements()</code>方法刷新statement，数据库内的数据修改才会生效。</strong></li><li><strong>执行<code>BatchExecutor</code>的<code>doQuery</code>方法时，会先执行<code>flushStatements()</code>方法，再进行查询操作</strong></li></ol><p>下面贴出<code>BatchExecutor</code>实现<code>doUpdate</code>方法的源码，并加以注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchExecutor</span> <span class="keyword">extends</span> <span class="title">BaseExecutor</span> </span>&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameterObject)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Configuration configuration = ms.getConfiguration();</span><br><span class="line">       <span class="keyword">final</span> StatementHandler handler = configuration.newStatementHandler(<span class="keyword">this</span>, ms, parameterObject, RowBounds.DEFAULT, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">final</span> BoundSql boundSql = handler.getBoundSql();</span><br><span class="line">       <span class="keyword">final</span> String sql = boundSql.getSql();</span><br><span class="line">       <span class="keyword">final</span> Statement stmt;</span><br><span class="line">       <span class="keyword">if</span> (sql.equals(currentSql) &amp;&amp; ms.equals(currentStatement)) &#123;<span class="comment">// 当前维护的sql和ms与要执行的sql和ms比较，若都相同</span></span><br><span class="line">         <span class="keyword">int</span> last = statementList.size() - <span class="number">1</span>;</span><br><span class="line">         stmt = statementList.get(last);<span class="comment">// 取出statement列表最后一个元素作为当前的statement</span></span><br><span class="line">         applyTransactionTimeout(stmt);</span><br><span class="line">         handler.parameterize(stmt);</span><br><span class="line">         BatchResult batchResult = batchResultList.get(last); <span class="comment">// 取出最后一个批处理执行结果</span></span><br><span class="line">         batchResult.addParameterObject(parameterObject);     <span class="comment">// 并添加当前的参数对象到该批处理执行结果</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;<span class="comment">// 当前维护的sql和ms与要执行的只要有一个不同</span></span><br><span class="line">         Connection connection = getConnection(ms.getStatementLog());</span><br><span class="line">         stmt = handler.prepare(connection, transaction.getTimeout());<span class="comment">// 获取新的statement</span></span><br><span class="line">         handler.parameterize(stmt);  </span><br><span class="line">         currentSql = sql;<span class="comment">// 顶替掉维护的sql</span></span><br><span class="line">         currentStatement = ms;<span class="comment">// 顶替掉维护的ms</span></span><br><span class="line">         statementList.add(stmt);<span class="comment">// 添加新的statement到statement列表</span></span><br><span class="line">         batchResultList.add(<span class="keyword">new</span> BatchResult(ms, sql, parameterObject));<span class="comment">// 添加新的批处理结果到列表</span></span><br><span class="line">       &#125;</span><br><span class="line">       handler.batch(stmt);</span><br><span class="line">       <span class="keyword">return</span> BATCH_UPDATE_RETURN_VALUE;</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通过阅读<code>BatchExecutor</code>的成员变量和<code>doUpdate</code>方法的源码，不难发现，以下几点：</p><ul><li><p>通过statement列表保存要执行的sql操作</p></li><li><p><code>BatchExecutor</code>内部通过维护一个sql和一个<code>MappedStatement</code>来减少statement的生成，连续相同的sql和<code>MappedStatement</code>不会生成新的statement</p></li><li><p>通过批处理结果对象（<code>BatchResult</code>）列表，维护批处理结果，其中批处理结果对象维护了<code>MappedStatement</code>、sql以及不同参数的列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchResult</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MappedStatement mappedStatement;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String sql;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; parameterObjects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>statement列表和批处理结果对象（<code>BatchResult</code>）列表，它们下标对应的元素是一一对应有关联的</p></li></ul><h3 id="CachingExecutor"><a href="#CachingExecutor" class="headerlink" title="CachingExecutor"></a>CachingExecutor</h3><p>缓存执行器，实现Executor接口，实现二级缓存，详情见下文。</p><h2 id="一缓存实现原理"><a href="#一缓存实现原理" class="headerlink" title="一缓存实现原理"></a>一缓存实现原理</h2><p><strong>首先要明确一级缓存存在的意义（需求）：同一个事务内，多次相同的查询每次都查询数据库性能是不高的，所以要做缓存</strong></p><p>所以sql执行器<code>Executor</code>接口干净利落的定义了一级缓存（也叫localCache）相关的接口，因为一级缓存是一个逻辑上必然应该存在的功能。</p><p>前文讲到MyBatis的一级缓存是由<code>BaseExecutor</code>实现的，<code>BaseExecutor</code>通过内部的<code>PerpetualCache localCache</code>缓存对象来维护缓存。<img src="/WindShadow/MyBatis/MyBatis%E6%BA%90%E7%A0%81/MyBatis%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/baseExecutor%E7%BC%93%E5%AD%98.png"></p><p><strong>PerpetualCache</strong> 内部通过维护一个map实现MyBatis的Cache接口（此处不展开MyBatis的缓存接口的实现体系）。<img src="/WindShadow/MyBatis/MyBatis%E6%BA%90%E7%A0%81/MyBatis%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/perpetualCache.png"></p><h3 id="一级缓存源码分析"><a href="#一级缓存源码分析" class="headerlink" title="一级缓存源码分析"></a>一级缓存源码分析</h3><p>我们将<code>BaseExecutor</code>实现<code>Executor</code>接口的两个query方法源码贴出并加以关键注释，即可明白<code>BaseExecutor</code>如何实现MyBatis一缓存的，如下：</p><p><strong>不带缓存key的查询方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    BoundSql boundSql = ms.getBoundSql(parameter);<span class="comment">// 通过MappedStatement对象获取sql</span></span><br><span class="line">    CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);<span class="comment">// 创建缓存key</span></span><br><span class="line">    <span class="keyword">return</span> query(ms, parameter, rowBounds, resultHandler, key, boundSql);<span class="comment">// 调用带缓存key的查询方法</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>带缓存key的查询方法（重点）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing a query&quot;</span>).object(ms.getId());</span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">    clearLocalCache();</span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;E&gt; list;<span class="comment">// 定义查询结果引用</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    queryStack++;</span><br><span class="line">     <span class="comment">// 1、满足resultHandler == null则走缓存获取查询结果</span></span><br><span class="line">    list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;<span class="comment">// 2、缓存命中了，处理缓存的输出参数，可不必关心此处干了啥</span></span><br><span class="line">      handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 3、缓存未命中，从数据库查询数据</span></span><br><span class="line">      list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    queryStack--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">      deferredLoad.load();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    deferredLoads.clear();</span><br><span class="line">    <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">      </span><br><span class="line">      clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;<span class="comment">// 4、返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询数据库的方法<code>queryFromDatabase</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  List&lt;E&gt; list;<span class="comment">// 1、定义查询结果</span></span><br><span class="line">  localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);<span class="comment">// 2、调用子类的doQuery方法进行查询</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    localCache.removeObject(key);</span><br><span class="line">  &#125;</span><br><span class="line">  localCache.putObject(key, list);<span class="comment">// 3、缓存结果，一级缓存的写入操作！！！</span></span><br><span class="line">  <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">    localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;<span class="comment">// 4、返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一级缓存清除时机</strong></p><p><code>BaseExecutor</code>更新操作（方法）被调用时，清除执行器缓存的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing an update&quot;</span>).object(ms.getId());</span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  clearLocalCache(); <span class="comment">// 1、清除该执行器的一级缓存</span></span><br><span class="line">  <span class="keyword">return</span> doUpdate(ms, parameter);<span class="comment">// 2、调用子类的doUpdate方法执行更新操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据一级缓存的需求，事务提交后，缓存应该就要被清空，这一点在<code>BaseExecutor</code>的 <code>commit</code>方法中体现</p><p><img src="/WindShadow/MyBatis/MyBatis%E6%BA%90%E7%A0%81/MyBatis%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/baseExcutor%E6%8F%90%E4%BA%A4.png"></p><h3 id="BaseExecutor实现一级缓存总结"><a href="#BaseExecutor实现一级缓存总结" class="headerlink" title="BaseExecutor实现一级缓存总结"></a><code>BaseExecutor</code>实现一级缓存总结</h3><ul><li>如何维护：通过<code>PerpetualCache localCache</code>成员变量维护一级缓存</li><li>写入时机：实现<code>Executor</code>接口的<code>query</code>方法时，先尝试从缓存中获取查询结果，获取不到则调用子类的<code>doQuery</code>方法从数据库获取查询结果，获取到数据后写入缓存再返回</li><li>清除时机：【1】执行<code>BaseExecutor</code>实现<code>Executor</code>执行器接口的<code>update</code>更新方法时，先清除一级缓存的所有数据，再调用子类的<code>doUpdate</code>方法执行更新操作；【2】<code>BaseExecutor</code>的<code>commit</code>方法被调用时清除一级缓存的所有数据</li></ul><h2 id="二级缓存实现原理"><a href="#二级缓存实现原理" class="headerlink" title="二级缓存实现原理"></a>二级缓存实现原理</h2><p><strong>同样，先明确二级缓存存在的意义（需求）：我们希望数据的缓存结果可以覆盖整个应用，也就是多个事务，一个事务的查询结果被缓存后，另一个事务也能读取到这个缓存结果，以减少对数据库的访问次数，加快数据查询效率。</strong></p><p>MyBatis的二级缓存是通过<code>CachingExecutor</code>实现的，需要注意的是，<code>CachingExecutor</code>在<code>Executor</code>类结构中和<code>BaseExecutor</code>是同级的，内部维护了一个<code>Executor</code>对象，通过构造方法传入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachingExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Executor delegate;<span class="comment">// 被装饰的Executor执行器对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TransactionalCacheManager tcm = <span class="keyword">new</span> TransactionalCacheManager();<span class="comment">// 事务缓存管理器</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CachingExecutor</span><span class="params">(Executor delegate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    delegate.setExecutorWrapper(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CachingExecutor</code>专门负责二级缓存，而获取连接等执行器的基本操作则交给给内部的<code>Executor</code>对象，此处用到了设计模式中的“<strong>装饰者模式（装饰器模式）</strong>”，在不改变原有功能的基础上，增加新功能，这里的新功能就是二级缓存的功能了。</p><p><em>（有的文章说这是委派模式，<code>CachingExecutor</code>的<code>Executor delegate</code>变量名称确实是委派的意思。不过根据笔者的理解和查询其它高质量的文章之后，比较赞同该设计模式为装饰者模式，因为<code>CachingExecutor</code>确实做到了“在不改变原有功能的基础上，增加新功能”，并且委派模式中，通常“委派者”在委派任务时，通常要根据条件决定把任务交给哪个具体的实现对象，<code>CachingExecutor</code>显然不是这样的情形）</em></p><h3 id="二级缓存源码分析"><a href="#二级缓存源码分析" class="headerlink" title="二级缓存源码分析"></a>二级缓存源码分析</h3><p><code>CachingExecutor</code>实现二级缓存的操作类似于一级缓存，在实现<code>Executor</code>接口的<code>query</code>方法时先查缓存，查不到则调用内部的<code>Executor</code>对象的<code>query</code>方法获取。下面分析<code>CachingExecutor</code>的<code>query</code>方法。</p><p><strong>不带缓存key的查询方法</strong>，最终调用带缓存key的查询方法，与一级缓存相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    BoundSql boundSql = ms.getBoundSql(parameterObject);</span><br><span class="line">    CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">    <span class="keyword">return</span> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>带缓存key的查询方法（重点）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   Cache cache = ms.getCache(); <span class="comment">// 1-A、从MappedStatement获取缓存对象</span></span><br><span class="line">   <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;<span class="comment">// 2、如果缓存对象不为空</span></span><br><span class="line">     flushCacheIfRequired(ms);</span><br><span class="line">     <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;<span class="comment">// 3、如果MappedStatement开启了缓存，且resultHandler == null</span></span><br><span class="line">       ensureNoOutParams(ms, boundSql);</span><br><span class="line">       <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">       List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);<span class="comment">// 4、尝试从通过事务缓存管理器对象获取查询结果</span></span><br><span class="line">       <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;<span class="comment">// 5、从缓存对象获取查询结果为空</span></span><br><span class="line">         <span class="comment">// 6、调用内部的执行器对象进行查询</span></span><br><span class="line">         list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">         tcm.putObject(cache, key, list);<span class="comment">// 7、通过事务缓存管理器对象缓存结果，二级缓存的写入操作！！！</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list;<span class="comment">// 8、返回结果</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">     <span class="comment">// 1-B、MappedStatement获取不到缓存对象则直接调用内部的执行器对象进行查询并返回</span></span><br><span class="line">   <span class="keyword">return</span> delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>二级缓存清除时机</strong></p><p><code>CachingExecutor</code>更新操作（方法）被调用时，清除所有缓存的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameterObject)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">// 1、刷新（清除）缓存，因为是更新操作，ms.isFlushCacheRequired() == true</span></span><br><span class="line">  flushCacheIfRequired(ms);</span><br><span class="line">  <span class="keyword">return</span> delegate.update(ms, parameterObject);<span class="comment">// 2、再调用装饰的执行器执行更新操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>flushCacheIfRequired</code>刷新（清除）缓存，如果可以需要的话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushCacheIfRequired</span><span class="params">(MappedStatement ms)</span> </span>&#123;</span><br><span class="line">    Cache cache = ms.getCache();</span><br><span class="line">    <span class="comment">// 1、缓存对象有效且设置了MappedStatement必须刷新缓存的开关为true，则清除MappedStatement中的缓存</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">      tcm.clear(cache);<span class="comment">// 2、通过事务缓存管理器对象清空MappedStatement中的缓存</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="二级缓存跨事务使用具体实现与数据一致性原理（重点）"><a href="#二级缓存跨事务使用具体实现与数据一致性原理（重点）" class="headerlink" title="二级缓存跨事务使用具体实现与数据一致性原理（重点）"></a>二级缓存跨事务使用具体实现与数据一致性原理（重点）</h3><p>思考三个点：</p><ol><li><p>由二级缓存的需求可知，二级缓存服务于多个事务的，因为同一个事务内的多次查询已经由一级缓存来保证效率了，所以显然缓存数据的写入应该在事务提交时才会写入。</p><p>而<code>CachingExecutor</code>提交方法<code>commit</code>是直接调用事务缓存管理器对<code>TransactionalCacheManager</code>的提交方法，毫无疑问二级缓存数据的写入操作肯定与该方法有关</p><p><img src="/WindShadow/MyBatis/MyBatis%E6%BA%90%E7%A0%81/MyBatis%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/cachingExecutor%E6%8F%90%E4%BA%A4.png"></p></li><li><p>又通过<code>CachingExecutor</code>的<code>query</code>方法源码分析可知，二级缓存的数据的存储实际由<code>MappedStatement</code>对象的自身的cache缓存来做的，而缓存的添加和删除是调用<code>TransactionalCacheManager</code>的方法实现的</p></li><li><p>而二级缓存在得到查询结果后就直接通过事务缓存管理器对象<code>TransactionalCacheManager</code>缓存结果了，但是此时事务并没有提交。</p></li></ol><p>由以上三点可知，<code>CachingExecutor</code>通过<code>MappedStatement</code>的cache缓存和事务缓存管理器<code>TransactionalCacheManager</code>的配合来实现二级缓存</p><p>来看看事务缓存管理器<code>TransactionalCacheManager</code>管理啥了</p><p><img src="/WindShadow/MyBatis/MyBatis%E6%BA%90%E7%A0%81/MyBatis%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/tcm.png"></p><p>不难看出<code>TransactionalCacheManager</code>实际管理的是<code>MappedStatement</code>的cache缓存和事务缓存对象<code>TransactionalCache</code>的关系，<code>TransactionalCacheManager</code>的方法最终执行的都是<code>TransactionalCache</code>的方法。</p><p>带着这个问题阅读<code>TransactionalCache</code>的源码（读者自行阅读），理解<code>TransactionalCacheManager</code>、cache缓存、<code>TransactionalCache</code>的关系就全懂了。总结出下图</p><p><img src="/WindShadow/MyBatis/MyBatis%E6%BA%90%E7%A0%81/MyBatis%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/MyBatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.svg" alt="MyBatis二级缓存"></p><h4 id="TransactionalCache源码总结"><a href="#TransactionalCache源码总结" class="headerlink" title="TransactionalCache源码总结"></a>TransactionalCache源码总结</h4><ul><li><p>TransactionalCache的四个成员变量含义如上图所示</p></li><li><p>二级缓存数据添加流程：</p><ol><li><code>CachingExecutor</code>的<code>query</code>查询操作通过事务管理器（tcm）添加缓存时，tcm根据该缓存对象获取对应的事务缓存对象<code>TransactionalCache</code>（tc）</li><li>tc将要添加的二级缓存的key-value对先添加到一个由hashmap实现的暂存区</li><li>在执行<code>commit</code>方法（<code>CachingExecutor</code> -&gt; <code>TransactionalCacheManager</code> -&gt; <code>TransactionalCache</code>）时，tc将暂存区的数据添加到缓存cache（<code>MappedStatement</code>的cache）中，同时将记录过未命中缓存的key也加入到缓存cache中，这些key的value为null。</li></ol></li><li><p>二级缓存未命中时，tc记录当前未命中的key到一个由hashset实现的缓冲区中</p></li><li><p>clearOnCommit的作用：</p><ul><li><code>TransactionalCache</code>通过clearOnCommit变量标记，通知事务进行提交时，决定是否先清空二级缓存（<code>MappedStatement</code>的cache），后以当前事务的发生的缓存为最新缓存，刷新到二级缓存中。<img src="/WindShadow/MyBatis/MyBatis%E6%BA%90%E7%A0%81/MyBatis%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/tcCommit.png"></li><li>clearOnCommit = true时，则认为当前二级缓存中的数据无效，调用<code>TransactionalCache</code>的<code>getObject</code>方法获取缓存中的数据必定是null<img src="/WindShadow/MyBatis/MyBatis%E6%BA%90%E7%A0%81/MyBatis%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/tcGet.png"></li><li><code>TransactionalCache</code>每次提交或回滚后，调用内部的<code>reset</code>方法将clearOnCommit变量设置为false（见上图commit方法），以便后续的事务可以读到二级缓存的数据。</li></ul><p>而clearOnCommit = true 的情况只有在调用<code>TransactionalCacheManager</code> 的clear方法时（<code>TransactionalCacheManager</code> -&gt; <code>TransactionalCache</code>）才会出现</p><p><img src="/WindShadow/MyBatis/MyBatis%E6%BA%90%E7%A0%81/MyBatis%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/commit.jpg"></p><p>而只有在调用<code>CachingExecutor</code>的<code>flushCacheIfRequired</code>方法时可能调用<code>TransactionalCacheManager</code> 的clear方法（见前文源码），追溯到底，若想触发clearOnCommit = true，则需要触发<code>MappedStatement#isFlushCacheRequired</code>为true，当执行更新操作时上述情况才会发生。</p></li></ul><p>得出<strong>二级缓存数据一致性原理</strong>：执行器执行更新操作时，<code>MappedStatement#isFlushCacheRequired</code>为true，对应缓存的<code>TransactionalCache</code>的clearOnCommit = true，达到在没有事务提交或回滚前，缓存查询不命中的效果，保证数据的一致性。</p><h3 id="二级缓存命中示例"><a href="#二级缓存命中示例" class="headerlink" title="二级缓存命中示例"></a>二级缓存命中示例</h3><p>调用执行器的<code>commit</code>方法进行提交时，二级缓存中才会有数据，后续的查询操作才能命中缓存，示例代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* cachingExecutor的二级缓存</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cachingExecutorTest</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    CachingExecutor cachingExecutor = <span class="keyword">new</span> CachingExecutor(<span class="keyword">new</span> SimpleExecutor(configuration,transaction));</span><br><span class="line">    MappedStatement ms = configuration.getMappedStatement(<span class="string">&quot;ws.mybatis.demo.mapper.UserMapper.selectByPrimaryKey&quot;</span>);</span><br><span class="line">    <span class="comment">// 查询id为1的user</span></span><br><span class="line">    List&lt;User&gt; ls1 = cachingExecutor.query(ms, <span class="number">1L</span>,RowBounds.DEFAULT,Executor.NO_RESULT_HANDLER);</span><br><span class="line">    cachingExecutor.commit(<span class="keyword">true</span>);<span class="comment">// 提交，重要！！！</span></span><br><span class="line">    <span class="comment">// 命中二级缓存</span></span><br><span class="line">    List&lt;User&gt; ls2 = cachingExecutor.query(ms, <span class="number">1L</span>,RowBounds.DEFAULT,Executor.NO_RESULT_HANDLER);</span><br><span class="line">    List&lt;User&gt; ls3 = cachingExecutor.query(ms, <span class="number">1L</span>,RowBounds.DEFAULT,Executor.NO_RESULT_HANDLER);</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>,ls1.get(<span class="number">0</span>).equals(ls2.get(<span class="number">0</span>)));<span class="comment">// true</span></span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>,ls2.get(<span class="number">0</span>).equals(ls3.get(<span class="number">0</span>)));<span class="comment">// true</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>因为二级缓存是跨线程跨连接调用的，所以需要设计成提交后数据才会写入缓存，而一级缓存是单线程内调用，所以无需提交。</p><h3 id="CachingExecutor实现二级缓存总结"><a href="#CachingExecutor实现二级缓存总结" class="headerlink" title="CachingExecutor实现二级缓存总结"></a><code>CachingExecutor</code>实现二级缓存总结</h3><ul><li><code>CachingExecutor</code>使用“装饰者模式”，装饰一级缓存的<code>Executor</code>执行器对象，增加二级缓存的功能</li><li>查询操作时，查询顺序是：二级缓存 -&gt; 一级缓存 -&gt; 数据库</li><li><code>CachingExecutor</code>本身不维护二级缓存，而是作为<code>MappedStatement</code>的缓存的调用者，所以二级缓存也被称为“Mapper级别的缓存”。事务缓存管理器对象<code>TransactionalCacheManager</code> 、<code>TransactionalCache</code>、<code>MappedStatement</code>三者的搭配实现了二级缓存底层功能。</li><li>执行<code>CachingExecutor</code>实现<code>Executor</code>执行器接口的<code>update</code>更新方法时，会先清除二级缓存的所有数据，再调用被装饰执行器的<code>update</code>方法执行更新操作</li><li>二级缓存需要手动开启，mapper.xml文件中需要指定<code>&lt;cache/&gt;</code>标签以开启二级缓存，这样生成的<code>MappedStatement</code>才会有<code>Cache</code>缓存对象，<code>MappedStatement#getCache()</code>方法返回值不是null（见<code>query</code>方法源码），<code>CachingExecutor</code>才能使用到<code>MappedStatement</code>的缓存。</li></ul><h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><ol><li><p>二级缓存线程安全吗，一级缓存呢？</p><p>二级缓存线程不安全，二级缓存是mapper级别的缓存，是跨线程跨连接的，实际的实现是<code>MappedStatement</code>来实现的，底层存储也是HashMap而不是ConcurrentHashMap，二级缓存也不用也没必要实现线程安全，因为SqlSession本身就是线程不安全的。</p><p>一级缓存肯定是线程安全的，因为一级缓存的读写只可能在一个线程，一个连接里发生。（如果你强行将<code>BaseExeCutor</code>让多个线程调用，那当我没说）</p></li><li><p>二级缓存能保证100%数据一致性吗？</p><p>不能，因为<code>MappedStatement</code>对象是SQL映射语句的封装，那么当这个sql操作过的表，在其他mapper的sql里也操作了，对应<code>MappedStatement</code>的缓存肯定是不感知的，所以二级缓存的数据一致性，需要开发者自己注意，MyBatis的<code>CachingExecutor</code>在代码层面上有效保证了数据一致性，但是实际的sql语句造成的影响需要开发者控制，这也是为什么二级缓存需要手动开启的原因。</p></li><li><p>二级缓存为什么不在<code>BaseExecutor</code>实现？</p><p>二级缓存如果在<code>BaseExecutor</code>实现，那么<code>BaseExecutor</code>必然需要怎么某种开关去控制二级缓存的开启与关闭，这就造成<code>BaseExecutor</code>的职责不单一，面向对象编程应该要让一个类职责明确。</p></li><li><p>二级缓存为什么不像一级缓存一样通过类继承实现？</p><p>如此做会造成<code>Executor</code>类体系结构过于复杂，使用装饰者模式在不改变原有功能的基础上增加二级缓存功能是很好的选择。</p></li><li><p>三级缓存甚至n级缓存如何实现？</p><p>参考二级缓存的实现，继续使用装饰者模式实现三级缓存甚至n级缓存都是ok的。</p></li></ol><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p>MyBatis源码阅读指南【鲁班大叔】：<a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv7933087">https://www.bilibili.com/read/cv7933087</a></p><hr><p><strong>本文参考B站UP主“鲁班大叔”<a target="_blank" rel="noopener" href="https://space.bilibili.com/190795407%E7%9A%84MyBatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%95%99%E5%AD%A6%E8%A7%86%E9%A2%91%E8%BF%9B%E8%A1%8C%E6%95%B4%E7%90%86%EF%BC%9B">https://space.bilibili.com/190795407的MyBatis源码分析教学视频进行整理；</a></strong></p><p><strong>感谢成长路上为在下传道受业解惑之人</strong></p>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
          <category> MyBatis源码 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nginx调优</title>
      <link href="WindShadow/Nginx/nginx%E8%B0%83%E4%BC%98/"/>
      <url>WindShadow/Nginx/nginx%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx调优"><a href="#Nginx调优" class="headerlink" title="Nginx调优"></a>Nginx调优</h1><h2 id="并发数"><a href="#并发数" class="headerlink" title="并发数"></a>并发数</h2><p>基于nginx的多进程架构，通过合理配置worker_processes、worker_connections、worker_rlimit_nofile参数可调节nginx的最优并发。</p><h3 id="worker-processes"><a href="#worker-processes" class="headerlink" title="worker_processes"></a>worker_processes</h3><p>在nginx配置文件全局块中，通过 worker_processes 参数配置worker 进程数，设置为 auto时，nginx则会自动设置与cpu核心数相同的数量worker 进程。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span> auto;</span><br></pre></td></tr></table></figure><h3 id="worker-connection"><a href="#worker-connection" class="headerlink" title="worker_connection"></a>worker_connection</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个值是表示每个worker进程所能建立连接的最大值，所以，一个nginx能建立的最大连接数，应该是 worker_connections * worker_processes。当然，这里说的是最大连接数，对于HTTP请求本地资源来说，能够支持的最大并发数量是worker_connections * worker_processes，如果是支持http1.1的浏览器每次访问要占两个连接（ 并不是request和response响应占用两个连接 ），所以普通的静态访问最大并发数是：worker_connections * worker_processes / 2，而如果是HTTP作为反向代理来说，最大并发数量应该是worker_connections * worker_processes / 4，因为作为反向代理服务器,每个并发会建立与客户端的连接和与后端服务的连接，即2*2=4。</p><h3 id="worker-rlimit-nofile"><a href="#worker-rlimit-nofile" class="headerlink" title="worker_rlimit_nofile"></a>worker_rlimit_nofile</h3><p>这个参数表示worker进程最多能打开的文件句柄数，基于liunx系统ulimit设置<em>（Linux一切皆文件，所有请求过来最终目的访问文件，查看系统文件句柄数最大值（<strong>用户</strong>可以打开文件的最大数目）：ulimit -n；一般root用户是65535，普通用户是1024）</em></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nginx配置文件全局块</span></span><br><span class="line"><span class="comment"># 配置nginx worker进程最大打开文件数</span></span><br><span class="line"><span class="attribute">worker_rlimit_nofile</span> <span class="number">65535</span>; </span><br></pre></td></tr></table></figure><p>worker_rlimit_nofile 理论值应该是最多打开文件数（ulimit -n）与nginx worker进程进程数相除，但是nginx分配请求并不是那么均匀，所以与ulimit -n的值保持一致为优。</p><p>所以 worker_connections 值不能超过 worker_rlimit_nofile ，否则在高并发下可能会出现“too many open files”的异常。</p><h2 id="nginx长连接"><a href="#nginx长连接" class="headerlink" title="nginx长连接"></a>nginx长连接</h2><h3 id="保持和客户端的长连接"><a href="#保持和客户端的长连接" class="headerlink" title="保持和客户端的长连接"></a>保持和客户端的长连接</h3><p>一般情况下，nginx已经自动开启了对客户端（浏览器）连接的keep alive（http1.1）支持。</p><p>同时可设置以下两个配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">120s</span> <span class="number">120s</span>;</span><br><span class="line">    <span class="attribute">keepalive_requests</span> <span class="number">10000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>keepalive_timeout<br>指令格式：keepalive_timeout timeout [header_timeout];</p><p>timeout ：设置keep-alive客户端连接在服务器端保持开启的超时值（默认75s）；值为0即禁用keep-alive客户端连接；<br>header_timeout：可选，在响应的header域中设置一个值“Keep-Alive: timeout=time”；通常可不设置；<br>timeout默认75s，一般情况下也够用，对于一些请求比较大的内部服务器通讯的场景，适当加大。</p></li><li><p>keepalive_requests<br>keepalive_requests指令用于设置一个keep-alive连接上可以服务的请求的最大数量，当最大请求数量达到时，连接被关闭，默认为100。</p><p>该参数的工作机制：一个keep alive建立之后，nginx就会为这个连接设置一个计数器，记录这个keep alive的长连接上已经接收并处理的客户端请求的数量。如果达到这个参数设置的最大值时，则nginx会强行关闭这个长连接，逼迫客户端不得不重新建立新的长连接。</p></li></ul><h3 id="保持和server的长连接"><a href="#保持和server的长连接" class="headerlink" title="保持和server的长连接"></a>保持和server的长连接</h3><p>nginx访问后端server（nginx称为upstream，上游服务器）默认用的是短连接的HTTP1.0协议，客户端请求到达时，nginx与后端建立连接，后端响应完毕后主动关闭该连接。</p><p>为了让nginx和后端server之间保持长连接，一般指明nginx请求后端服务的协议为http1.1</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">upstream</span>  BACK_SERVER &#123;</span><br><span class="line">        <span class="attribute">server</span>   <span class="number">10.0.0.1:8080</span>  weight=<span class="number">1</span> max_fails=<span class="number">2</span> fail_timeout=<span class="number">30s</span>;</span><br><span class="line">        <span class="attribute">server</span>   <span class="number">10.0.0.2:8080</span>  weight=<span class="number">1</span> max_fails=<span class="number">2</span> fail_timeout=<span class="number">30s</span>;</span><br><span class="line">        keepalive 300;        // 设置空闲连接的最大数量</span><br><span class="line">    &#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line">        <span class="attribute">server_name</span> www.myapp.com;</span><br><span class="line">        <span class="attribute">location</span> /  &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://BACK_SERVER ;</span><br><span class="line">          <span class="comment"># 其它配置...</span></span><br><span class="line">            proxy_http_version 1.1;// 指明请求后端的协议</span><br><span class="line">            proxy_set_header Connection &quot;&quot;; // 清理来自客户端的Connection请求头</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>proxy_set_header Connection &quot;&quot;;</code>指令作用时清理来自客户端的Connection请求头，因为http1.1保持开启的长连接的关键是Connection请求头， 因为如果客户端和nginx之间是短连接（http1.0），我们把Connection请求头也带到后端，那么nginx与后端就不会开启长连接了，所以此处需要清除。</p><h3 id="upstream块的keepalive"><a href="#upstream块的keepalive" class="headerlink" title="upstream块的keepalive"></a>upstream块的keepalive</h3><p>官方解释：设置到upstream服务器的空闲keepalive连接的最大数量， 当这个数量被突破时，最近使用最少的连接将被关闭，keepalive指令不会限制一个nginx worker进程到upstream服务器连接的总数量。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span>  BACK_SERVER &#123;</span><br><span class="line">        <span class="attribute">server</span>   <span class="number">10.0.0.1:8080</span>  weight=<span class="number">1</span> max_fails=<span class="number">2</span> fail_timeout=<span class="number">30s</span>;</span><br><span class="line">        <span class="attribute">server</span>   <span class="number">10.0.0.2:8080</span>  weight=<span class="number">1</span> max_fails=<span class="number">2</span> fail_timeout=<span class="number">30s</span>;</span><br><span class="line">        <span class="attribute">keepalive</span> <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说白了就是nginx往后端服务器发的请求的空闲连接的最大数量，假设keepalive设置为30，此时来了100个请求，nginx新建了100个线程去请求后端，那么请求结束后，nginx会关闭100-30=70个线程，此时又再来了100个请求，nginx必须再新建70个线程去请求后端，之前30个线程被复用。所以合理配置keepalive是很有必要的。</p><p><strong>一般把upstream块的keepalive配置和保持和server长连接的配置结合使用。</strong></p><h2 id="持续更新……"><a href="#持续更新……" class="headerlink" title="持续更新……"></a>持续更新……</h2>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker容器数据卷</title>
      <link href="WindShadow/Docker/docker%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7/"/>
      <url>WindShadow/Docker/docker%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7/</url>
      
        <content type="html"><![CDATA[<p>我们知道docker容器相当于一个小型linux系统，docker容器被删除后，这个系统也就消失了，如果数据都在容器中，那么删除容器后数据就会丢失，如mysql容器中数据库表数据，docker提供了数据卷来对容器内的数据进行持久化。</p><h2 id="数据卷挂载"><a href="#数据卷挂载" class="headerlink" title="数据卷挂载"></a>数据卷挂载</h2><p><img src="/WindShadow/Docker/docker%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7/docker-volume.webp"></p><p>作用：将容器内的文件映射（挂载）到宿主机，类似硬链接。</p><p>数据卷是一个可供容器使用的特殊目录，它绕过文件系统，可以提供很多有用的特性：</p><ol><li>数据卷可以在容器之间共享和重用。</li><li>对数据卷的更改会立即生效。</li><li>对数据卷的更新不会影响镜像。</li><li>和容器的生命周期是分离的，数据卷会一直存在，除非被清理。</li><li>数据卷的变化不会影响镜像的更新。数据卷是独立于联合文件系统，镜像是基于联合文件系统。镜像与数据卷之间不会相互影响。</li></ol><p>上图表示了docker挂载卷的3种方式：volume、bind mount、tmpfs mounts；</p><h3 id="volume挂载方式"><a href="#volume挂载方式" class="headerlink" title="volume挂载方式"></a>volume挂载方式</h3><p>volume意思为“卷”，可在执行<code>docker run</code>命令时使用<code>-v</code>选项挂载卷，docker管理数据卷的目录一般为<code>/var/lib/docker/volumes/</code></p><p><img src="/WindShadow/Docker/docker%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7/docker-volumes.png"></p><h5 id="匿名挂载"><a href="#匿名挂载" class="headerlink" title="匿名挂载"></a>匿名挂载</h5><p>命令示例：<code>docker run -v &lt;容器内路径&gt; centos</code>；此方式为<strong>匿名挂载</strong>，docker将分配一个匿名的数据卷（如上图16进制字符构成的文件夹），将容器内的路径硬链接到该卷下的_data目录。</p><h5 id="具名挂载"><a href="#具名挂载" class="headerlink" title="具名挂载"></a>具名挂载</h5><p>命令示例：<code>docker run -v &lt;卷名称&gt;:&lt;容器内路径&gt; centos</code>；此方式为<strong>具名挂载</strong>，docker将分配一个有具体名称的数据卷（如上图mycentos-v文件夹），如果该名称卷已经存在则直接使用而不再创建，将容器内的路径硬链接到该卷下的_data目录。</p><p>数据卷挂载文件覆盖问题：</p><ul><li>如果容器内路径不存在则被创建</li><li>如果挂载一个空的数据卷到容器中的一个非空目录中，那么这个目录下的文件会被复制到数据卷中。</li><li>如果挂载一个非空的数据卷到容器中的一个目录中，那么容器中的目录中会显示数据卷中的数据。如果原来容器中的目录中有数据，那么这些原始数据会被隐藏掉。</li></ul><p>这两个规则都非常重要，灵活利用第一个规则可以帮助我们初始化数据卷中的内容。掌握第二个规则可以保证挂载数据卷后的数据总是你期望的结果。</p><p>除此之外，也可以在通过Dockerfile构建镜像时指定挂载出匿名数据卷。</p><h3 id="bind-mounts绑定挂载"><a href="#bind-mounts绑定挂载" class="headerlink" title="bind mounts绑定挂载"></a>bind mounts绑定挂载</h3><p>绑定文件系统的文件。</p><p>命令示例：<code>docker run -v &lt;宿主机路径&gt;:&lt;容器内路径&gt; centos</code> ；此方式为指定路径挂载，此挂载方式，docker直接将容器内的路径硬链接到指定的宿主机目录，有以下几点值得注意：</p><ul><li>且宿主机路径必须是绝对路径</li><li>无论宿主机路径还是容器内路径，路径不存在则被创建</li><li>文件覆盖规则：【宿主机 -&gt; 容器内】</li><li>此种挂载方式无法通过<code>docker volume</code>管理卷。</li></ul><h3 id="只读挂载"><a href="#只读挂载" class="headerlink" title="只读挂载"></a>只读挂载</h3><p>过ro选项指定挂载的数据卷是只读的，意味着容器无法对挂载的文件进行修改，只能读，即挂载的文件只允许宿主机单向修改。rw便是可读可写，默认卷读写性质为rw。</p><ul><li><p>匿名挂载的只读：匿名挂载不支持只读，即使使用<code>--read-only</code>选项进行只读限定，也不会生效，卷读写性质依旧为rw</p></li><li><p>具名挂载的只读：命令示例：<code>docker run -v &lt;卷名称&gt;:&lt;容器内路径&gt;:ro centos</code></p></li><li><p>bind mounts挂载的只读：命令示例：<code>docker run -v &lt;宿主机路径&gt;:&lt;容器内路径&gt;:ro centos</code>；文件覆盖情况【宿主机 -&gt; 容器内】且是强制覆盖，且容器无法对该目录的文件进行修改</p></li></ul><h3 id="tmpfs临时文件系统"><a href="#tmpfs临时文件系统" class="headerlink" title="tmpfs临时文件系统"></a>tmpfs临时文件系统</h3><p>volume挂载方式（卷挂载）和bind mounts挂载方式（绑定挂载）允许在主机和容器之间共享文件，以便即使在容器停止后也可以保留数据。Linux上运行的Docker，有第三个挂载方式选择：tmpfs，即临时的文件系统。</p><p>以tmpfs挂载方式创建容器时，容器可以在容器的可写层外创建文件。与卷和绑定挂载相反，tmpfs挂载是临时的，并且仅保留在主机内存中。当容器停止时，将tmpfs删除。这对于临时存储不希望在主机或容器可写层中保留的敏感文件很有用。</p><p>tmpfs挂载的限制：</p><ul><li>与卷和绑定挂载不同，tmpfs无法在容器之间共享</li><li>只有在Linux上运行的Docker才能使用此功能</li></ul><p>命令实例：<code>docker run --rm -it --tmpfs /root  centos</code>；</p><p>tmpfs挂载允许两个配置选项，都不是必需的。如果需要指定这些选项，则必须使用该<code>--mount</code>选项，因为该–tmpfs选项不支持它们：</p><ul><li>tmpfs-size：tmpfs挂载的大小（单位：字节），默认无限</li><li>tmpfs-mode：tmpfs的文件模式，为八进制，即linux系统下的文件读写权限的数字标识，例如700或0770，默认值为1777（全局可写）</li></ul><p>命令实例：<code>docker run --rm -it --mount type=tmpfs,destination=/root,tmpfs-mode=1770  centos</code></p><p>关于<code>--mount</code>与<code>--tmpfs</code>的区别：<a target="_blank" rel="noopener" href="https://docs.docker.com/storage/tmpfs/#use-a-tmpfs-mount-in-a-container">https://docs.docker.com/storage/tmpfs/#use-a-tmpfs-mount-in-a-container</a></p><h2 id="数据卷管理"><a href="#数据卷管理" class="headerlink" title="数据卷管理"></a>数据卷管理</h2><h3 id="docker-volume"><a href="#docker-volume" class="headerlink" title="docker volume"></a>docker volume</h3><p>作用：可以通过<code>docker volume</code>命令管理数据卷</p><p>常见命令格式：<code>docker volume &lt;option&gt;</code></p><ul><li><code>docker volume ls</code>：查看所有数据卷</li><li><code>docker volume rm &lt;卷名称&gt;</code>：删除数据卷，还有容器使用的数据卷不可被删除</li><li><code>docker volume inspect &lt;卷名称&gt;</code>：查看数据卷详情</li><li><code>docker volume create &lt;卷名称&gt;</code>：创建一个数据卷</li></ul><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>容器挂载数据卷，其它容器通过挂载这个（父容器）实现数据共享，这个挂载数据卷的“父”容器称之为数据卷容器；</p><p>因为数据卷会存在直到没有容器使用为止（除非手动强制删除），像多个数据库容器场景下，容器之间需要传递共享数据卷，使用容器维护数据卷，这就是数据卷容器。</p><p><img src="/WindShadow/Docker/docker%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7/volumes-from.jpg"></p><h3 id="–volumes-from"><a href="#–volumes-from" class="headerlink" title="–volumes-from"></a>–volumes-from</h3><p>可在执行<code>docker run</code>命令时使用<code>--volumes-from</code>选项从其它容器挂载卷。</p><p>命令示例：<code>docker run -it --volumes-from=&lt;容器id或容器名&gt; centos</code>，数据覆盖情况：【卷 -&gt; 容器内】；</p><p>我们可以把<code>--volumes-from</code>选项比作继承，上图中，容器X挂载出volume1、volume2，数据卷容器A和容器B继承自容器X，容器C继承容器A，容器D继承容器B，最终ABCD容器都挂载了volume1、volume2，无论哪个容器对数据卷内的文件进行修改，其它容器都能同步更新到，容器X便是数据卷容器。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker网络</title>
      <link href="WindShadow/Docker/docker%E7%BD%91%E7%BB%9C/"/>
      <url>WindShadow/Docker/docker%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="docker0网卡"><a href="#docker0网卡" class="headerlink" title="docker0网卡"></a>docker0网卡</h2><p>服务器安装了docker，就会有一个网卡docker0，docker0网卡使用nat直连到服务器的物理网卡。</p><p><img src="/WindShadow/Docker/docker%E7%BD%91%E7%BB%9C/docker-veth-pair.jpg"></p><h3 id="evth-pair"><a href="#evth-pair" class="headerlink" title="evth-pair"></a>evth-pair</h3><p>evth-pari 是一种虚拟网络设备，是一对的虚拟设备接口，它们都是成对出现的，一端连着内核协议栈 ，一端彼此相连着，一个设备收到协议栈的数据发送请求后，会将数据发送到另一个设备上去，正因为这个特性，evth-pair 充当一个桥梁，连接各种虚拟网络设备；OpenStack，Docker容器之间的连接, OVS的连接，都是使用 evth-pair 技术。</p><p>上图中，docker0扮演的角色可以比作容器依赖的路由器，容器不指定网络的情况下，都是通过docker0路由的，docker会给容器分配一个默认的可用ip，只要容器被删除，对应的evth-pari接口就没了 。docker中通过evth-pair连接到docker0的网络连接模式称之为<strong>桥接</strong>模式，该模式下的任意容器之间是可以相互ping通的。</p><p>桥接到docker0网卡的方式缺点也很明显，无法预知容器IP，且在容器重启后IP可能会发生变化，导致容器内的应用之间存在依赖时，不方便配置，如数据库IP等。</p><h3 id="docker0-IP分配方式"><a href="#docker0-IP分配方式" class="headerlink" title="docker0 IP分配方式"></a>docker0 IP分配方式</h3><p>需要注意的是，docker0分配IP的方式是按顺序分配，如已经分配了容器A（172.17.0.1）、容器B（172.17.0.2），下一个容器C的IP为172.17.0.3，如果此时容器B停止或被删除，再新建容器D时，其IP为172.17.0.2。</p><h2 id="link方式连接"><a href="#link方式连接" class="headerlink" title="link方式连接"></a>link方式连接</h2><p>容器桥接到docker0的网络连接方式显然不能满足部署需求，如果能使用容器名进行网络连接，就不必担心容器重启后IP改变的问题了，docker提供了link方式的网络连接；</p><p>在<code>docker run</code>启动容器时使用<code>--link</code>选项连接到其它容器：命令示例：<code>docker run -it --link &lt;容器id或容器名&gt;:[alias] centos</code>；</p><ul><li><code>docker run -it --name=mycentos --link mysql-dev centos</code>：启动一个名为mycentos的容器，且连接到名为mysql-dev的容器，此时在mycentos容器内可以使用<code>ping mysql-dev</code>的方式ping通名为mysql-dev的容器</li><li><code>docker run -it --name=mycentos --link mysql-dev:db centos</code>：alias是容器在link模式下的别名，同上，在mycentos容器内还可以使用<code>ping db</code>的方式ping通名为mysql-dev的容器</li></ul><h3 id="link方式连接原理"><a href="#link方式连接原理" class="headerlink" title="link方式连接原理"></a>link方式连接原理</h3><p>在源容器的hosts文件写入目标容器名、目标容器link下的别名、目标容器id，均指向目标容器的IP，当目标容器的IP发生变化时，hosts文件的配置也跟着发生变化，这是通过docker容器的环境变量完成的。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>显然的，源容器通过link方式连接到目标容器时，可以通过容器名访问目标容器，反过来则不行，因为是通过写hosts的形式去实现的。</li><li>当目标容器被删除时，源容器的hosts配置还存在，此时新的容器“占据”旧目标容器IP时（依据docker0的 IP分配方式），源容器的hosts配置并不会发生改变，故而连接到新的容器。</li></ul><p>官方已经已经不推荐使用link方式去设计容器的网络了。</p><h2 id="自定义网络（核心）"><a href="#自定义网络（核心）" class="headerlink" title="自定义网络（核心）"></a>自定义网络（核心）</h2><p>既然docker通过容器模拟了一个小型的linux操作系统，自然也少不了计算机网络。docker提供<code>docker network</code>命令来管理网络，使用docker创建网络的主要参数有：网络名称，网络模式，子网，网关。</p><h3 id="docker的网络模式"><a href="#docker的网络模式" class="headerlink" title="docker的网络模式"></a>docker的网络模式</h3><ul><li><p>bridge</p><p>桥接模式，docker默认的网络模式，该模式下容器桥接到docker0网卡</p></li><li><p>none</p><p>不配置网络</p></li><li><p>host</p><p>和宿主机共享网络，即使用宿主机的IP端口</p></li><li><p>container</p><p>容器网络连通（用得少，局限大）</p></li></ul><h3 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h3><h4 id="docker-network-create"><a href="#docker-network-create" class="headerlink" title="docker network create"></a>docker network create</h4><p>作用：创建网络；</p><p>命令格式：<code>docker network create [options] &lt;网络名&gt;</code>；</p><p>常见命令格式：<code>docker network create --driver &lt;网络模式&gt; --subnet &lt;子网&gt; --gateway &lt;网关地址&gt; &lt;网络名称&gt; </code>；</p><p>常用option选项：</p><ul><li><code>--driver</code>：指定网络模式，不指定默认为桥接模式(driver)，一般使用桥接模式较多</li><li><code>--subnet</code>：指定子网，写法为网段 + 掩码，如10.0.0.0/16</li><li><code>--gateway</code>：指定网关地址</li><li><code>--ip-range</code>：指定ip网络内可动态分配的IP范围，写法为网段 + 掩码，如10.0.0.0/16</li></ul><p>示例：<code>docker network create --driver bridge --subnet 10.0.0.0/16 --gateway 10.0.0.254 mynet</code>，该命令创建了一个网络，名称为”mynet”，网络模式为桥接模式（bridge ），子网为10.0.0.0/16，网关为10.0.0.254，此时宿主机网络情况如下</p><p><img src="/WindShadow/Docker/docker%E7%BD%91%E7%BB%9C/mynet.svg"></p><h4 id="docker-network-ls"><a href="#docker-network-ls" class="headerlink" title="docker network ls"></a>docker network ls</h4><p>查看当前所有网络；常见命令格式：<code>docker network ls [option]</code>；</p><p>示例：<code>docker network ls -f &#39;driver=bridge&#39;</code>：查看所有网络中网络模式为桥接的网络。</p><h4 id="docker-network-inspect"><a href="#docker-network-inspect" class="headerlink" title="docker network inspect"></a>docker network inspect</h4><p>查看网络详情；常见命令格式：<code>docker network inspect &lt;网络id或网络名称&gt;</code>；</p><p>该命令可查看网络创建时的基本信息和使用该网络的容器信息等。</p><h4 id="docker-network-rm"><a href="#docker-network-rm" class="headerlink" title="docker network rm"></a>docker network rm</h4><p>删除网络；常见命令格式：<code>docker network rm &lt;网络id或网络名称&gt;</code>；</p><h3 id="容器连接或断开网络"><a href="#容器连接或断开网络" class="headerlink" title="容器连接或断开网络"></a>容器连接或断开网络</h3><p>可以使用<code>docker run</code>新建容器时可使用<code>--network</code>或<code>--net</code>将容器连接到指定的网络：<code>docker run -it --net &lt;网络id或网络名&gt; centos</code>，另一种便是使用<code>docker network connect</code>命令。</p><h3 id="docker-network-connect"><a href="#docker-network-connect" class="headerlink" title="docker network connect"></a>docker network connect</h3><p>作用：将容器连接到网络；</p><p>常见的命令格式：<code>docker network connect &lt;网络id或网络名称&gt; [options] &lt;容器名&gt;</code>；</p><p>option选项：</p><ul><li><code>--alias</code> ：指定该容器在该网络中的别名</li><li><code>--ip</code>：指定IP地址（常用）</li><li><code>--ip6</code>：指定IPv6地址</li><li><code>--link</code>：链接到另一个容器</li><li><code>--link-local-ip</code>：添加容器的链接本地地址</li></ul><p><code>docker network connect</code>的选项几乎全都可在<code>docker run</code>时使用。</p><h3 id="docker-network-disconnect"><a href="#docker-network-disconnect" class="headerlink" title="docker network disconnect"></a>docker network disconnect</h3><p>作用：将容器与网络断开；</p><p>常见的命令格式：<code>docker network disconnect [option] &lt;网络id或网络名称&gt; &lt;容器名&gt;</code>；</p><p>断开条件：容器必须正在运行才能将其与网络断开连接；</p><p>option选项：</p><ul><li><code>-f</code>：强制断开容器与网络的连接</li></ul><p>容器连接到网络之后，容器内都有一个默认的DNS服务器配置，这样任意容器之间均可通过容器名互相访问，而不需要像link方式般由hsots文件维护容器名与IP的关系。</p><h3 id="停止、暂停或重启容器对网络的影响"><a href="#停止、暂停或重启容器对网络的影响" class="headerlink" title="停止、暂停或重启容器对网络的影响"></a><strong>停止、暂停或重启容器对网络的影响</strong></h3><p>暂停、重新启动和停止连接到网络的容器，容器在运行时会连接到其配置的网络：</p><ul><li>若未容器指定IP（动态IP），容器启动时自动获取网络内可分配的IP</li><li>若未容器指定了IP（静态IP），容器启动时应用容器的 IP 地址，如果 IP 地址不再可用，则容器无法启动。</li></ul><p>保证 IP 地址可用的一种方法：</p><p>使用<code>--ip-range</code>指定一个网络自动分配的IP的范围，使用<code>--ip</code>给容器指定该范围之外的IP地址（静态IP），可确保在此容器不在网络上时不会将 IP 地址提供给另一个容器。</p><p>如：<code>docker network create --driver bridge --subnet 10.0.0.0/24 --ip-range 10.0.0.0/25 --gateway 10.0.0.254 mynet</code>，创建一个网络名叫”mynet”，子网为10.0.0.0/24，可动态分配的地址范围为10.0.0.0/25，网关为10.0.0.254，新建容器A、容器B、容器C且都加入mynet网络，容器C使用<code>--ip</code>指定IP地址。</p><p><img src="/WindShadow/Docker/docker%E7%BD%91%E7%BB%9C/docker%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C.svg"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker基础</title>
      <link href="WindShadow/Docker/docker%E5%9F%BA%E7%A1%80/"/>
      <url>WindShadow/Docker/docker%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker基础知识"><a href="#Docker基础知识" class="headerlink" title="Docker基础知识"></a>Docker基础知识</h2><h3 id="Docker的基本组成"><a href="#Docker的基本组成" class="headerlink" title="Docker的基本组成"></a>Docker的基本组成</h3><p><img src="/WindShadow/Docker/docker%E5%9F%BA%E7%A1%80/docker.png"></p><ul><li><p>镜像（image)：</p><p>docker镜像就好比是一个模板，可以通过这个模板来创建容器对外提供服务，如通过tomcat镜像创建一个tomcat容器，容器内的tomcat运行我们的war包对外提供服务，而一个镜像可以创建多个容器，我们不需要像传统部署一样每次都手动部署war，修改端口配置等。</p></li><li><p>容器(container)：</p><p>Docker利用容器技术，独立运行一个或者一组应用，容器通过镜像来创建。对容器的基本操作有启动，停止，删除等，可以把这个容器理解为就是一个简易的Linux系统。</p></li><li><p>仓库(repository)：</p><p>仓库就是存放镜像的地方，仓库分为公有仓库和私有仓库，类似GitHub，DockerHub便是镜像仓库。</p></li></ul><h3 id="Docker如何工作"><a href="#Docker如何工作" class="headerlink" title="Docker如何工作"></a>Docker如何工作</h3><p>Docker是一个Client-Server结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端访问！Docker-Server接收到Docker-Client的指令并执行。</p><p><img src="/WindShadow/Docker/docker%E5%9F%BA%E7%A1%80/docker-cs.png"></p><h3 id="为什么Docker比VM快"><a href="#为什么Docker比VM快" class="headerlink" title="为什么Docker比VM快"></a>为什么Docker比VM快</h3><ol><li><p>docker有着比虚拟机更少的抽象层。由于docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。</p><p><img src="/WindShadow/Docker/docker%E5%9F%BA%E7%A1%80/docker-vs-vm.png"></p></li><li><p>docker利用的是宿主机的内核,而不需要Guest OS。</p></li></ol><p>当docker新建一个容器时，docker不需要和虚拟机一样重新加载一个操作系统内核，避免了引导、加载操作系统内核返个比较费时费资源的过程。VM新建一个虚拟机时，虚拟机软件需要加载GuestOS，而docker由于直接利用宿主机的操作系统,则省略了这个复杂的过程</p><ul><li>Hypervisor：虚拟机监视器（virtual machine monitor，缩写为 VMM），是用来建立与执行虚拟机器的软件、固件或硬件。</li><li>GuestOS： VM（虚拟机）里的的系统（OS）</li><li>HostOS：物理机里的系统（OS）</li></ul><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><p>Docker的安装要求Linux在内核3.0以上</p><p>官方安装文档：<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/">https://docs.docker.com/engine/install/ </a></p><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示docker版本</span></span><br><span class="line">docker version</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看镜像容器数量等信息</span></span><br><span class="line">dcoker info </span><br><span class="line"><span class="meta">#</span><span class="bash"> 帮助命令，查看某个命令如何使用</span></span><br><span class="line">docker &lt;命令&gt; --help</span><br></pre></td></tr></table></figure><p>docker全部命令官方文档：<a target="_blank" rel="noopener" href="https://docs.docker.com/reference/">https://docs.docker.com/reference/</a></p><h2 id="操作镜像"><a href="#操作镜像" class="headerlink" title="操作镜像"></a>操作镜像</h2><h3 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h3><p>作用：查看镜像</p><ul><li><p><code>docker images</code>查看当前系统的镜像（默认隐藏中间的镜像）</p></li><li><p><code>docker images -a</code>查看全部镜像，包括中间层的镜像</p></li><li><p><code>docker images -q</code>查看镜像，仅显示镜像id</p></li><li><p><code>docker images -f &lt;key=valu&gt;</code>查看镜像，根据条件过滤</p><p>key的范围：</p><ul><li>dangling：显示标记为<code>&lt;none&gt;</code>的镜像，取值范围：true | false，如：<code>docker images -f dangling=true</code></li><li>label：根据标签进行过滤，其中lable的值，是docker在编译的时候配置的或者在Dockerfile中配置的</li><li>before：根据某个镜像的构建时间进行过滤，before的value表示某个镜像构建时间之前的镜像列表，如：<code>docker images -f before=mysql</code></li><li>since：跟before正好相反，表示的是在某个镜像构建之后构建的镜像</li><li>reference：添加正则进行匹配，如：<code>docker images -f reference=&quot;*:latest&quot;</code>（查询版本为最新版本的镜像）</li></ul></li></ul><h3 id="docker-search"><a href="#docker-search" class="headerlink" title="docker search"></a>docker search</h3><p>作用：搜索远程仓库的镜像</p><p>如：<code>docker search mysql -f STARS=3000</code>（查询远程仓库镜像,查询mysql的镜像，且stars数量大于等于3000）</p><h3 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h3><p>作用：从远程仓库拉取镜像</p><p>格式<code>docker pull &lt;镜像名[:版本]&gt;</code>，等价于<code>docker image pull &lt;镜像名[:版本]&gt;</code>，如<code>docker pull mysql</code>（拉取mysql镜像，默认拉取最新版，latest），<code>docker pull mysql:5.7</code>（拉取mysql5.7镜像）</p><h3 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a>docker rmi</h3><p>作用：删除镜像</p><p>格式：<code>docker rmi &lt;镜像名或镜像ID&gt;</code> ，等价于<code>docker image rm &lt;镜像名或镜像ID&gt;</code> 。镜像删除时，docker默认不允许删除正在运行的容器所引用的镜像，除非指定-f选项。</p><ul><li><code>docker rmi mysql</code>（删除mysql的镜像）</li><li>删除时可通过<code>镜像名:tag</code>指定版本（标签）。如：<code>docker rmi mysql:5.7</code>这实际上只会删除mysql镜像为5.7的标签，除非该镜像仅有此标签，那么镜像就真的被删除</li><li><code>docker rmi -f mysql</code>：强制删除镜像</li><li><code>docker rmi -f $(docker images -aq)</code> （强制删除全部镜像，先查出id后删除）</li><li><code>docker images -q|xargs docker rmi</code>：使用管道符传参进行删除</li><li><code>docker rmi -no-prune</code>：不移除该镜像的过程镜像，默认移除</li><li>同一镜像有多个tag情况下，执行 <code>docker rmi &lt;镜像ID&gt;</code> 指令无法删除</li></ul><h2 id="操作容器"><a href="#操作容器" class="headerlink" title="操作容器"></a>操作容器</h2><p>扫盲：容器通过镜像创建而来，镜像与容器为1对多的关系。</p><h3 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h3><p>作用：新建并运行容器</p><p><code>docker run</code>等价于<code>docker container run</code></p><p>常见命令格式：<code>docker run [option1][option2] &lt;镜像id或名称&gt;</code>，如：<code>docker run --name=mysql-test mysql:5.7</code>（使用mysql5.7镜像新建并运行一个容器，容器名为“mysql-test”）。</p><p>docker run 命令支持的option非常多，介绍部分option：</p><ul><li>–name：指定容器名称</li><li>-i：以交互模式运行容器，通常与 -t 同时使用</li><li>-t：为容器重新分配一个伪终端，通常与 -i 使用</li><li>-d：以后台模式运行容器，并返回容器id，即启动守护式容器</li><li>-v：挂载卷（此处不展开讲，见下文）</li><li>-P：随机映射宿主机一个端口到容器内的一个端口</li><li>-p：指定端口映射，模式如下：<ul><li><code>ip:&lt;宿主机端口&gt;:&lt;容器端口&gt;</code>：宿主机IP+端口映射到容器内端口（如多网卡时）</li><li><code>ip::&lt;容器端口&gt;</code>：自动选择宿主机端口（包含宿主机所有IP）映射到容器内端口</li><li><code>&lt;宿主机端口&gt;:&lt;容器端口&gt;</code>：宿主机端口映射到容器内端口</li></ul></li><li>–rm：容器停止时删除容器</li></ul><h3 id="docker-create"><a href="#docker-create" class="headerlink" title="docker create"></a>docker create</h3><p>作用：新建容器，但不启动</p><p>常见命令格式：<code>docker create[option1][option2] &lt;镜像id或名称&gt;</code>，option选项参数含义与run类似但不是全都支持</p><h3 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h3><p>作用：查看容器的运行状况，类似linux的ps命令查看进程的运行状态</p><p><code>docker ps</code>等价于<code>docker container list</code>等价于<code>docker container ls</code></p><ul><li><code>docker ps</code>：列出正在运行的容器</li><li><code>docker ps -a</code>：列出全部容器，包括历史记录中已经停止的容器</li><li><code>docker ps -q</code>：列出正在运行的容器，仅显示容器id</li><li><code>docker ps -n=?</code>：列出最近创建的?个容器</li><li><code>docker ps -l</code>：列出最近创建的上个容器，即<code>docker ps -n=1</code></li></ul><h3 id="docker-stop"><a href="#docker-stop" class="headerlink" title="docker stop"></a>docker stop</h3><p>作用：停止正在运行的容器</p><p>常见命令格式：<code>docker stop &lt;容器id或容器名&gt;</code>，如：</p><ul><li><code>docker stop mysql-test</code>：停止容器名为mysql-test的容器</li><li><code>docker stop d29f876f66d5</code>：停止容器id为d29f876f66d5的容器</li></ul><h3 id="docker-kill"><a href="#docker-kill" class="headerlink" title="docker kill"></a>docker kill</h3><p>作用：强制停止正在运行的容器，类似linux的kill命令</p><p>常见命令格式：<code>docker kill &lt;容器id或容器名&gt;</code>，如：</p><ul><li><code>docker kill mysql-test</code>：强制停止容器名为mysql-test的容器</li></ul><h3 id="docker-start"><a href="#docker-start" class="headerlink" title="docker start"></a>docker start</h3><p>作用：启动容器</p><p>常见命令格式：<code>docker start &lt;容器id或容器名&gt;</code>，如：</p><ul><li><code>docker start mysql-test</code>：启动容器名为mysql-test的容器</li></ul><h3 id="docker-restart"><a href="#docker-restart" class="headerlink" title="docker restart"></a>docker restart</h3><p>作用：重启容器</p><p>常见命令格式：<code>docker restart &lt;容器id或容器名&gt;</code>，如：</p><ul><li><code>docker restartmysql-test</code>：重启容器名为mysql-test的容器</li></ul><h3 id="docker-rm"><a href="#docker-rm" class="headerlink" title="docker rm"></a>docker rm</h3><p>作用：删除容器</p><p>正常情况下正在运行的容器不可删除。</p><p>常见命令格式：<code>docker rm &lt;容器id或容器名&gt;</code>，如：</p><ul><li><code>docker rm mysql-test</code>：删除容器名为mysql-test的容器</li><li><code>docker rm -f mysql-test</code>：强制删除容器名为mysql-test的容器，即使该容器正在运行</li></ul><h2 id="与容器交互"><a href="#与容器交互" class="headerlink" title="与容器交互"></a>与容器交互</h2><h3 id="docker-attach"><a href="#docker-attach" class="headerlink" title="docker attach"></a>docker attach</h3><p>常见命令格式：<code>docker attach &lt;容器id或容器名&gt;</code>，此命令将进入容器正在执行的终端，如容器启动的前台进程是SpringBoot的jar（以前台模式启动），那么此方式进入容器后看到的就是SpringBoot应用的控制台打印的日志。</p><h3 id="docker-exec"><a href="#docker-exec" class="headerlink" title="docker exec"></a>docker exec</h3><p>常见命令格式：<code>docker exec [option] &lt;容器id或容器名&gt;</code>，进入当前容器后开启一个新的终端，option选项常用有：</p><ul><li>-i：即使没有附加也保持STDIN（标准输入）打开</li><li>-t：分配一个伪终端</li><li>-d：分离模式: 在后台运行</li></ul><p>选项意义与run命令的选项类似，如：</p><ul><li><code>docker exec -it mysql-test /bin/bash</code>：我们想进入容器，执行任何命令，就像平时使用linux那样，可同时指定<code>-it</code>选项。</li><li><code>docker exec -t mysql-test ls /</code>：我们想查看某一目录下的文件信息，可以仅指定<code>-t</code>选项来进行回显，执行完毕后就退出了容器。</li><li><code>docker exec -i mysql-test /bin/bash</code>：当使用<code>-i</code>选项执行<code>/bin/bash</code>时，由于标准输入打开，我们可以输入其它命令，但是此时是没有回显的。正常情况下只能用Ctr+C结束与之的交互，此时容器内由”/bin/bash”命令创建的进程不会被结束。</li><li><code>docker exec mysql-test ls</code>：不带option，有回显，命令执行完毕后，docker发现没有前台进程，退出容器。</li></ul><p>单独使用<code>-i</code>的场景不多，更多使用的是<code>-t</code>和<code>-it</code>。笔者这里对这几个选项的描述可能并不是特别准确，心里明白但无法用文字完美诠释，读者还是自己实操理解会好些。</p><h3 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h3><ul><li>docker attach方式进入容器：按下Ctrl+P+Q退出，如果使用exit退出终端或Ctrl+c方式结束当前前台进程，会导致容器停止！如果使用<code>docker attach --sig-proxy=false &lt;容器id或容器名&gt;</code>进入容器，则可以使用Ctrl+c方式退出</li><li>docker exec方式进入容器：按下Ctrl+P+Q退出，或以exit命令退出当前终端以退出容器。</li></ul><p>两种进入容器的方式使用Ctrl+P+Q退出时，容器不会停止，因为此种方式会保留进入容器时的执行该命令的进程，容器不会退出，如果一个容器已经后台运行，我们以<code>docker exec -it</code>进入容器时，最好以exit命令退出，容器不会保留终端进程。如果是以docker attach方式进入，此时我们来到了容器守护的前台进程，一定要以Ctrl+P+Q方式退出，否则容器会停止。</p><h2 id="容器内外的文件传输"><a href="#容器内外的文件传输" class="headerlink" title="容器内外的文件传输"></a>容器内外的文件传输</h2><h3 id="docker-cp"><a href="#docker-cp" class="headerlink" title="docker cp"></a>docker cp</h3><p>作用：从容器内拷贝文件（文件夹也是文件）到宿主机上</p><p>常见命令格式：<code>docker cp [option] &lt;srcPath&gt; &lt;destPath&gt;</code></p><ul><li>option选项：-L，以保持源目标中的链接 </li><li>srcPath与destPath分两种情况：<ul><li>容器内拷贝文件到容器外：<code>docker cp &lt;容器id或容器名&gt;:&lt;容器内路径&gt; &lt;主机路径&gt;</code></li><li>容器外拷贝文件到容器内：<code>docker cp &lt;主机目的路径&gt; &lt;容器id或容器名&gt;:&lt;容器内路径&gt; </code>，容器内的路径不存在则创建，即重命名</li></ul></li></ul><h3 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h3><p><a href="../docker%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7">《Docker容器数据卷》篇</a></p><h2 id="容器内外的网络连通"><a href="#容器内外的网络连通" class="headerlink" title="容器内外的网络连通"></a>容器内外的网络连通</h2><h3 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h3><p>使用run命令时指定端口映射，前文提到过，见<code>docker run</code>命令的<code>-p</code>与<code>-P</code>选项。</p><h3 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h3><p><a href="../docker%E7%BD%91%E7%BB%9C/">《Docker网络》篇</a></p><h2 id="容器的日志"><a href="#容器的日志" class="headerlink" title="容器的日志"></a>容器的日志</h2><h3 id="docker-logs"><a href="#docker-logs" class="headerlink" title="docker logs"></a>docker logs</h3><p>作用：查看容器运行产生的日志</p><p>命令格式：<code>docker logs [oprion1][option2] &lt;容器id或容器名&gt; </code>，常用option：</p><ul><li><code>docker logs mysql-test</code> ：查看容器名为mysql-test的日志</li><li><code>docker logs -f mysql-test</code> ：查看且跟踪容器名为mysql-test的日志</li><li><code>docker logs -f mysql-test</code> ：查看且跟踪容器名为mysql-test的日志</li><li><code>docker logs -n=100 mysql-test</code> ：查看容器名为mysql-test的最后100行日志</li><li><code>docker logs --since=2021-02-01 mysql-test</code>：查看容器名为mysql-test自2021年2月1日以来的日志</li><li><code>docker logs --since=2021-02-01T00:00 mysql-test</code>：查看容器名为mysql-test自2021年2月1日00:00以来的日志</li><li><code>docker logs --since=2021-02-01T00:00:00 mysql-test</code>：查看容器名为mysql-test自2021年2月1日00:00:00以来的日志</li></ul><h2 id="查看镜像或容器元数据"><a href="#查看镜像或容器元数据" class="headerlink" title="查看镜像或容器元数据"></a>查看镜像或容器元数据</h2><p>镜像或容器元数据：镜像或容器的详细信息，镜像元数据包括镜像完整id、构建时间等，容器元数据包括数据卷、网络等信息。</p><h3 id="docker-inspect"><a href="#docker-inspect" class="headerlink" title="docker inspect"></a>docker inspect</h3><ul><li><p><code>docker inspect &lt;镜像名或镜像ID&gt;</code>（查看镜像元数据）</p><ul><li><code>docker inspect java</code>：查看java（latest版本）的镜像元数据</li><li><code>docker inspect java:7</code>：查看java7的镜像元数据</li></ul></li><li><p><code>docker inspect &lt;容器名或容器ID&gt;</code>（查看容器元数据）</p><ul><li><code>docker inspect mysql-test</code>：查看容器名为mysql-test的容器元数据</li></ul></li></ul><h2 id="Docker镜像原理"><a href="#Docker镜像原理" class="headerlink" title="Docker镜像原理"></a>Docker镜像原理</h2><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时库、环境变量和配置文件。</p><h3 id="镜像加载原理"><a href="#镜像加载原理" class="headerlink" title="镜像加载原理"></a>镜像加载原理</h3><h4 id="UnionFS（联合文件系统）"><a href="#UnionFS（联合文件系统）" class="headerlink" title="UnionFS（联合文件系统）"></a>UnionFS（联合文件系统）</h4><p>复制粘贴一下概念：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，他支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统是 Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p><p>UFS可以类比git的commit进行理解。</p><p>docker的镜像实际上由一层一层的联合文件系统组成。</p><p><img src="/WindShadow/Docker/docker%E5%9F%BA%E7%A1%80/dockerUFS.png"></p><p><strong>boots</strong>(boot file system）：主要包含 bootloader和 Kernel, bootloader主要是引导加 kernel, Linux刚启动时会加bootfs文件系统，在Docker镜像的最底层是 boots。这一层与我们典型的Linux/Unix系统是一样的，包含boot加載器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs转交给内核，此时系统也会卸载bootfs。<br><strong>rootfs</strong>（root file system)：在 bootfs之上。包含的就是典型 Linux系统中的/dev,/proc,/bin,/etc等标准目录和文件。 rootfs就是各种不同的操作系统发行版，比如 Ubuntu, Centos等等。</p><p>平时我们安装进虚拟机的CentOS都是好几个G，为什么Docker这里才200M？</p><p><img src="/WindShadow/Docker/docker%E5%9F%BA%E7%A1%80/docker-centos.png"></p><p>对于个精简的OS，rootfs可以很小，只需要包合最基本的命令，工具和程序库就可以了，因为底层直接用宿主机的kernel，自己只需要提供rootfs就可以了。由此可见对于不同的Linux发行版， boots基本是一致的，rootfs会有差別，因此不同的发行版可以公用bootfs。</p><h3 id="镜像的分层"><a href="#镜像的分层" class="headerlink" title="镜像的分层"></a>镜像的分层</h3><p>基于UFS的特点，大多数docker镜像都是由多层镜像“叠加”而来的，所有的 Docker镜像都起始于一个基础镜像层，当进行修改或培加新的内容时，就会在当前镜像层之上，创建新的镜像层，为什么Docker镜像要采用这种分层的结构呢？</p><p>最大的好处，莫过于资源共享了！比如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享。类似于面向对象多态的体现之一：类的继承。</p><h3 id="镜像与容器的联系"><a href="#镜像与容器的联系" class="headerlink" title="镜像与容器的联系"></a>镜像与容器的联系</h3><p>Docker 镜像都是只读的，当容器启动时，一个新的可写层加载到镜像的顶部，这一层就是我们通常说的容器层，容器之下的都叫镜像层。</p><p><img src="/WindShadow/Docker/docker%E5%9F%BA%E7%A1%80/container.jpg"></p><p>如果想要保存当前容器的状态，就可以通过<code>docker commit</code>来提交（此处不将commit命令），获得一个镜像，就好比我们我们使用虚拟机的快照。</p><hr><p><strong>本文参考B站UP主“狂神说Java”<a target="_blank" rel="noopener" href="https://space.bilibili.com/95256449/%E7%9A%84docker%E6%95%99%E5%AD%A6%E8%A7%86%E9%A2%91%E8%BF%9B%E8%A1%8C%E6%95%B4%E7%90%86%E3%80%82">https://space.bilibili.com/95256449/的docker教学视频进行整理。</a></strong></p><p><strong>感谢成长路上为在下传道受业解惑之人</strong></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>cookie session localStorage sessionStorage</title>
      <link href="WindShadow/web%E5%9F%BA%E7%A1%80%E6%89%AB%E7%9B%B2/cookie%20session%20localStorage%20sessionStorage/"/>
      <url>WindShadow/web%E5%9F%BA%E7%A1%80%E6%89%AB%E7%9B%B2/cookie%20session%20localStorage%20sessionStorage/</url>
      
        <content type="html"><![CDATA[<p><em>啰嗦的话不说，直接上干货，概念性的东西，什么产生背景啥的自己组织一下语言就好了</em></p><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>session是用来在客户端与服务器之间保持状态的一种解决方案（由于http的无状态），主要特点：</p><ul><li><p>数据保存在服务端，session存在过期时间</p></li><li><p>多数情况下session实现依赖cookie，通过cookie存放sessionId，也可通过URL编码的方式携带sessionId</p></li><li><p>session存放的数据的key不能为null（至少在java web中如此）</p></li><li><p>session存放的数据的value为null时视为删除操作（至少在java web中如此）</p><p>放源码，来自apache tomcat的session实现类<code>org.apache.catalina.session.StandardSession</code></p><p><img src="/WindShadow/web%E5%9F%BA%E7%A1%80%E6%89%AB%E7%9B%B2/cookie%20session%20localStorage%20sessionStorage/session.png"></p></li></ul><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>cookie大小限制，最多4K。</p><p>cookie主要5大属性：</p><ul><li>name：名称</li><li>value：值</li><li>domain：作用域，默认情况下，cookie的domain是设置该cookie的web服务器的域名，如domain域为<code>.ccc.com</code>的cookie可以被<code>www.aaa.ccc.com</code>和<code>www.bbb.ccc.com</code>的网站所读取，不能将一个cookie的域设置成服务器所在的域之外的域 ；cookie的domain属性不与端口相关，即同IP不同端口的web服务有机会获取到对方的cookie（path值匹配的话）</li><li>path：路径值；服务器后端获取cookie的规则：设当前URI为：/a/b，cookie路径为path，服务器后端能获取到的cookie满足：<code>path.startsWith(URI) || URI.startsWith(path)</code></li><li>expires/max-age：过期时间/最大“年龄”；根据过期时间 max-age 有3种情况：<ul><li>max-age &gt; 0；cookie到期销毁，此时cookie存于磁盘</li><li>max-age = 0；cookie已经过期，此时cookie销毁</li><li>max-age &lt; 0；cookie在关闭浏览器后销毁，此时cookie存于内存</li></ul></li></ul><p>另外还有两个属性值得关注：</p><ul><li><p>secure：取值范围 true | false，是否仅支持https传输</p></li><li><p>SameSite：Chrome 51 开始，浏览器的 Cookie 新增加了一个SameSite属性，限制第三方 Cookie，用来防止 CSRF 攻击和用户追踪，该属性不在服务端体现（至少目前java web是这样）。取值范围：</p><ul><li><p>Strict：完全禁止第三方 Cookie，任何跨域请求浏览器都不会发送cookie</p></li><li><p>Lax：次于Strict的限制级别，任何跨域大多数情况浏览器不会发送cookie，如下表</p><table><thead><tr><th>请求类型</th><th>示例</th><th>Lax</th></tr></thead><tbody><tr><td>链接</td><td>&lt;a href=”…”&gt;&lt;/a&gt;</td><td>发送 Cookie</td></tr><tr><td>预加载</td><td>&lt;link rel=”prerender” href=”…”/&gt;</td><td>发送 Cookie</td></tr><tr><td>GET 表单</td><td>&lt;form method=”GET” action=”…”&gt;</td><td>发送 Cookie</td></tr><tr><td>POST 表单</td><td>&lt;form method=”POST” action=”…”&gt;</td><td>不发送</td></tr><tr><td>iframe</td><td>&lt;iframe src=”…”&gt;&lt;/iframe&gt;</td><td>不发送</td></tr><tr><td>ajax</td><td>$.get(“…”)</td><td>不发送</td></tr><tr><td>Image</td><td>&lt;img src=”…”&gt;</td><td>不发送</td></tr></tbody></table></li></ul></li></ul><ul><li>None：不禁止第三方 Cookie，跨域请求浏览器都会发送cookie，当secure为true时，该值才有效（此条知识点以Chrome浏览器80版本之后为前提）</li></ul><h3 id="后端读写cookie"><a href="#后端读写cookie" class="headerlink" title="后端读写cookie"></a>后端读写cookie</h3><p>后端读取cookie的特点：</p><ul><li>后端通过request对象获取cookie：<code>Cookie[] cookies = request.getCookies()</code>，值得注意的是获取到的cookie数量为0时，该方法返回的是null而不是空数组。</li></ul><p>设当前访问的地址URI为 <code>/xxx/yyy</code>，写入规则如下：</p><table><thead><tr><th>属性</th><th>后端写cookie的值</th><th>描述</th><th>浏览器实际存储的值</th><th>含义</th></tr></thead><tbody><tr><td>name</td><td>“abc”</td><td></td><td>“abc”</td><td></td></tr><tr><td>name</td><td>null</td><td>null引用</td><td></td><td>后端抛IllegalArgumentException异常</td></tr><tr><td>name</td><td>“”或” “</td><td>空白字符串</td><td></td><td>后端抛IllegalArgumentException异常</td></tr><tr><td>name</td><td>“  abc”或“abc ”</td><td>空白字符开头或结尾的字符串</td><td></td><td>后端抛IllegalArgumentException异常</td></tr><tr><td>value</td><td>null</td><td>null引用</td><td>“”</td><td></td></tr><tr><td>value</td><td>“”</td><td>长度为0的字符串</td><td>“”</td><td></td></tr><tr><td>value</td><td>“ “</td><td>空白字符串</td><td></td><td>后端抛IllegalArgumentException异常</td></tr><tr><td>path</td><td>/xxx</td><td>当前路径的或子路径</td><td>/xxx</td><td></td></tr><tr><td>path</td><td>/</td><td>/ 代表根</td><td>${contextPath}</td><td>web容器上下文</td></tr><tr><td>path</td><td>null</td><td>null引用</td><td>${contextPath}</td><td>web容器上下文</td></tr><tr><td>path</td><td>“”或” “</td><td>长度为0或空白字符串</td><td>${contextPath}</td><td>web容器上下文</td></tr><tr><td>path</td><td>xyz</td><td>不以斜杠开头的字符串</td><td>${contextPath}</td><td>web容器上下文</td></tr><tr><td>path</td><td>/zzz</td><td>其它路径</td><td>/zzz</td><td></td></tr><tr><td>expires/max-age</td><td>age &gt; 0</td><td>过期时间大于0秒</td><td>age * 1000ms</td><td>cookie到期销毁</td></tr><tr><td>expires/max-age</td><td>age = 0</td><td>过期时间等于0秒</td><td>0ms</td><td>cookie已经过期，销毁</td></tr><tr><td>expires/max-age</td><td>age &lt; 0</td><td>过期时间小于0秒</td><td>N/A(Session)</td><td>关闭浏览器时cookie销毁</td></tr></tbody></table><ul><li><strong>当${contextPath}web容器上下文为空时，则写入浏览器的path为 /。</strong></li></ul><h3 id="前端读写cookie"><a href="#前端读写cookie" class="headerlink" title="前端读写cookie"></a>前端读写cookie</h3><p>代码可封装如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name,value,age,path</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> expiresString = <span class="string">&quot;Session&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Number</span>.isInteger(age)) &#123;</span><br><span class="line">        <span class="comment">// age 小于0则视为Session会话级别的cookie</span></span><br><span class="line">        <span class="keyword">if</span> (age &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> expires = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">            expires.setTime(expires.getTime() + age * <span class="number">1000</span>);</span><br><span class="line">            expiresString = expires.toGMTString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.cookie= name + <span class="string">&quot;=&quot;</span> + value + <span class="string">&quot;; expires=&quot;</span> + expiresString + <span class="string">&quot;;path=&quot;</span> + path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前浏览器地址为 <code>/xxx/yyy</code></p><table><thead><tr><th>属性</th><th>前端写cookie的值</th><th>浏览器实际存储的值</th><th>后端接受到的值</th><th>含义</th></tr></thead><tbody><tr><td>name</td><td>“abc”</td><td>“abc”</td><td>“abc”</td><td></td></tr><tr><td>name</td><td>“”或” “</td><td>“”</td><td>${value}</td><td>name无效，后端取出的name反而为其value值</td></tr><tr><td>name</td><td>“  abc”</td><td>“abc”</td><td>“abc”</td><td>前端存cookie会处理name的首尾空白字符</td></tr><tr><td>name</td><td>null</td><td>“null”</td><td>“null”</td><td>null类型转换为”null”字符串</td></tr><tr><td>name</td><td>undefined</td><td>“undefined”</td><td>“undefined”</td><td>undefined类型转换为”undefined”字符串</td></tr><tr><td>value</td><td>“abc”</td><td>“abc”</td><td>“abc”</td><td></td></tr><tr><td>value</td><td>“”</td><td>“”</td><td>“”</td><td></td></tr><tr><td>value</td><td>“ “</td><td>“”</td><td>“”</td><td>前端存cookie会处理value的首尾空白字符</td></tr><tr><td>value</td><td>null</td><td>“null”</td><td>“null”</td><td>null类型转换为”null”字符串</td></tr><tr><td>value</td><td>undefined</td><td>“undefined”</td><td>“undefined”</td><td>undefined类型转换为”undefined”字符串</td></tr><tr><td>path</td><td>/xxx</td><td>/xxx</td><td>null（后端不感知path值）</td><td></td></tr><tr><td>path</td><td>/zzz</td><td>/zzz</td><td>null（后端不感知path值）</td><td>其它路径</td></tr><tr><td>path</td><td>/</td><td>/</td><td>null（后端不感知path值）</td><td>/ 根</td></tr><tr><td>path</td><td>xyz</td><td>/xxx</td><td>null（后端不感知path值）</td><td>当前路径的前一级路径，若不存在则为 /</td></tr><tr><td>path</td><td>undefined</td><td>/xxx</td><td>null（后端不感知path值）</td><td>当前路径的前一级路径，若不存在则为 /</td></tr><tr><td>path</td><td>null</td><td>/xxx</td><td>null（后端不感知path值）</td><td>当前路径的前一级路径，若不存在则为 /</td></tr><tr><td>path</td><td>“”</td><td>/xxx</td><td>null（后端不感知path值）</td><td>当前路径的前一级路径，若不存在则为 /</td></tr><tr><td>path</td><td>“ “</td><td>/xxx</td><td>null（后端不感知path值）</td><td>当前路径的前一级路径，若不存在则为 /</td></tr><tr><td>expires</td><td>“Session”</td><td>N/A(Session)</td><td>-1（后端不感知过期时间）</td><td>关闭浏览器时cookie销毁（存于内存）</td></tr><tr><td>expires</td><td>t &gt; 0</td><td>过期时间大于0秒</td><td>-1（后端不感知过期时间）</td><td>cookie到期销毁（存于磁盘）</td></tr><tr><td>expires</td><td>t &lt; 0</td><td>过期时间小于0秒</td><td>-1（后端不感知过期时间）</td><td>cookie已经过期，销毁</td></tr></tbody></table><ul><li>前端js代码写cookie时，过对<code>document.cookie</code>赋值进行设置cookie</li><li>设置的属性基本都有默认值，如果设置的值是“无理”的，属性都会取默认值，path属性默认为当前路径的前一级路径，expires属性默认为”Session”。</li><li>设置的name和value属性会进行一定优化，需要主要后端取到实际值的不同</li></ul><h2 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h2><p>localStorage属性在HTML5时增加，允许在浏览器中存储 key/value 对的数据，特点：</p><ul><li>只支持string类型的存储，key和value哪怕set时是number类型也会转成string类型</li><li>遵循同源策略</li><li>永久存在浏览器中，除非手动删除</li><li>一般浏览器支持的是5M大小，不同的浏览器中会有所不同 </li><li>浏览器发送请求时不会带上</li></ul><h2 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h2><p>sessionStorage属性在HTML5时增加，允许在浏览器中存储 key/value 对的数据，特点：</p><ul><li>只支持string类型的存储，key和value哪怕set时是number类型也会转成string类型</li><li>数据仅在当前浏览器窗口有效</li><li>一般浏览器支持的是5M大小，不同的浏览器中会有所不同 </li><li>浏览器发送请求时不会带上</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><table><thead><tr><th></th><th>数据存放位置</th><th>非手动情况下数据销毁时机</th></tr></thead><tbody><tr><td>session</td><td>服务端（依赖cookie存放sessionId）</td><td>session过期</td></tr><tr><td>cookie</td><td>浏览器</td><td>到达过期时间</td></tr><tr><td>localStorage</td><td>浏览器</td><td>必须手动删除</td></tr><tr><td>sessionStorage</td><td>浏览器</td><td>浏览器窗口关闭</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> web基础扫盲 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nginx使用ssl</title>
      <link href="WindShadow/Nginx/Nginx%E4%BD%BF%E7%94%A8ssl/"/>
      <url>WindShadow/Nginx/Nginx%E4%BD%BF%E7%94%A8ssl/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx使用ssl"><a href="#Nginx使用ssl" class="headerlink" title="Nginx使用ssl"></a>Nginx使用ssl</h1><p>nginx往往通过反向代理屏蔽服务端，nginx使用ssl的可以让客户端使用https协议与nginx通信，在一定程度上保证整个链路的数据安全。</p><h2 id="nginx配置ssl"><a href="#nginx配置ssl" class="headerlink" title="nginx配置ssl"></a>nginx配置ssl</h2><p>证书与私钥配置相对路径起点为位置为nginx安装目录，假设nginx安装目录下存在ssl文件夹</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">443</span>; </span><br><span class="line">    <span class="attribute">server_name</span>  ip;<span class="comment"># ip 或域名</span></span><br><span class="line">    <span class="attribute">ssl_certificate</span>      ssl/ws-ssl-server.crt;<span class="comment"># 证书位置</span></span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>  ssl/ws-ssl-server.key;<span class="comment"># 证书私钥</span></span><br><span class="line">    <span class="attribute">ssl</span> <span class="literal">on</span>;<span class="comment"># 开启ssl</span></span><br><span class="line">    <span class="comment"># 其它配置 ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般我们还会配置http请求的80端口重定向到443端口</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  ip;<span class="comment"># ip 或域名</span></span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/(.*)$</span> https://ip:443/<span class="variable">$1</span> <span class="literal">permanent</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此配置方式为https的单向认证，一般自签证书使用这种方式较多</p><h2 id="证书生成"><a href="#证书生成" class="headerlink" title="证书生成"></a>证书生成</h2><p>在javaweb中使用jks比较多，这里介绍使用keytool生成的jks密钥库应用到nginx的方法，需要结合openssl使用。一个大坑：尽量不要使用windows下git（git bash）自带的openssl，如果执行openssl的命令需要交互式的输入数据（如密钥库口令）时，git bash窗口直接卡住，没有提示也输入不了。</p><p>使用假设有ws-ssl-server.jks密钥库存在。</p><ol><li><p>jks密钥库转换成挣p12类型密钥库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -importkeystore -srckeystore ws-ssl-server.jks -srcstoretype jks -destkeystore ws-ssl-server.p12 -deststoretype pkcs12</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -importkeystore -alias ws-ssl-server -srckeystore ws-ssl-server.jks -srcstoretype jks -srcstorepass srcstorepassxxx -destkeystore ws-ssl-server.p12 -deststoretype pkcs12 -deststorepass deststorepassxxx -destkeypass destkeypassxxx</span><br></pre></td></tr></table></figure></li><li><p>使用openss将p12密钥库提取出crt证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -nokeys -clcerts -in ws-ssl-server.p12  -out ws-ssl-server.crt</span><br></pre></td></tr></table></figure></li><li><p>提取私钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -nocerts -nodes -in ws-ssl-server.p12 -out ws-ssl-server.key</span><br></pre></td></tr></table></figure></li><li><p>如前文一样，在nginx配置文件中配置ssl证书，<code>nginx -s reload</code> 重新加载即可</p></li></ol><h2 id="双向认证"><a href="#双向认证" class="headerlink" title="双向认证"></a>双向认证</h2><p>前文介绍的是nginx使用ssl完成https单向认证的操作，此章节介绍双向认证。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">443</span>; </span><br><span class="line">    <span class="attribute">server_name</span>  ip;<span class="comment"># ip 或域名</span></span><br><span class="line">    <span class="attribute">ssl_certificate</span>      ssl/ws-ssl-server.crt;<span class="comment"># 证书位置</span></span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>  ssl/ws-ssl-server.key;<span class="comment"># 证书私钥</span></span><br><span class="line">    <span class="attribute">ssl</span> <span class="literal">on</span>;<span class="comment"># 开启ssl</span></span><br><span class="line">    <span class="attribute">ssl_client_certificate</span> ssl/ws-ssl-client.cer;  <span class="comment">#客户端证书</span></span><br><span class="line">    <span class="attribute">ssl_verify_client</span> <span class="literal">on</span>; <span class="comment"># 开启客户端证书验证</span></span><br><span class="line">    <span class="comment"># 其它配置 ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ssl常用指令"><a href="#ssl常用指令" class="headerlink" title="ssl常用指令"></a>ssl常用指令</h2><ul><li><p>ssl on | off;</p><p>为指定的虚拟主机配置是否启用ssl功能，此功能在1.15.0废弃，使用listen [ssl]替代。</p></li><li><p>ssl_certificate server.crt; </p><p>当前虚拟主机使用使用的证书文件，一般是crt文件</p></li><li><p>ssl_certificate_key server.key;</p><p>当前虚拟主机使用的私钥文件，一般是key文件</p></li><li><p>ssl_client_certificate ssl client.cer;</p><p>客户端证书</p></li><li><p>ssl_verify_client on;</p><p>开启客户端证书验证</p></li><li><p>ssl_protocols [SSLv2][SSLv3][TLSv1][TLSv1.1][TLSv1.2]</p><p>支持ssl协议版本，早期为ssl现在是TSL，默认为后三个</p></li><li><p>ssl_session_cache off | none | [builtin[:size]][shared:name:size];</p><p>配置ssl缓存：off：关闭缓存；none: 通知客户端支持ssl session cache，但实际不支持；</p><p>builtin[:size]：使用OpenSSL内建缓存，为每worker进程私有</p><p>[shared:name:size]：在各worker之间使用一个共享的缓存，需要定义一个缓存名称和缓存空间大小，一兆可以存储4000个会话信息，多个虚拟主机可以使用相同的缓存名称。</p></li><li><p>ssl_session_timeout time;</p><p>客户端连接可以复用ssl session cache中缓存的有效时长，默认5m（分钟）</p></li></ul><p>关于证书格式：其实证书格式之间的差异几乎也就编码问题，后缀也并不能完全代表什么，每个软件支持的格式可能不一样，如tomcat和nginx的差异，能用就行，不能就转换格式。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring框架基础能力-数据转换</title>
      <link href="WindShadow/Spring/Spring%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80%E8%83%BD%E5%8A%9B-%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/"/>
      <url>WindShadow/Spring/Spring%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80%E8%83%BD%E5%8A%9B-%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring的数据转换器"><a href="#Spring的数据转换器" class="headerlink" title="Spring的数据转换器"></a>Spring的数据转换器</h2><p>众所周知，在书写Spring的配置文件或者前端请求后端时，我们所有配置项的值或参数值都是字符串的形式存在（上传文件的IO流也类似），根据一定的书写规则，Spring可以将这些原本为string类型的值赋值到对应的bean上或SpringMVC控制层的方法的实参上，这得益于Spring中强大的数据转换能力，下面盘点一波“Spring的数据转换器”。</p><p>Spring中的数据转换器主要分两大派系：</p><ul><li><p>PropertyEditor（属性编辑器）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.beans;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PropertyEditor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Object value)</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isPaintable</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">paintValue</span><span class="params">(java.awt.Graphics gfx, java.awt.Rectangle box)</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getJavaInitializationString</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getAsText</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAsText</span><span class="params">(String text)</span> <span class="keyword">throws</span> java.lang.IllegalArgumentException</span>;</span><br><span class="line">    String[] getTags();</span><br><span class="line">    java.awt.<span class="function">Component <span class="title">getCustomEditor</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supportsCustomEditor</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addPropertyChangeListener</span><span class="params">(PropertyChangeListener listener)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removePropertyChangeListener</span><span class="params">(PropertyChangeListener listener)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PropertyEditor</code>是JavaBean规范定义的接口，这是java.beans中一个接口，其设计方便对象与String之间的转换工作，而spring将其扩展，方便各种对象与String之间的转换工作。Spring所有的扩展都是通过继承<code>PropertyEditorSupport</code>，因为它只聚焦于转换上，所以只需复写setAsText()、getAsText()以及构造方法即可实现扩展。</p><p>Spring 使用PropertyEditor的接口来实现对象和字符串之间的转换，比如将 2020-01-01转化为日期类型等，可以通过注册自定义编辑器来实现此功能。</p><p>应用场景：</p><ul><li>在基于xml的配置中，我们往往通过字面值为Bean各种类型的属性提供设置值：如double、int类型，在配置文件配置字面值即可。Spring填充Bean属性时如何将这个字面值转换为对应的类型呢？我们可以隐约地感觉到一定有一个转换器在其中起作用，这个转换器就是属性编辑器。</li><li>再者便是Spring MVC框架使用多种PropertyEditor分析绑定HTTP请求的各种参数</li></ul></li><li><p>Converter（转换器）</p><p>Spring的<code>Converter</code>可以将一种类型转换成另一种类型的一个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">S</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// 把S转成T</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">T <span class="title">convert</span><span class="params">(S source)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring提供了3种converter接口：</p><ul><li><p><code>Converter</code>接口 ：使用最简单，最不灵活，1:1</p></li><li><p><code>ConverterFactory</code>接口 ：使用较复杂，比较灵活 1:N</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConverterFactory</span>&lt;<span class="title">S</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">&lt;T extends R&gt; <span class="function">Converter&lt;S, T&gt; <span class="title">getConverter</span><span class="params">(Class&lt;T&gt; targetType)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>GenericConverter</code>接口 ：使用最复杂，也最灵活 N:N</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericConverter</span> </span>&#123;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Set&lt;ConvertiblePair&gt; <span class="title">getConvertibleTypes</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Object <span class="title">convert</span><span class="params">(<span class="meta">@Nullable</span> Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConvertiblePair</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>既然有了PropertyEditor，那为何还需要有Converter呢？因为Java原生的PropertyEditor存在以下两点不足：</p><ol><li>只能用于字符串和Java对象的转换，不适用于任意两个Java类型之间的转换；</li><li>对源对象及目标对象所在的上下文信息（如注解、所在宿主类的结构等）不敏感，在类型转换时不能利用这些上下文信息实施高级转换逻辑。</li></ol><p>鉴于此，Spring 3.0在核心模型中添加了一个通用的类型转换模块。Spring希望用这个类型转换体系替换Java标准的PropertyEditor。但由于历史原因，Spring将同时支持两者。在Bean配置、Spring MVC处理方法入参绑定中使用它们。</p><p>**注：如今SpringBoot是开发首先，本文所列罗的源码均来自于SpringBoot 2.3.7.RELEASE **</p><h2 id="PropertyEditor属性编辑器"><a href="#PropertyEditor属性编辑器" class="headerlink" title="PropertyEditor属性编辑器"></a>PropertyEditor属性编辑器</h2><h3 id="PropertyEditor在Bean配置上的使用"><a href="#PropertyEditor在Bean配置上的使用" class="headerlink" title="PropertyEditor在Bean配置上的使用"></a>PropertyEditor在Bean配置上的使用</h3><p>以字符串转换为自定义对象为需求；</p><p>定义一个<code>Student</code>实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Max(100)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个Student的属性编辑器，继承<code>PropertyEditorSupport</code>以实现<code>PropertyEditor</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 把“(1001,张三)” 转换成 &#123;<span class="doctag">@link</span> Student&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentEditor</span> <span class="keyword">extends</span> <span class="title">PropertyEditorSupport</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text 这里进来的字符串不会是空的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsText</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="comment">// 解析字符串过程...</span></span><br><span class="line">        <span class="keyword">this</span>.setValue(<span class="keyword">new</span> Student(<span class="number">1001</span>,<span class="string">&quot;张三&quot;</span>)); <span class="comment">// 关键的setValue方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入一个属性编辑器的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyEditorConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class&lt;?&gt;, Class&lt;? extends PropertyEditor&gt;&gt; customEditors;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     *     注册属性编辑器，使IOC创建bean时拥有string类型转为目标类型的能力</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     *     注意SpringMVC进行参数绑定时是无法利用此能力的，这是&#123;<span class="doctag">@link</span> org.springframework.beans.factory.BeanFactory&#125;的能力，SpringMVC上使用需要额外注册</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> CustomEditorConfigurer&#125;实现了&#123;<span class="doctag">@link</span> org.springframework.beans.factory.config.BeanFactoryPostProcessor&#125;接口，设置为静态方法以提高优先级</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> CustomEditorConfigurer&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ws.spring.convert.controller.CustomControllerAdvice#initBinder(WebDataBinder) SpringMVC在参数绑定期间注册属性编辑器实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CustomEditorConfigurer <span class="title">customEditorConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        CustomEditorConfigurer configurer = <span class="keyword">new</span> CustomEditorConfigurer();</span><br><span class="line">        configurer.setCustomEditors(getPropertyEditors());</span><br><span class="line">        <span class="keyword">return</span> configurer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存全部的属性编辑器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Class&lt;?&gt;, Class&lt;? extends PropertyEditor&gt;&gt; getPropertyEditors() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (customEditors == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">synchronized</span> (PropertyEditorConfig.class) &#123;</span><br><span class="line">               <span class="keyword">if</span> (customEditors == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                   customEditors = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">4</span>/<span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">                   customEditors.put(Student.class, StudentEditor.class);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> customEditors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义bean组件需要注入Student类的属性，支持校验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;custom.bean&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Student student;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">custom:</span></span><br><span class="line"> <span class="attr">bean:</span></span><br><span class="line">   <span class="attr">student:</span> <span class="string">(81,张三)</span></span><br></pre></td></tr></table></figure><p><strong>疑点</strong>：Spring如何使用到了我们注册的PropertyEditor？</p><p>因为<code>CustomEditorConfigurer</code>实现了<code>BeanFactoryPostProcessor</code>接口，往beanFactory注册了我们的PropertyEditor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory.config;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomEditorConfigurer</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.propertyEditorRegistrars != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (PropertyEditorRegistrar propertyEditorRegistrar : <span class="keyword">this</span>.propertyEditorRegistrars) &#123;</span><br><span class="line">beanFactory.addPropertyEditorRegistrar(propertyEditorRegistrar);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.customEditors != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.customEditors.forEach(beanFactory::registerCustomEditor); <span class="comment">// 注册 PropertyEditor</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PropertyEditor在MVC参数绑定上的使用"><a href="#PropertyEditor在MVC参数绑定上的使用" class="headerlink" title="PropertyEditor在MVC参数绑定上的使用"></a>PropertyEditor在MVC参数绑定上的使用</h3><p>首先要清楚一个概念，MVC的参数绑定看起来很像bean配置过程，基本也是从字符串到java对象的转换，但是前者是MVC模块的功能，后者是beanFactory的能力，MVC只是Spring体系中的一员，IOC中beanFactory才是整个Spring体系的核心。所以数据转换这样的基础功能，MVC的参数绑定是不能使用beanFactory的转换能力的，因为<strong>参数绑定过程不是bean的创建过程，创建的对象不是SpringBean</strong>。所以数据转换的功能在MVC模块是需要注册进去才有的，即一次编写，多处注册。</p><p>先定义一个控制层的增强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestControllerAdvice(assignableTypes = &#123;PropertyEditorController.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomControllerAdvice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@InitBinder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBinder</span><span class="params">(WebDataBinder binder)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 注册属性编辑器</span></span><br><span class="line">        registerCustomEditor(binder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerCustomEditor</span><span class="params">(WebDataBinder binder)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        此种绑定方式看似很好，先找到对应的属性编辑器，再进行注册，但是此时 target 为 null，不知道 target的类型，也就无法“对症下药”</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        Object target = binder.getTarget();</span></span><br><span class="line"><span class="comment">        if (target == null) &#123;</span></span><br><span class="line"><span class="comment">            return;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        // 注册对应的属性编辑器到当前的绑定器，如果存在的话</span></span><br><span class="line"><span class="comment">        Class&lt;?&gt; entityClass = target.getClass();</span></span><br><span class="line"><span class="comment">        Class&lt;? extends PropertyEditor&gt; entityPropertyEditorClass = PropertyEditorConfig.getPropertyEditors().get(entityClass);</span></span><br><span class="line"><span class="comment">        if (entityPropertyEditorClass != null) &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            registerCustomEditor(binder,entityClass,entityPropertyEditorClass);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="comment">// 注册全部的属性编辑器到当前的绑定器（比较退而求其次的做法）</span></span><br><span class="line">        PropertyEditorConfig.getPropertyEditors()</span><br><span class="line">            .forEach((entityClass,entityPropertyEditorClass) -&gt; registerCustomEditor(binder,entityClass,entityPropertyEditorClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerCustomEditor</span><span class="params">(WebDataBinder binder,Class&lt;?&gt; entityClass, Class&lt;? extends PropertyEditor&gt; entityPropertyEditorClass)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor&lt;? extends PropertyEditor&gt; constructor = entityPropertyEditorClass.getConstructor();</span><br><span class="line">            PropertyEditor editor = constructor.newInstance();</span><br><span class="line">            binder.registerCustomEditor(entityClass,editor);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ReflectiveOperationException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;属性编辑器&lt;&#123;&#125;&gt;没有无参构造方法&quot;</span>,entityPropertyEditorClass.getTypeName(),e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义控制层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyEditorController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get请求string参数转&#123;<span class="doctag">@link</span> Student&#125;，使用&#123;<span class="doctag">@link</span> RequestParam&#125;指定参数名</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;但是无法进行数据校验</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> student Get请求的String参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/property-editor-assign&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">stringToStudentAssign</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@RequestParam(&quot;student&quot;)</span> Student student)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;student: &#123;&#125;&quot;</span>,student);</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get请求string参数转&#123;<span class="doctag">@link</span> Student&#125;，不指定参数名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> student Get请求的String参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> 无法从Get请求的String参数映射</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/property-editor-non-assign&quot;)</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">stringToStudentNonAssign</span><span class="params">(<span class="meta">@Validated</span> Student student)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;student: &#123;&#125;&quot;</span>,student);</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(student);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>PropertyEditor是线程不安全的，一个实例对应一次String转换操作，而且在IOC启动时的bean配置和MVC参数绑定功能上需要各自注册，且MVC参数绑定增强时不能获取参数类型进行按需注册，退而求其次的做法是全部注册可能的PropertyEditor。</p><h2 id="Converter转换器"><a href="#Converter转换器" class="headerlink" title="Converter转换器"></a>Converter转换器</h2><h3 id="Converter在Bean配置上的使用"><a href="#Converter在Bean配置上的使用" class="headerlink" title="Converter在Bean配置上的使用"></a>Converter在Bean配置上的使用</h3><p>在此之前我们需要了解一个新的接口<code>ConversionService</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConversionService</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(<span class="meta">@Nullable</span> Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(<span class="meta">@Nullable</span> TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">convert</span><span class="params">(<span class="meta">@Nullable</span> Object source, Class&lt;T&gt; targetType)</span></span>;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Object <span class="title">convert</span><span class="params">(<span class="meta">@Nullable</span> Object source, <span class="meta">@Nullable</span> TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顾名思义就是Converter的服务，这个接口通过管理<code>Converter</code>、<code>ConverterFactory</code>、<code>GenericConverter</code>统一对外提供转换服务，所以Spring的的Bean转换操作使用的是ConversionService，贴上<code>ConfigurableBeanFactory</code>的接口声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory.config;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigurableBeanFactory</span> <span class="keyword">extends</span> <span class="title">HierarchicalBeanFactory</span>, <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Specify a Spring 3.0 ConversionService to use for converting</span></span><br><span class="line"><span class="comment"> * property values, as an alternative to JavaBeans PropertyEditors.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setConversionService</span><span class="params">(<span class="meta">@Nullable</span> ConversionService conversionService)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看使用Converter如何实现以字符串转换为自定义对象的需求；</p><p>定义实体类Town</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Town</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Max(100)</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义转换器且加入IOC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TownConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Town</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 &quot;100-南京&quot; 转换成&#123;<span class="doctag">@link</span> Town&#125;对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Town <span class="title">convert</span><span class="params">(String source)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line"><span class="comment">// 解析字符串过程...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Town(<span class="number">100</span>,<span class="string">&quot;南京&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>往IOC中注入配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConverterConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * bean名称必须叫 &quot;conversionService&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConversionServiceFactoryBean <span class="title">conversionService</span><span class="params">(<span class="meta">@Autowired</span> TownConverter townConverter)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ConversionServiceFactoryBean conversionService = <span class="keyword">new</span> ConversionServiceFactoryBean();</span><br><span class="line">        Set&lt;Converter&gt; converters = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        converters.add(townConverter);</span><br><span class="line">        <span class="comment">// add other</span></span><br><span class="line">        conversionService.setConverters(converters);</span><br><span class="line">        <span class="keyword">return</span> conversionService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConversionServiceFactoryBean</code>类是一个工厂bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context.support;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConversionServiceFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">ConversionService</span>&gt;, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义bean组件需要注入Town类的属性，支持校验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;custom.bean&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="keyword">private</span> Town town;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">custom:</span></span><br><span class="line"> <span class="attr">bean:</span></span><br><span class="line">   <span class="attr">town:</span> <span class="number">100</span><span class="string">-南京</span></span><br></pre></td></tr></table></figure><p><strong>疑点</strong>：为什么我们注册一个到名为”conversionService”类型为<code>ConversionService</code>的bean，Spring IOC容器在bean配置时就可以使用这个conversionService来完成属性的数据转换呢？</p><p>答案在<code>ConfigurableApplicationContext</code>和<code>AbstractApplicationContext</code>的源码里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigurableApplicationContext</span> <span class="keyword">extends</span> <span class="title">ApplicationContext</span>, <span class="title">Lifecycle</span>, <span class="title">Closeable</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Name of the ConversionService bean in the factory.</span></span><br><span class="line"><span class="comment"> * If none is supplied, default conversion rules apply.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.core.convert.ConversionService</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String CONVERSION_SERVICE_BEAN_NAME = <span class="string">&quot;conversionService&quot;</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context.support;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title">DefaultResourceLoader</span> <span class="keyword">implements</span> <span class="title">ConfigurableApplicationContext</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">beanFactory.setConversionService(</span><br><span class="line">beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractApplicationContext在完成beanFactory的初始化工作时，会从beanFactory中获取名为”conversionService”类型为<code>ConversionService</code>的bean，将其作为后续beanFactory的转换服务。</p><h3 id="Converter在MVC参数绑定上的使用"><a href="#Converter在MVC参数绑定上的使用" class="headerlink" title="Converter在MVC参数绑定上的使用"></a>Converter在MVC参数绑定上的使用</h3><p>前面我们已经把<code>TownConverter</code>加入IOC中了，在Controller上我们可以直接享受其转换能力。</p><p>定义控制层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConvertController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get请求string参数转&#123;<span class="doctag">@link</span> Town&#125;，使用&#123;<span class="doctag">@link</span> RequestParam&#125;指定参数名</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;/converter/assign?town=1001-风雷镇</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;但是无法进行数据校验，见&#123;<span class="doctag">@link</span> CustomControllerAdvice#initBinder(WebDataBinder)&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> town Get请求的String参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ws.spring.convert.converter.TownConverter 加入IOC之后控制层直接可以进行String到&#123;<span class="doctag">@link</span> Town&#125;的转换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/converter/assign&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">stringToTown</span><span class="params">(<span class="meta">@RequestParam(&quot;town&quot;)</span> <span class="meta">@Validated</span> Town town)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;town: &#123;&#125;&quot;</span>,town);</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(town);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get请求string参数转&#123;<span class="doctag">@link</span> Town&#125;，不指定参数名</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;/converter/non-assign?town=1001-风雷镇</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;可以进行数据校验</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> town Get请求的String参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/converter/non-assign&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">stringToTown2</span><span class="params">(<span class="meta">@Validated</span> Town town)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;town: &#123;&#125;&quot;</span>,town);</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(town);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>疑点</strong>：为什么MVC的参数绑定可以直接使用我们加入到IOC的Converter bean的能力而不需要像PropertyEditor那样额外注册呢？</p><p>解答：</p><p>首先我们知道<code>WebMvcConfigurer</code>接口是MVC模块的配置接口，其中有一个addFormatters方法，我们可以通过FormatterRegistry注册器注册我们的Formatter（见下文）、Converter等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.servlet.config.annotation;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">addFormatters</span><span class="params">(FormatterRegistry registry)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FormatterRegistry</code>继承了<code>ConverterRegistry</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.format;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FormatterRegistry</span> <span class="keyword">extends</span> <span class="title">ConverterRegistry</span> </span>&#123;</span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConverterRegistry</code>接口可以注册Converter等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConverterRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addConverter</span><span class="params">(Converter&lt;?, ?&gt; converter)</span></span>;</span><br><span class="line">&lt;S, T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addConverter</span><span class="params">(Class&lt;S&gt; sourceType, Class&lt;T&gt; targetType, Converter&lt;? <span class="keyword">super</span> S, ? extends T&gt; converter)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addConverter</span><span class="params">(GenericConverter converter)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addConverterFactory</span><span class="params">(ConverterFactory&lt;?, ?&gt; factory)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeConvertible</span><span class="params">(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切入点：</p><p>在MVC的自动装配类<code>WebMvcAutoConfiguration</code>中，可以看到这样一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot.autoconfigure.web.servlet;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcAutoConfiguration</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Import(EnableWebMvcConfiguration.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123; WebMvcProperties.class, ResourceProperties.class &#125;)</span></span><br><span class="line"><span class="meta">@Order(0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcAutoConfigurationAdapter</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFormatters</span><span class="params">(FormatterRegistry registry)</span> </span>&#123;</span><br><span class="line">ApplicationConversionService.addBeans(registry, <span class="keyword">this</span>.beanFactory);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>WebMvcAutoConfigurationAdapter</code>实现<code>WebMvcConfigurer</code>接口注册到IOC中，并调用<code>ApplicationConversionService.addBeans(registry, this.beanFactory);</code>方法注册了一些bean</p><p>继续跟源码 ApplicationConversionService.addBeans(registry, this.beanFactory)；可以看到beanFactory中的Converter bean被注册到FormatterRegistry中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot.convert;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationConversionService</span> <span class="keyword">extends</span> <span class="title">FormattingConversionService</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add &#123;<span class="doctag">@link</span> GenericConverter&#125;, &#123;<span class="doctag">@link</span> Converter&#125;, &#123;<span class="doctag">@link</span> Printer&#125;, &#123;<span class="doctag">@link</span> Parser&#125;</span></span><br><span class="line"><span class="comment"> * and &#123;<span class="doctag">@link</span> Formatter&#125; beans from the specified context.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registry the service to register beans with</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactory the bean factory to get the beans from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.2.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addBeans</span><span class="params">(FormatterRegistry registry, ListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">Set&lt;Object&gt; beans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">beans.addAll(beanFactory.getBeansOfType(GenericConverter.class).values());</span><br><span class="line">beans.addAll(beanFactory.getBeansOfType(Converter.class).values());</span><br><span class="line">beans.addAll(beanFactory.getBeansOfType(Printer.class).values());</span><br><span class="line">beans.addAll(beanFactory.getBeansOfType(Parser.class).values());</span><br><span class="line"><span class="keyword">for</span> (Object bean : beans) &#123;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> GenericConverter) &#123;</span><br><span class="line">registry.addConverter((GenericConverter) bean);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Converter) &#123;</span><br><span class="line">registry.addConverter((Converter&lt;?, ?&gt;) bean);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Formatter) &#123;</span><br><span class="line">registry.addFormatter((Formatter&lt;?&gt;) bean);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Printer) &#123;</span><br><span class="line">registry.addPrinter((Printer&lt;?&gt;) bean);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Parser) &#123;</span><br><span class="line">registry.addParser((Parser&lt;?&gt;) bean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时<code>WebMvcAutoConfigurationAdapter</code>还引入了<code>EnableWebMvcConfiguration</code>配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot.autoconfigure.web.servlet;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcAutoConfiguration</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EnableWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title">DelegatingWebMvcConfiguration</span> <span class="keyword">implements</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 注入 mvcConversionService，完成 RequestMappingHandlerMapping 的配置</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestMappingHandlerMapping <span class="title">requestMappingHandlerMapping</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="meta">@Qualifier(&quot;mvcContentNegotiationManager&quot;)</span> ContentNegotiationManager contentNegotiationManager,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="meta">@Qualifier(&quot;mvcConversionService&quot;)</span> FormattingConversionService conversionService,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="meta">@Qualifier(&quot;mvcResourceUrlProvider&quot;)</span> ResourceUrlProvider resourceUrlProvider)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Must be @Primary for MvcUriComponentsBuilder to work</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.requestMappingHandlerMapping(contentNegotiationManager, conversionService,</span><br><span class="line">resourceUrlProvider);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 声明bean mvcConversionService</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FormattingConversionService <span class="title">mvcConversionService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Format format = <span class="keyword">this</span>.mvcProperties.getFormat();</span><br><span class="line">WebConversionService conversionService = <span class="keyword">new</span> WebConversionService(<span class="keyword">new</span> DateTimeFormatters()</span><br><span class="line">.dateFormat(format.getDate()).timeFormat(format.getTime()).dateTimeFormat(format.getDateTime()));</span><br><span class="line">addFormatters(conversionService);</span><br><span class="line"><span class="keyword">return</span> conversionService;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>不难发现，MVC的数据转换服务是由名为”mvcConversionService”的ConversionService完成的，看看mvcConversionService这个bean的创建做了哪些事。</p><p>进<code>WebConversionService</code>源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot.autoconfigure.web.format;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConversionService</span> <span class="keyword">extends</span> <span class="title">DefaultFormattingConversionService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WebConversionService</span><span class="params">(DateTimeFormatters dateTimeFormatters)</span> </span>&#123;<span class="comment">/// 构造器</span></span><br><span class="line"><span class="keyword">super</span>(<span class="keyword">false</span>); <span class="comment">/// 父类构造</span></span><br><span class="line"><span class="keyword">if</span> (dateTimeFormatters.isCustomized()) &#123;</span><br><span class="line">addFormatters(dateTimeFormatters);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">addDefaultFormatters(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DefaultFormattingConversionService</code>构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.format.support;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultFormattingConversionService</span> <span class="keyword">extends</span> <span class="title">FormattingConversionService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultFormattingConversionService</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultFormattingConversionService</span><span class="params">(<span class="keyword">boolean</span> registerDefaultFormatters)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="keyword">null</span>, registerDefaultFormatters);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultFormattingConversionService</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="meta">@Nullable</span> StringValueResolver embeddedValueResolver, <span class="keyword">boolean</span> registerDefaultFormatters)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (embeddedValueResolver != <span class="keyword">null</span>) &#123;</span><br><span class="line">setEmbeddedValueResolver(embeddedValueResolver);</span><br><span class="line">&#125;</span><br><span class="line">DefaultConversionService.addDefaultConverters(<span class="keyword">this</span>); <span class="comment">/// 添加默认的 Converter</span></span><br><span class="line"><span class="keyword">if</span> (registerDefaultFormatters) &#123;</span><br><span class="line">addDefaultFormatters(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结，<code>EnableWebMvcConfiguration</code>配置类提供了MVC的默认配置，并添加注册了框架默认的Converter 到mvcConversionService，利用mvcConversionService完成 <code>RequestMappingHandlerMapping</code> 的配置</p><p>如图：</p><p><img src="/WindShadow/Spring/Spring%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80%E8%83%BD%E5%8A%9B-%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/MVC%E6%B3%A8%E5%86%8CConverter.svg"></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Converter加入IOC可以被MVC管理，从而在参数绑定上使用其能力，但是要注意controller方法写法的区别。在Bean配置上使用Converter则需要手动注册到名为”conversionService”类型为<code>ConversionService</code>的配置bean中，IOC在bean配置时才能享受到其能力。</p><h2 id="Formatter"><a href="#Formatter" class="headerlink" title="Formatter"></a>Formatter</h2><p>数据转换中还有一个特殊的接口，<code>Formatter</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.format;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Formatter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Printer</span>&lt;<span class="title">T</span>&gt;, <span class="title">Parser</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.format;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Printer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="function">String <span class="title">print</span><span class="params">(T object, Locale locale)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.format;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Parser</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="function">T <span class="title">parse</span><span class="params">(String text, Locale locale)</span> <span class="keyword">throws</span> ParseException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容易想到格式化器是java对象和String之间的转换功能在不同地区语言上的加强，所以它是在MVC控制层使用的，根据不同地区信息进行数据转换。</p><h3 id="Formatter数据转换"><a href="#Formatter数据转换" class="headerlink" title="Formatter数据转换"></a>Formatter数据转换</h3><p>定义实体类User</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义格式化器，加入IOC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 实现 id-name-email 到 User的互转，此处为了演示忽略 locale */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFormatter</span> <span class="keyword">implements</span> <span class="title">Formatter</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** like: &quot;id-name-email&quot; */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern USER_STRING_PATTERN = Pattern.compile(<span class="string">&quot;[0-9]&#123;1,&#125;-[a-zA-Z\\u4e00-\\u9fa5]&#123;1,&#125;-\\S*&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">parse</span><span class="params">(String text, Locale locale)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;parse: &#123;&#125;&quot;</span>, text);</span><br><span class="line">        <span class="keyword">if</span> (!USER_STRING_PATTERN.matcher(text).matches()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ParseException(<span class="string">&quot;The value [&quot;</span> + text + <span class="string">&quot;] is not matcher format &lt;id-name-email&gt;&quot;</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String[] fields = text.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(Long.valueOf(fields[<span class="number">0</span>]),fields[<span class="number">1</span>],fields[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">print</span><span class="params">(User user, Locale locale)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;print: &#123;&#125;&quot;</span>, user);</span><br><span class="line">        <span class="keyword">return</span> user.getId() + <span class="string">&quot;-&quot;</span> + user.getName() + <span class="string">&quot;-&quot;</span> + user.getEmail();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/formatter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormatterController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------------</span></span><br><span class="line">    <span class="comment">// Formatter 的转换器效果</span></span><br><span class="line">     <span class="comment">//-------------------------------</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get参数(String类型)直接解析为&#123;<span class="doctag">@link</span> User&#125;，指定参数名</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;/formatter/user-request-query-assign?user=100-tom-123qq.com</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;但无法进行&#123;<span class="doctag">@link</span> Validated&#125;校验</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ws.spring.convert.formatter.UserFormatter#parse(String, Locale)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user-request-query-assign&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">formatUserWhenQueryParamAssign</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@RequestParam(&quot;user&quot;)</span> User user)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;user: &#123;&#125;&quot;</span>,user);</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get参数(String类型)直接解析为&#123;<span class="doctag">@link</span> User&#125;，不指定参数名</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;/formatter/user-request-query-non-assign?user=100-tom-123qq.com</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;可以进行&#123;<span class="doctag">@link</span> Validated&#125;校验</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ws.spring.convert.formatter.UserFormatter#parse(String, Locale)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user-request-query-non-assign&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">formatUserWhenQueryParamNonAssign</span><span class="params">(<span class="meta">@Validated</span> User user)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;user: &#123;&#125;&quot;</span>,user);</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Formatter-view视图格式化"><a href="#Formatter-view视图格式化" class="headerlink" title="Formatter view视图格式化"></a>Formatter view视图格式化</h3><p>在MVC后端视图渲染时，我们可以通过格式化来指定数据在视图中的呈现内容，比如有一个pojo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NumberSeparate</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="meta">@NumberSeparate(&#x27;=&#x27;)</span></span><br><span class="line">    <span class="meta">@Max(100)</span></span><br><span class="line">    <span class="keyword">private</span> Long number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们希望，视图中使用NumberWrapper的code属性时，将code数值进行单个拆分，如”123” -&gt; “1-2-3”，将number也进行拆分，并指定分隔符为”=”，如如”123” -&gt; “1=2=3”，分隔符通过<code>NumberSeparate</code>注解指定。</p><p>在controller中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/formatter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormatterController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在jsp视图中格式化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> model</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/number-print&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">numberWrapperPrint</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        NumberWrapper wrapper = <span class="keyword">new</span> NumberWrapper(<span class="number">123</span>,<span class="number">456L</span>);</span><br><span class="line">        log.info(<span class="string">&quot;wrapper: &#123;&#125;&quot;</span>,wrapper);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;wrapper&quot;</span>,wrapper);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;show&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>show.jsp内容</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;form&quot;</span> uri=<span class="string">&quot;http://www.springframework.org/tags/form&quot;</span> %&gt;</span><br><span class="line">&lt;%@ taglib uri=<span class="string">&quot;http://www.springframework.org/tags&quot;</span> prefix=<span class="string">&quot;spring&quot;</span> %&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;from&quot;</span> uri=<span class="string">&quot;http://www.springframework.org/tags/form&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;welcome&lt;/title&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form:form modelAttribute=<span class="string">&quot;wrapper&quot;</span>&gt;</span><br><span class="line">    &lt;%--  <span class="number">1</span>-<span class="number">2</span>-<span class="number">3</span>  --%&gt;</span><br><span class="line">    &lt;h6&gt;&lt;from:input path=&quot;code&quot;/&gt;&lt;/h6&gt;</span><br><span class="line">    &lt;%--  <span class="number">4</span>=<span class="number">5</span>=<span class="number">6</span>  --%&gt;</span><br><span class="line">    &lt;h6&gt;&lt;from:input path=&quot;number&quot;/&gt;&lt;/h6&gt;</span><br><span class="line">&lt;/form:form&gt;</span><br><span class="line">&lt;H1&gt;JSP&lt;/H1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>效果</p><p><img src="/WindShadow/Spring/Spring%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80%E8%83%BD%E5%8A%9B-%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/show.jsp.png"></p><p><strong>代码实现</strong></p><p>定义注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NumberSeparate &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">separator</span><span class="params">()</span> <span class="keyword">default</span> &#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(&quot;separator&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &#x27;-&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现一个注解格式化工厂<code>AnnotationFormatterFactory</code>，且加入IOC容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberSeparateAnnotationFormatterFactory</span> <span class="keyword">implements</span> <span class="title">AnnotationFormatterFactory</span>&lt;<span class="title">NumberSeparate</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 支持的类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getFieldTypes() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(Integer.class,Long.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Printer&lt;?&gt; getPrinter(NumberSeparate annotation, Class&lt;?&gt; fieldType) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> separator = annotation.separator();</span><br><span class="line">        <span class="keyword">return</span> getFormatter(separator,fieldType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Parser&lt;?&gt; getParser(NumberSeparate annotation, Class&lt;?&gt; fieldType) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> separator = annotation.separator();</span><br><span class="line">        <span class="keyword">return</span> getFormatter(separator,fieldType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Formatter&lt;?&gt; getFormatter(<span class="keyword">char</span> separator, Class&lt;?&gt; clazz) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Integer.class.equals(clazz)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NumberSeparateFormatter&lt;&gt;(separator, Integer::valueOf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Long.class.equals(clazz)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NumberSeparateFormatter&lt;&gt;(separator, Long::valueOf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;不支持的类型&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 实现格式化器完成 &quot;123&quot; -&gt; “1-2-3” 的互转，继承Formatter以便同时实现  Printer 和 Parser */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberSeparateFormatter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt; <span class="keyword">implements</span> <span class="title">Formatter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> separator;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Function&lt;String,T&gt; converter;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">NumberSeparateFormatter</span><span class="params">(<span class="keyword">char</span> separator, Function&lt;String,T&gt; converter)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.separator = separator;</span><br><span class="line">            <span class="keyword">this</span>.converter = converter;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">print</span><span class="params">(T object, Locale locale)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">char</span>[] chars = object.toString().toCharArray();</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> aChar : chars) &#123;</span><br><span class="line">                sb.append(aChar).append(separator);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sb.substring(<span class="number">0</span>,sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">parse</span><span class="params">(String text, Locale locale)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line"></span><br><span class="line">            String replace = text.replace(String.valueOf(separator), <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> converter.apply(replace);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ParseException(<span class="string">&quot;格式错误&quot;</span>,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以在view视图上使用Formatter 的格式化能力</p><p>同时在参数绑定上也可以完成字符串到java对象转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/formatter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormatterController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在参数绑定时解析参数到注解上的属性</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; /formatter/number-parse?code=1-2-3&amp;number=4=5=6 即 /formatter/number-parse?code=1-2-3&amp;number=4%3D5%3D6</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; 但是不经过参数校验，&#123;<span class="doctag">@link</span> NumberWrapper#number&#125;上的注解不会得到校验</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> wrapper wrapper</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/number-parse&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">numberWrapperParse</span><span class="params">(NumberWrapper wrapper)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;wrapper: &#123;&#125;&quot;</span>,wrapper);</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(wrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>疑点</strong>：为什么Formatter在MVC参数绑定上拥有和Converter一样的效果？</p><p>还记得MVC的自动装配中，名为”mvcConversionService”类型为 <code>WebConversionService</code> 的bean吗，其继承关系如图，看的出其继承<code>FormattingConversionService</code>实现了ConversionService 接口</p><p><img src="/WindShadow/Spring/Spring%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80%E8%83%BD%E5%8A%9B-%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/WebConversionService.png"></p><p>而<code>FormattingConversionService</code>在注册Formatterr时，通过内部类<code>PrinterConverter</code>和<code>ParserConverter</code>进行封装，实际注册的是它俩，所以MVC才拥有了数据转换的能力，故表面上看Formatter拥有和Converter一样的效果，源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.format.support;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormattingConversionService</span> <span class="keyword">extends</span> <span class="title">GenericConversionService</span> <span class="keyword">implements</span> <span class="title">FormatterRegistry</span>, <span class="title">EmbeddedValueResolverAware</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 添加 Printer */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPrinter</span><span class="params">(Printer&lt;?&gt; printer)</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt; fieldType = getFieldType(printer, Printer.class);</span><br><span class="line">addConverter(<span class="keyword">new</span> PrinterConverter(fieldType, printer, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 添加 Parser */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addParser</span><span class="params">(Parser&lt;?&gt; parser)</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt; fieldType = getFieldType(parser, Parser.class);</span><br><span class="line">addConverter(<span class="keyword">new</span> ParserConverter(fieldType, parser, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 添加 Formatter */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFormatter</span><span class="params">(Formatter&lt;?&gt; formatter)</span> </span>&#123;</span><br><span class="line">addFormatterForFieldType(getFieldType(formatter), formatter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFormatterForFieldType</span><span class="params">(Class&lt;?&gt; fieldType, Formatter&lt;?&gt; formatter)</span> </span>&#123;</span><br><span class="line">addConverter(<span class="keyword">new</span> PrinterConverter(fieldType, formatter, <span class="keyword">this</span>));</span><br><span class="line">addConverter(<span class="keyword">new</span> ParserConverter(fieldType, formatter, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFormatterForFieldType</span><span class="params">(Class&lt;?&gt; fieldType, Printer&lt;?&gt; printer, Parser&lt;?&gt; parser)</span> </span>&#123;</span><br><span class="line">addConverter(<span class="keyword">new</span> PrinterConverter(fieldType, printer, <span class="keyword">this</span>));</span><br><span class="line">addConverter(<span class="keyword">new</span> ParserConverter(fieldType, parser, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 封装 Printer 实现 GenericConverter */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrinterConverter</span> <span class="keyword">implements</span> <span class="title">GenericConverter</span> </span>&#123;</span><br><span class="line">         <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; fieldType;</span><br><span class="line">         <span class="keyword">private</span> <span class="keyword">final</span> TypeDescriptor printerObjectType;</span><br><span class="line">         <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">         <span class="keyword">private</span> <span class="keyword">final</span> Printer printer;</span><br><span class="line">         <span class="keyword">private</span> <span class="keyword">final</span> ConversionService conversionService;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">     &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/** 封装 Parser 实现 GenericConverter */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParserConverter</span> <span class="keyword">implements</span> <span class="title">GenericConverter</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; fieldType;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Parser&lt;?&gt; parser;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConversionService conversionService;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>Formatter用于数据对不同地区的语言信息进行格式化，如MVC视图的数据呈现格式化，同时因为FormattingConversionService内部对Formatter进行了增强，所以Formatter有了数据转换的能力，而且可以根据语言信息进行不同的转换。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot常用注解</title>
      <link href="WindShadow/SpringBoot/SpringBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
      <url>WindShadow/SpringBoot/SpringBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>话不多说，过一下配置文件</p><h2 id="yml配置文件主要写法"><a href="#yml配置文件主要写法" class="headerlink" title="yml配置文件主要写法"></a>yml配置文件主要写法</h2><p>参数写法</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mystarter.config:</span></span><br><span class="line">  <span class="comment"># 布尔类型</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 数字或基本类型</span></span><br><span class="line"><span class="comment">#  size: $&#123;random.int&#125; 随机数</span></span><br><span class="line">  <span class="attr">size:</span> <span class="number">18</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 字符串</span></span><br><span class="line"><span class="comment">#  address: &quot;beijing \n aaa&quot; 加双引号不会转义</span></span><br><span class="line"><span class="comment">#  address: &#x27;beijing \n aaa&#x27; 加单引号会转义</span></span><br><span class="line">  <span class="attr">address:</span> <span class="string">beijing</span></span><br><span class="line">  <span class="comment"># 时间date</span></span><br><span class="line">  <span class="attr">date:</span> <span class="number">2021</span><span class="string">/01/01</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 自定义bean map</span></span><br><span class="line"><span class="comment">#  user: &#123;username: root, password: 123456&#125; 行内写法</span></span><br><span class="line">  <span class="attr">user:</span></span><br><span class="line"><span class="comment">#    username: $&#123;mystarter.config.address&#125;  引用其它配置，不存在则为 &quot;$&#123;mystarter.config.address&#125;&quot;字符串</span></span><br><span class="line"><span class="comment">#    username: $&#123;mystarter.config.address: testuser&#125;  引用其它配置，不存在则使用缺省值</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">  <span class="attr">map:</span></span><br><span class="line">    <span class="attr">ip:</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">loginName:</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 数组 list set</span></span><br><span class="line"><span class="comment">#    array: [aaa,bbb,ccc] 行内写法</span></span><br><span class="line">  <span class="attr">array:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">aaa</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">bbb</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ccc</span></span><br><span class="line">  <span class="attr">list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ddd</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">eee</span></span><br><span class="line">  <span class="attr">set:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">fff</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ggg</span></span><br></pre></td></tr></table></figure><p>激活配置文件或配置块</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">demo-test</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line"><span class="comment"># 配置文件激活</span></span><br><span class="line"><span class="comment"># 1、创建配置文件时名称为 application-&#123;name&#125;.yml 可使用 spring.profiles.active=&#123;name&#125;去激活，找不到则使用默认主配置</span></span><br><span class="line"><span class="comment">#   激活后配置内容 = 配置文件交集 + 激活文件非交集部分</span></span><br><span class="line"><span class="comment"># 2、也可激活块部分，yml文档块 spring.profiles.active=dev1</span></span><br><span class="line"><span class="comment"># 3、使用命令行激活 --spring.profiles.active=dev1</span></span><br><span class="line"><span class="comment"># 4、使用jvm参数 -Dspring.profiles.active=dev1</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev1</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="string">---</span> <span class="comment"># 新的块</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev1</span></span><br><span class="line"><span class="string">---</span> <span class="comment"># 新的块</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev2</span></span><br><span class="line"><span class="comment">#  spring boot启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件</span></span><br><span class="line"><span class="comment">#  file:./config/</span></span><br><span class="line"><span class="comment">#  file:./</span></span><br><span class="line"><span class="comment">#  classpath:/config(- classpath:/</span></span><br><span class="line"><span class="comment">#  以上是按照优先级从高到低的顺序，所有位置的文件都会被加载，高优先级配置内容会覆盖低优先级配置内容。</span></span><br><span class="line"><span class="comment">#  我们也可以通过配置spring.config.location来改变默认配置</span></span><br></pre></td></tr></table></figure><p>另外，properties文件，特殊#—注释用于标记文档拆分</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">MyApp</span></span><br><span class="line"><span class="comment">#---</span></span><br><span class="line"><span class="meta">spring.config.activate.on-cloud-platform</span>=<span class="string">kubernetes</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">MyCloudApp</span></span><br></pre></td></tr></table></figure><h2 id="外部配置加载顺序"><a href="#外部配置加载顺序" class="headerlink" title="外部配置加载顺序"></a>外部配置加载顺序</h2><p>SpringBoot也可以从以下位置加载配置﹔优先级从高到低﹔高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置，以下列举实用的外部配置，<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config">官网文档</a></p><ol><li><p>命令行参数，多个参数用空格分开</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar spring-boot-xxx-0.0.1-SNAPSHOT.jar --server.port=9090</span><br></pre></td></tr></table></figure></li><li><p>来自java:comp/env的JNDI属性</p></li><li><p>Java系统属性( System.getProperties() )</p></li><li><p>操作系统环境变量</p></li><li><p>RandomValuePropertySource配置的random.*属性值</p></li><li><p>jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件</p></li><li><p>jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件</p></li><li><p>jar包外部的application.properties或application.yml(不带spring.profile)配置文件</p></li><li><p>jar包内部的application.properties或application.yml(不带spring.profile)配置文件</p></li><li><p>@Configuration注解类上的@PropertySource</p></li><li><p>通过SpringApplication.setDefaultProperties指定的默认属性</p></li></ol><p>优先级从 1 &gt; 2 &gt; … &gt; 11，jar包外 &gt; jar包内，带{profile} &gt; 不带{profile} ；</p><h2 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h2><p>从配置文件给bean配置属性</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>搭配组件型注解，如<code>@Component</code>，指定前缀，以属性名进行赋值，依赖于空构造函数；</p><ol><li><p>ignoreInvalidFields</p><p>当配置文件中的值无法映射给bean的属性。如字符串给数字赋值等，SpringBoot应用会抛异常而起动失败，而ignoreInvalidFields属性设置为true（默认为false）时可以使应用不会停止，即使用属性默认的值。</p></li><li><p>ignoreUnknownFields</p><p>忽略位置属性；当配置文件中出现了类中没有定义的属性时，即出现了未知的属性，SpringBoot默认时忽略它的（ignoreUnknownFields默认为true），ignoreUnknownFields设为false时，表示要对未知属性“斤斤计较”，结果自然是启动失败。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;ordinary.bind&quot;, ignoreInvalidFields = true, ignoreUnknownFields = false)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrdinaryPropertiesBindExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Boolean enable = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-Spring-Boot-Configuration-Processor自动补全"><a href="#使用-Spring-Boot-Configuration-Processor自动补全" class="headerlink" title="使用 Spring Boot Configuration Processor自动补全"></a>使用 Spring Boot Configuration Processor自动补全</h3><p>pom.xml中加入Spring Boot Configuration Processor的依赖，并重新build之后，IDEA中编写配置文件时就可以自动补全了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/WindShadow/SpringBoot/SpringBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8.png" alt="自动补全"></p><h4 id="标记配置属性为-Deprecated"><a href="#标记配置属性为-Deprecated" class="headerlink" title="标记配置属性为 Deprecated"></a>标记配置属性为 Deprecated</h4><p>使用<code>@DeprecatedConfigurationProperty</code>注解作用与属性的get方法上，表示该属性已经过时，重新build之后，属性对应的自动补全提示也会发生改变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;ordinary.bind&quot;, ignoreInvalidFields = true, ignoreUnknownFields = false)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrdinaryPropertiesBindExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Boolean enable = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeprecatedConfigurationProperty(reason = &quot;我已经过时&quot;, replacement = &quot;none&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">getEnable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.enable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/WindShadow/SpringBoot/SpringBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8-%E8%BF%87%E6%97%B6.png" alt="自动补全-过时"></p><h3 id="搭配-ConstructorBinding"><a href="#搭配-ConstructorBinding" class="headerlink" title="搭配@ConstructorBinding"></a>搭配@ConstructorBinding</h3><p><code>@ConstructorBinding</code>注解，顾名思义，构造绑定，通过构造方法，从配置文件获取值给bean设置属性。使用此方式时，需要通过<code>@EnableConfigurationProperties</code>注解修饰的配置类来扫描该类加入IOC，不能对通过常规Spring机制创建的bean使用构造函数绑定，即不能添加组件型注解（如<code>@Component</code>）这样的注解加入IOC，原因也很简单，这里不作解释。</p><p>搭配<code>@ConstructorBinding</code>的配置方式，一般在给类内为 final的属性初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConstructorBinding</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;constructor.bind&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorPropertiesBindExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;<span class="comment">// 一般用于运行时不可变的配置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConstructorPropertiesBindExample</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;构造方法被调用&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(ConstructorPropertiesBindExample.class)</span><span class="comment">// 激活</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorPropertiesBindExampleActive</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="搭配-Bean"><a href="#搭配-Bean" class="headerlink" title="搭配@Bean"></a>搭配<code>@Bean</code></h3><p>搭配<code>@Bean</code>注解时，不依赖该bean的无参构造，仅在bean实例化后进行属性设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConfigurationProperties(&quot;atbean.bind&quot;)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExampleBean <span class="title">exampleBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExampleBean();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 定义一个pojo</span></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String examName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ConfigurationPropertiesBinding与自定义转换器"><a href="#ConfigurationPropertiesBinding与自定义转换器" class="headerlink" title="@ConfigurationPropertiesBinding与自定义转换器"></a>@ConfigurationPropertiesBinding与自定义转换器</h2><p>实现<code>org.springframework.core.convert.converter.Converter</code>接口实现自定义转换器，使用<code>@ConfigurationPropertiesBinding</code>声名为Spring可用的转换器</p><p>设置性别类。不设置枚举是因为Spring默认支持枚举的字符串配置了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sex</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex MAN = <span class="keyword">new</span> Sex(<span class="string">&quot;man&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex WOMAN = <span class="keyword">new</span> Sex(<span class="string">&quot;woman&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Sex</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现性别类的转换器，接收不符合规则的String抛出<code>IllegalArgumentException</code>异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationPropertiesBinding</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SexConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>,<span class="title">Sex</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String,Sex&gt; SEX_VALUE_SET =</span><br><span class="line">            Arrays.stream(<span class="keyword">new</span> Sex[]&#123;Sex.MAN,Sex.WOMAN&#125;).collect(Collectors.toMap(Sex::getValue,sex -&gt; sex));</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sex <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (SEX_VALUE_SET.containsKey(source)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> SEX_VALUE_SET.get(source);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;The sex string value must in &quot;</span> + SEX_VALUE_SET.keySet().toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立一个pojo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;sexbean&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleSexBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Sex sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>yml文件如下配置即可达到目的，配置的值不是 man或woman则抛出异常</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义转换器</span></span><br><span class="line"><span class="attr">sexbean:</span></span><br><span class="line">  <span class="attr">sex:</span> <span class="string">man</span></span><br></pre></td></tr></table></figure><p>一般来说像上面这种情况使用枚举即可，这里为了举例不使用枚举。</p><h2 id="条件注入"><a href="#条件注入" class="headerlink" title="条件注入"></a>条件注入</h2><p>仅列举常用的条件注入（有必要的话，可以取去了解<code>SpringBootCondition</code>）</p><h3 id="ConditionalOnProperty"><a href="#ConditionalOnProperty" class="headerlink" title="@ConditionalOnProperty"></a>@ConditionalOnProperty</h3><p>根据【配置文件是否存在对应的键值对】作为注入条件</p><p>以下配置可理解为：配置文件存在 “ex.config.flag=true”时注入bean，若不存在该key值则默认为false（不注入）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;ex.config&quot;, name = &quot;flag&quot;, havingValue = &quot;1&quot;, matchIfMissing = false)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConditionalOnBean"><a href="#ConditionalOnBean" class="headerlink" title="@ConditionalOnBean"></a>@ConditionalOnBean</h3><p>根据【容器内是否存在符合条件的bean】作为注入条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConditionalOnBean &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要作为条件的类的Class对象数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要作为条件的类的Name,Class.getName()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] type() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  (用指定注解修饰的bean)条件所需的注解类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;? extends Annotation&gt;[] annotation() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * spring容器中bean的名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] name() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 搜索容器层级,当前容器，父容器，全部</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">SearchStrategy <span class="title">search</span><span class="params">()</span> <span class="keyword">default</span> SearchStrategy.ALL</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可能在其泛型参数中包含指定bean类型的其他类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt;[] parameterizedContainer() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnBean(value = SpringbootAnnotationApplication.class)</span></span><br><span class="line"><span class="comment">//@ConditionalOnBean(name = &quot;springbootAnnotationApplication&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleConditionalOnBean</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConditionalOnClass"><a href="#ConditionalOnClass" class="headerlink" title="@ConditionalOnClass"></a>@ConditionalOnClass</h3><p>根据【工程中引入是否存在该class】作为注入条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass(SpringbootAnnotationApplication.class)</span></span><br><span class="line"><span class="comment">//@ConditionalOnClass(name = &quot;ws.springboot.springbootannotation.SpringbootAnnotationApplication&quot;) // 类全限定名</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleConditionalOnClass</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConditionalOnJava"><a href="#ConditionalOnJava" class="headerlink" title="@ConditionalOnJava"></a>@ConditionalOnJava</h3><p>根据【当前使用的java版本与配置的版本对比结果】作为注入条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnJava(</span></span><br><span class="line"><span class="meta">        value = JavaVersion.EIGHT, // java 1.8</span></span><br><span class="line"><span class="meta">        range = ConditionalOnJava.Range.EQUAL_OR_NEWER)</span><span class="comment">// 大于或等于 ConditionalOnJava.Range.OLDER_THAN 为小于</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleConditionalOnJava</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConditionalOnExpression"><a href="#ConditionalOnExpression" class="headerlink" title="@ConditionalOnExpression"></a>@ConditionalOnExpression</h3><p>根据【spel表达式结果】作为注入条件，注解内值不符合表达式规则则抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnExpression(&quot;1 + 1 == 2&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleConditionalOnExpression</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConditionalOnMissingBean"><a href="#ConditionalOnMissingBean" class="headerlink" title="@ConditionalOnMissingBean"></a>@ConditionalOnMissingBean</h3><p>根据【容器内是否不存在符合条件的bean】作为注入条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Conditional(OnBeanCondition.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConditionalOnMissingBean &#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要检查的 bean 的 class 类型。当 ApplicationContext 不包含每一个被指定的 class 时条件匹配。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;;    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要检查的 bean 的 class 类型名称(Java全限定名)。当 ApplicationContext 不包含每一个被指定的 class 时条件匹配。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] type() <span class="keyword">default</span> &#123;&#125;;    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 识别匹配 bean 时，可以被忽略的 bean 的 class 类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt;[] ignored() <span class="keyword">default</span> &#123;&#125;;    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 识别匹配 bean 时，可以被忽略的 bean 的 class 类型名称(Java全限定名)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] ignoredType() <span class="keyword">default</span> &#123;&#125;;    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 装饰需要检查的 bean 的注解。当 ApplicationContext 不包含带有这些注解的 bean 时条件匹配。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;? extends Annotation&gt;[] annotation() <span class="keyword">default</span> &#123;&#125;;    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要检查的 bean 的 name。当 ApplicationContext 不包含任意指定的每一个的 class 时条件匹配。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] name() <span class="keyword">default</span> &#123;&#125;;    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 搜索容器层级,当前容器，父容器，全部</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">SearchStrategy <span class="title">search</span><span class="params">()</span> <span class="keyword">default</span> SearchStrategy.ALL</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnMissingBean(name = &quot;springbootAnnotationApplication999&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleConditionalOnMissingBean</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConditionalOnMissingClass"><a href="#ConditionalOnMissingClass" class="headerlink" title="@ConditionalOnMissingClass"></a>@ConditionalOnMissingClass</h3><p>根据【容器内是否不存在该class的bean】作为注入条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnMissingClass(&quot;ws.springboot.springbootannotation.SpringbootAnnotationApplication999&quot;)</span> <span class="comment">// 类全限定名</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleConditionalOnMissingClass</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConditionalOnMissingFilterBean"><a href="#ConditionalOnMissingFilterBean" class="headerlink" title="@ConditionalOnMissingFilterBean"></a>@ConditionalOnMissingFilterBean</h3><p>根据【容器内是否不存在该过滤器】作为注入条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnMissingFilterBean(CorsFilter.class)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleConditionalOnMissingFilterBean</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConditionalOnCloudPlatform"><a href="#ConditionalOnCloudPlatform" class="headerlink" title="@ConditionalOnCloudPlatform"></a>@ConditionalOnCloudPlatform</h3><p>根据【应用所处云平台】作为注入条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleConditionalOnCloudPlatform</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">CloudPlatform</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无（无平台，返回false，bean不会被注入）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">NONE,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 云计算平台</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CLOUD_FOUNDRY,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Heroku平台</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">HEROKU,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SAP 云平台.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SAP,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * K8S.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">KUBERNETES </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConditionalOnWebApplication"><a href="#ConditionalOnWebApplication" class="headerlink" title="@ConditionalOnWebApplication"></a>@ConditionalOnWebApplication</h3><p>根据【应用是否所处于web环境】作为注入条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.ANY)</span> <span class="comment">// 任何web环境</span></span><br><span class="line"><span class="comment">//@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET) // 基于servlet的web应用</span></span><br><span class="line"><span class="comment">//@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.REACTIVE) // 基于响应式的web应用（猜测可能是webflux）</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleConditionalOnWebApplication</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ConditionalOnNotWebApplication"><a href="#ConditionalOnNotWebApplication" class="headerlink" title="@ConditionalOnNotWebApplication"></a>@ConditionalOnNotWebApplication</h3><p>根据【应用是否所不处于web环境】作为注入条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnNotWebApplication</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleConditionalOnNotWebApplication</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConditionalOnResource"><a href="#ConditionalOnResource" class="headerlink" title="@ConditionalOnResource"></a>@ConditionalOnResource</h3><p>根据【资源是否存在】作为注入条件，如日志的相关配置等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnResource(resources = &quot;classpath:application.yml&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleConditionalOnResource</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConditionalOnSingleCandidate"><a href="#ConditionalOnSingleCandidate" class="headerlink" title="@ConditionalOnSingleCandidate"></a>@ConditionalOnSingleCandidate</h3><p>根据【容器内是否存在该class的bean，且只有一个实例或为首选的】作为注入条件，即容器中存在该class的bean的实例，且只有一个时注入条件为true，当存在多个实例时，有一个实例为首选的（如加上了<code>@Primary</code>注解），注入条件也为true，即在其它bean中注入该class的bean时，如使用<code>@Autowired</code>且不指定bean名称时，不会发生依赖注入失败，这个时候，以这个calss为value的<code>@ConditionalOnResource</code>注解条件匹配结果就是true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnSingleCandidate(value = I.class)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleConditionalOnSingleCandidate</span> </span>&#123; <span class="comment">// 不可注入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I</span></span>&#123;&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">I</span></span>&#123;&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">I</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnSingleCandidate(value = I.class)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleConditionalOnSingleCandidate</span> </span>&#123; <span class="comment">// 可注入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I</span></span>&#123;&#125;</span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">I</span></span>&#123;&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">I</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="条件注入的组合"><a href="#条件注入的组合" class="headerlink" title="条件注入的组合"></a>条件注入的组合</h2><h3 id="组合条件-AND"><a href="#组合条件-AND" class="headerlink" title="组合条件 AND"></a>组合条件 AND</h3><ol><li><p>在类上使用多个@ConditionalOnXxxx</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass(name = &quot;ws.springboot.springbootannotation.SpringbootAnnotationApplication&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnJava(value = JavaVersion.EIGHT, range = ConditionalOnJava.Range.EQUAL_OR_NEWER)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleConditionalAnd1</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义注解上使用其它条件注入注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(name = &quot;ws.springboot.springbootannotation.SpringbootAnnotationApplication&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnJava(value = JavaVersion.EIGHT, range = ConditionalOnJava.Range.EQUAL_OR_NEWER)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyConditionalAndAnno &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用到要进行条件注入的组件上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyConditionalAndAnno</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleConditionalAnd3</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>继承<code>AllNestedConditions</code>类封装条件，使用静态内部类标注条件，所有条件将进行【逻辑与】操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * and条件注入</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> WindShadow</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/2/3</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConditionalAnd</span> <span class="keyword">extends</span> <span class="title">AllNestedConditions</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyConditionalAnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(ConfigurationPhase.PARSE_CONFIGURATION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConditionalOnClass(name = &quot;ws.springboot.springbootannotation.SpringbootAnnotationApplication&quot;)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OnClass</span></span>&#123;&#125;</span><br><span class="line">    <span class="meta">@ConditionalOnJava(value = JavaVersion.EIGHT, range = ConditionalOnJava.Range.EQUAL_OR_NEWER)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OnJava</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Conditional(MyConditionalAnd.class)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleConditionalAnd2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>ConfigurationPhase</code>枚举的两个值意义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ConfigurationPhase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 配置类解析阶段，如果条件为false，配置类将不会被解析</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        PARSE_CONFIGURATION,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * bean注册阶段，如果为false，bean将不会被注册</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">REGISTER_BEAN</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="组合条件-OR"><a href="#组合条件-OR" class="headerlink" title="组合条件 OR"></a>组合条件 OR</h3><p>   继承<code>AnyNestedCondition</code>类封装条件，使用静态内部类标注条件，所有条件将进行【逻辑或】操作</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConditionalOr</span> <span class="keyword">extends</span> <span class="title">AnyNestedCondition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyConditionalOr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(ConfigurationPhase.PARSE_CONFIGURATION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConditionalOnClass(name = &quot;ws.springboot.springbootannotation.SpringbootAnnotationApplication&quot;)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OnClass</span></span>&#123;&#125;</span><br><span class="line">    <span class="meta">@ConditionalOnJava(value = JavaVersion.NINE, range = ConditionalOnJava.Range.EQUAL_OR_NEWER)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OnJava</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Conditional(MyConditionalOr.class)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleConditionalOr</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合条件-NOT"><a href="#组合条件-NOT" class="headerlink" title="组合条件 NOT"></a>组合条件 NOT</h3><p>   继承<code>NoneNestedConditions</code>类封装条件，使用静态内部类标注条件，所有条件将进行【逻辑非】操作</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConditionalNot</span> <span class="keyword">extends</span> <span class="title">NoneNestedConditions</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyConditionalNot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(ConfigurationPhase.PARSE_CONFIGURATION);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@ConditionalOnClass(name = &quot;ws.springboot.springbootannotation.SpringbootAnnotationApplication999&quot;)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OnClass</span></span>&#123;&#125;</span><br><span class="line">    <span class="meta">@ConditionalOnJava(value = JavaVersion.NINE, range = ConditionalOnJava.Range.EQUAL_OR_NEWER)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OnJava</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Conditional(MyConditionalNot.class)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleConditionalNot</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Servlet组件的扫描"><a href="#Servlet组件的扫描" class="headerlink" title="Servlet组件的扫描"></a>Servlet组件的扫描</h2><h3 id="ServletComponentScan"><a href="#ServletComponentScan" class="headerlink" title="ServletComponentScan"></a>ServletComponentScan</h3><p>在<code>@SpringBootApplication</code>上使用<code>@ServletComponentScan</code>注解后，Servlet、Filter、Listener可以直接通过<code>@WebServlet</code>、<code>@WebFilter</code>、<code>@WebListener</code>注解自动注册，无需其他代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServletComponentScan</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nginx原理初探</title>
      <link href="WindShadow/Nginx/Nginx%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2/"/>
      <url>WindShadow/Nginx/Nginx%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="Nginx-多进程架构"><a href="#Nginx-多进程架构" class="headerlink" title="Nginx 多进程架构"></a>Nginx 多进程架构</h2><p>Nginx 多进程架构：<strong>一个master进程和多个worker进程</strong>；</p><ul><li>master进程：主要负责有轻而巧的工作，通过进程间通信对worker 进程发号施令或是处理来自bash的start,stop,reload等用户指令</li><li>worker进程：主要负责重而笨的工作，处理来自客户端的连接等，多个worker共享一个监听套接字；</li><li>worker进程由master进程fork而来</li><li>客户端请求处理机制：请求争抢；客户端请求到达nginx时，多个worker进程进行请求争抢</li></ul><p>在Linux下，Nginx 使用 epoll 的 I/O 多路复用模型（常见的/O 多路复用模型包括： select 模型、 poll模型、 epoll 模型）</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">   <span class="comment"># 默认使用epoll </span></span><br><span class="line">   <span class="attribute">use</span> <span class="literal">epoll</span>;</span><br><span class="line">   <span class="comment"># 每个worker允许连接的最大数</span></span><br><span class="line">   <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>拓展：</em></p><p><em>在TCP Socket 服务开发中，多进程或多线程共享监听套接字时会面临“惊群问题”（有兴趣了解一下）；</em></p><p><em>对于主流的linux版本, accept 阻塞调用,已经不存在惊群问题，也就是说多个进程同时accept 同一个 监听套接字,只有一个进程获的连接；</em></p><p><em>Nginx 在linux系统中使用epoll_wait 非阻塞式的方式，对于epoll_wait 非阻塞式的创建连接方式，依旧存在惊群问题。</em></p><p>多进程架构好处：</p><ul><li><p>热部署，可以使用nginx -s reload热部署</p></li><li><p>每个woker是独立的进程，如果有其中的一个woker出现问题，其他woker独立的继续进行争抢,实现请求过程,不会造成服务中断</p></li><li><p>首先，对于每个worker进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方便很多。其次，采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master进程则很快启动新的worker进程。当然，worker进程的异常退出，肯定是程序有bug了，异常退出，会导致当前worker上的所有请求失败，不过不会影响到所有请求，所以降低了风险。</p></li><li><p>Nginx同redis，类似都<strong>采用了io多路复用机制</strong>,每个worker都是一个独立的进程，但每个进程里只有一个主线程，通过<strong>异步非阻塞</strong>的方式来处理请求，即使是千上万个请求也不在话下。每个worker的线程可以把一个cpu的性能发挥到极致。所以 worker数和服务器的cpu数相等是最为适宜的。设置少了会浪费cpu性能，设多了会造成cpu频繁切换上下文带来损耗。</p><p>在nginx配置文件全局块中，通过 worker_processes 参数配置worker 进程数，设置为 auto时，nginx则会自动设置与cpu核心数相同的数量worker 进程。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span> auto;</span><br></pre></td></tr></table></figure></li></ul><h2 id="推荐文章"><a href="#推荐文章" class="headerlink" title="推荐文章"></a>推荐文章</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/spivic/article/details/15501359?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">初探Nginx架构之进程模型与事件处理机制</a></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot使用ssl</title>
      <link href="WindShadow/SpringBoot/SpringBoot%E4%BD%BF%E7%94%A8ssl/"/>
      <url>WindShadow/SpringBoot/SpringBoot%E4%BD%BF%E7%94%A8ssl/</url>
      
        <content type="html"><![CDATA[<h2 id="keytool"><a href="#keytool" class="headerlink" title="keytool"></a>keytool</h2><p>JDK自带的keytool是一个证书工具，位于<JAVA_HOME>\bin\keytool.exe（linux同理），用它可以生成ssl证书。</JAVA_HOME></p><p>使用 <code>keytool -help</code> 查看可用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-certreq            生成证书请求</span><br><span class="line">-changealias        更改条目的别名</span><br><span class="line">-delete             删除条目</span><br><span class="line">-exportcert         导出证书</span><br><span class="line">-genkeypair         生成密钥对</span><br><span class="line">-genseckey          生成密钥</span><br><span class="line">-gencert            根据证书请求生成证书</span><br><span class="line">-importcert         导入证书或证书链</span><br><span class="line">-importpass         导入口令</span><br><span class="line">-importkeystore     从其他密钥库导入一个或所有条目</span><br><span class="line">-keypasswd          更改条目的密钥口令</span><br><span class="line">-list               列出密钥库中的条目</span><br><span class="line">-printcert          打印证书内容</span><br><span class="line">-printcertreq       打印证书请求的内容</span><br><span class="line">-printcrl           打印 CRL 文件的内容</span><br><span class="line">-storepasswd        更改密钥库的存储口令</span><br></pre></td></tr></table></figure><p>使用<code>keytool -command_name -help</code>查看命令用法</p><h3 id="生成密钥库"><a href="#生成密钥库" class="headerlink" title="生成密钥库"></a>生成密钥库</h3><p>密钥库可以当作证书仓库来看</p><p><code>keytool -genkeypair [option]</code>或<code>keytool -genkey [option]</code> </p><p>选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-alias &lt;alias&gt;                  要处理的条目的别名</span><br><span class="line">-keyalg &lt;keyalg&gt;                密钥算法名称</span><br><span class="line">-keysize &lt;keysize&gt;              密钥位大小</span><br><span class="line">-sigalg &lt;sigalg&gt;                签名算法名称</span><br><span class="line">-destalias &lt;destalias&gt;          目标别名</span><br><span class="line">-dname &lt;dname&gt;                  唯一判别名</span><br><span class="line">-startdate &lt;startdate&gt;          证书有效期开始日期/时间</span><br><span class="line">-ext &lt;value&gt;                    X.509 扩展</span><br><span class="line">-validity &lt;valDays&gt;             有效天数</span><br><span class="line">-keypass &lt;arg&gt;                  密钥口令</span><br><span class="line">-keystore &lt;keystore&gt;            密钥库名称</span><br><span class="line">-storepass &lt;arg&gt;                密钥库口令</span><br><span class="line">-storetype &lt;storetype&gt;          密钥库类型</span><br><span class="line">-providername &lt;providername&gt;    提供方名称</span><br><span class="line">-providerclass &lt;providerclass&gt;  提供方类名</span><br><span class="line">-providerarg &lt;arg&gt;              提供方参数</span><br><span class="line">-providerpath &lt;pathlist&gt;        提供方类路径</span><br><span class="line">-v                              详细输出</span><br><span class="line">-protected                      通过受保护的机制的口令</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>-storetype 指定仓库类型， JKS、 JCEKS、 PKCS12等，默认JKS</li><li>-keyalg 指定密钥的算法， RSA、 DSA 等，默认DSA</li><li>-keysize 指定密钥长度，默认2048</li><li>-alias 指定密钥对的别名，该别名是公开的</li><li>-keystore 密钥库的路径及名称</li></ul><p>例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 根据提示挨个输入参数</span></span><br><span class="line">keytool -genkey -alias &lt;密钥库别名&gt; -storetype &lt;密钥库类型&gt; -keyalg &lt;密钥算法名称&gt; -keystore &lt;密钥库路径&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入参数完毕后将在当前路径生成证书</span></span><br><span class="line">keytool -genkey -alias test -storetype jks -keyalg RSA -keystore test-keystore.jks </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 一次性搞定</span></span><br><span class="line">keytool -genkey -alias &lt;密钥库别名&gt; -storetype &lt;密钥库类型&gt; -keystore &lt;密钥库路径&gt; -keyalg &lt;密钥算法名称&gt; -keysize &lt;密钥位大小&gt; -storepass &lt;密钥库口令&gt; -keypass &lt;密钥口令&gt;  -validity &lt;有效天数&gt; -dname &lt;dname&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接在当前路径生成证书，CN可填多个如：<span class="string">&quot;CN=test1.com, CN=test2.com, OU=test.com, O=ChinaHonker, L=Beijing, S=Beijing, C=086&quot;</span></span></span><br><span class="line">keytool -genkey -alias ws-ssl-server-keystore -storetype jks -keystore ws-ssl-server-keystore.jks -keyalg RSA -keysize 2048 -storepass 123456serverstore -keypass 123456serverkey -validity 3650 -dname &quot;CN=WindShadow, OU=WindShadow,O=WS-Server, L=Beijing, S=Beijing, C=086&quot;</span><br></pre></td></tr></table></figure><h4 id="dname详解"><a href="#dname详解" class="headerlink" title="dname详解"></a>dname详解</h4><ul><li>CN：Common Name 公用名称，对于 SSL 证书，一般为网站域名；而对于代码签名证书则为申请单位名称；而对于客户端证书则为证书申请者的姓名</li><li>OU：Organization Name 单位名称，对于 SSL 证书，一般为网站域名；而对于代码签名证书则为申请单位名称；而对于客户端单位证书则为证书申请者所在单位名称</li><li>O：Organization 组织</li><li>L： Locality 所在城市</li><li>S：State 所在省份</li><li>C：Country 所在国家，只能填代表国家的双字母或地区代码，如中国：CN或086</li></ul><h3 id="导出证书（-cer文件）"><a href="#导出证书（-cer文件）" class="headerlink" title="导出证书（.cer文件）"></a>导出证书（.cer文件）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keytool -keystore &lt;密钥库路径&gt; -alias &lt;密钥库别名&gt; -storepass &lt;密钥库口令&gt; -export -file &lt;证书路径&gt;</span><br><span class="line">keytool -keystore ws-ssl-server-keystore.jks -alias ws-ssl-server-keystore -storepass 123456serverstore -export -file ws-ssl-server-keystore.cer</span><br></pre></td></tr></table></figure><h3 id="导入证书（-cer文件）到密钥库"><a href="#导入证书（-cer文件）到密钥库" class="headerlink" title="导入证书（.cer文件）到密钥库"></a>导入证书（.cer文件）到密钥库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keytool -import -alias &lt;密钥库别名&gt; -storepass &lt;密钥库口令&gt; -file &lt;证书路径&gt; -keystore &lt;密钥库路径&gt;</span><br><span class="line">keytool -import -alias ws-ssl-server-keystore -storepass 123456serverstore -file ws-ssl-server-keystore.cer -keystore ws-ssl-trust-keystore.jks</span><br></pre></td></tr></table></figure><h3 id="转换密钥库格式"><a href="#转换密钥库格式" class="headerlink" title="转换密钥库格式"></a>转换密钥库格式</h3><p>jks转pkcs12，p12的密钥库其实不需要使用<code>keypass</code>，但是使用keytool进行转换还是要指定一下参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">keytool -importkeystore \</span><br><span class="line">-srckeystore &lt;源密钥库路径&gt; -srcstoretype &lt;源密钥库类型&gt; -srcalias &lt;源密钥库别名&gt; -srcstorepass &lt;源密钥库口令&gt; -srcstorepass &lt;源密钥口令&gt; \</span><br><span class="line">-destkeystore &lt;目标密钥库路径&gt; -deststoretype &lt;目标密钥库类型&gt; -destalias &lt;源密钥库别名&gt; -deststorepass &lt;目标密钥库口令&gt;  -destkeypass &lt;目标密钥口令&gt;</span><br><span class="line"></span><br><span class="line">keytool -importkeystore -srckeystore ws-ssl-server-keystore.jks -srcstoretype jks -srcalias ws-ssl-server-keystore  -srcstorepass 123456serverstore  -srckeypass 123456serverkey -destkeystore ws-ssl-server-keystore.p12 -deststoretype pkcs12 -destalias ws-ssl-server-keystore -deststorepass 123456serverstore -destkeypass 123456serverkey</span><br></pre></td></tr></table></figure><h3 id="列出密钥库条目"><a href="#列出密钥库条目" class="headerlink" title="列出密钥库条目"></a>列出密钥库条目</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">keytool -list -keystore  &lt;密钥库路径&gt;  -storepass &lt;密钥库口令&gt; -keypass &lt;密钥口令&gt;</span><br><span class="line"></span><br><span class="line">keytool -list -keystore ws-ssl-server-keystore.jks  -storepass 123456serverstore -keypass 123456serverkey</span><br></pre></td></tr></table></figure><h2 id="SpringBoot使用ssl"><a href="#SpringBoot使用ssl" class="headerlink" title="SpringBoot使用ssl"></a>SpringBoot使用ssl</h2><p>写一个http接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpsTestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/ssl&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloHttps</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;https ws-ssl&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="http单向认证"><a href="#http单向认证" class="headerlink" title="http单向认证"></a>http单向认证</h3><ol><li><p>生成一个server密钥库，名为“ws-ssl-server-keystore.jks”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -alias ws-ssl-server-keystore -storetype jks -keystore ws-ssl-server-keystore.jks -keyalg RSA -keysize 2048 -storepass 123456serverstore -keypass 123456serverkey -validity 3650 -dname &quot;CN=WindShadow, OU=WindShadow,O=WS-Server, L=Beijing, S=Beijing, C=086&quot;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li>将密钥库放到资源文件夹下，并在配置文件中配置ssl</li></ol><p><img src="/WindShadow/SpringBoot/SpringBoot%E4%BD%BF%E7%94%A8ssl/%E5%8D%95%E5%90%91%E9%85%8D%E7%BD%AE.png" alt="单向配置"></p><p>配置文件如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8443</span></span><br><span class="line">  <span class="attr">ssl:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">key-store:</span> <span class="string">classpath:ssl/ws-ssl-server-keystore.jks</span></span><br><span class="line">    <span class="attr">key-store-type:</span> <span class="string">JKS</span></span><br><span class="line">    <span class="attr">key-store-password:</span> <span class="string">123456serverstore</span></span><br><span class="line">    <span class="attr">key-password:</span> <span class="string">123456serverkey</span></span><br><span class="line">    <span class="attr">key-alias:</span> <span class="string">ws-ssl-server-keystore</span></span><br><span class="line">    <span class="attr">client-auth:</span> <span class="string">none</span></span><br></pre></td></tr></table></figure><p>测试结果：浏览器警告并显示不安全连接</p><p><img src="/WindShadow/SpringBoot/SpringBoot%E4%BD%BF%E7%94%A8ssl/%E5%8D%95%E9%A1%B9-%E6%B5%8B%E8%AF%95.png" alt="单项-测试"></p><h3 id="http双向认证"><a href="#http双向认证" class="headerlink" title="http双向认证"></a>http双向认证</h3><ol><li><p>在单向认证基础上，再创建一个密钥库，名为“ws-ssl-trust-keystore.jks”；此时拥有两个密钥库“ws-ssl-server-keystore.jks”和“ws-ssl-trust-keystore.jks”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -alias ws-ssl-client-keystore -storetype jks -keystore ws-ssl-client-keystore.jks -keyalg RSA -keysize 2048 -storepass 123456clientstore -keypass 123456clientkey -validity 3650 -dname &quot;CN=WindShadow, OU=WindShadow,O=WS-Client, L=Beijing, S=Beijing, C=086&quot;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>创建一个信任库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -alias ws-ssl-trust-keystore -storetype jks -keystore ws-ssl-trust-keystore.jks -keyalg RSA -keysize 2048 -storepass 123456truststore -keypass 123456trustkey -validity 3650 -dname &quot;CN=WindShadow, OU=WindShadow,O=WS-Trust, L=Beijing, S=Beijing, C=086&quot;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>这server和client密钥库分别导出一个证书，分别为：“ws-ssl-server-keystore.cer”、”ws-ssl-server-client.cer”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -keystore ws-ssl-server-keystore.jks -alias ws-ssl-server-keystore -storepass 123456serverstore -export -file ws-ssl-server-keystore.cer</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -keystore ws-ssl-client-keystore.jks -alias ws-ssl-client-keystore -storepass 123456clientstore -export -file ws-ssl-client-keystore.cer</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>将两个证书导入到信任库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">keytool -import -alias ws-ssl-server-keystore -file ws-ssl-server-keystore.cer -keystore ws-ssl-trust-keystore.jks -storepass 123456truststore -noprompt</span><br><span class="line"></span><br><span class="line">keytool -import -alias ws-ssl-client-keystore -file ws-ssl-client-keystore.cer -keystore ws-ssl-trust-keystore.jks -storepass 123456truststore -noprompt</span><br></pre></td></tr></table></figure></li><li><p>将client密钥库转为由jks转pkcs12，pkcs12是行业标准格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -importkeystore -srckeystore ws-ssl-client-keystore.jks -srcstoretype jks -srcalias ws-ssl-client-keystore  -srcstorepass 123456clientstore  -srckeypass 123456clientkey -destkeystore ws-ssl-client-keystore.p12 -deststoretype pkcs12 -destalias ws-ssl-client-keystore -deststorepass 123456clientstore -destkeypass 123456clientkey</span><br></pre></td></tr></table></figure></li><li><p>此时得到如下文件</p><p><img src="/WindShadow/SpringBoot/SpringBoot%E4%BD%BF%E7%94%A8ssl/%E4%BB%93%E5%BA%93%E4%B8%8E%E8%AF%81%E4%B9%A6.png" alt="仓库与证书"></p></li><li><p>将服务端与其信任的的密钥库放到项目中</p><p>配置文件如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8443</span></span><br><span class="line">  <span class="attr">ssl:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">key-store:</span> <span class="string">classpath:ssl/ws-ssl-server-keystore.jks</span></span><br><span class="line">    <span class="attr">key-store-type:</span> <span class="string">JKS</span></span><br><span class="line">    <span class="attr">key-store-password:</span> <span class="string">123456serverstore</span></span><br><span class="line">    <span class="attr">key-password:</span> <span class="string">123456serverkey</span></span><br><span class="line">    <span class="attr">key-alias:</span> <span class="string">ws-ssl-server-keystore</span></span><br><span class="line">    <span class="attr">trust-store:</span> <span class="string">classpath:ssl/ws-ssl-server-trust-keystore.jks</span></span><br><span class="line">    <span class="attr">trust-store-type:</span> <span class="string">JKS</span></span><br><span class="line">    <span class="attr">trust-store-password:</span> <span class="string">123456servertruststore</span></span><br><span class="line">    <span class="attr">trust-store-provider:</span> <span class="string">SUN</span></span><br><span class="line">    <span class="attr">client-auth:</span> <span class="string">need</span> <span class="comment"># 双向认证</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>访问接口进行测试，会无法访问</p><p><img src="/WindShadow/SpringBoot/SpringBoot%E4%BD%BF%E7%94%A8ssl/%E5%8F%8C%E5%90%91%E6%B5%8B%E8%AF%951.png" alt="双向测试1"></p><p>此时给浏览器导入客户端p12证书，重启浏览器后即可访问成功！</p><p><img src="/WindShadow/SpringBoot/SpringBoot%E4%BD%BF%E7%94%A8ssl/%E5%AF%BC%E5%85%A5%E8%AF%81%E4%B9%A6.png" alt="导入证书"></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringIOC常用注解和接口</title>
      <link href="WindShadow/Spring/SpringIOC%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
      <url>WindShadow/Spring/SpringIOC%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="IOC-Bean注入相关"><a href="#IOC-Bean注入相关" class="headerlink" title="IOC Bean注入相关"></a>IOC Bean注入相关</h1><h2 id="前提了解"><a href="#前提了解" class="headerlink" title="前提了解"></a>前提了解</h2><h3 id="BeanDefinition知识点"><a href="#BeanDefinition知识点" class="headerlink" title="BeanDefinition知识点"></a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/157416835?from_voters_page=true">BeanDefinition知识点</a></h3><h3 id="组件型注解"><a href="#组件型注解" class="headerlink" title="组件型注解"></a>组件型注解</h3><p>使用@Component作为元注解的注解可理解为组件型注解，如常见的@Configuration、@Controller、@Service等</p><h3 id="依赖注入注解"><a href="#依赖注入注解" class="headerlink" title="依赖注入注解"></a>依赖注入注解</h3><h4 id="Required（已弃用）"><a href="#Required（已弃用）" class="headerlink" title="@Required（已弃用）"></a>@Required（已弃用）</h4><p>用于setter方法注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="meta">@Value(&quot;abc&quot;)</span> String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4><ul><li><p>根据类型注入，从容器中寻找与该属性class相同的bean进行匹配并注入，如果找到多个则抛出异常，找不到则该属性为null；</p></li><li><p>提供required属性，表示非必须注入，即容器中找不到bean进行注入则拉倒</p></li><li><p>支持@Primary</p><p>@Primary使用</p><p>有两个同类型不同名称的bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleConfig3</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean(&quot;bean3&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExampleBean3 <span class="title">exampleBean3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExampleBean3();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(&quot;bean32&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExampleBean3 <span class="title">exampleBean3</span><span class="params">(<span class="meta">@Value(&quot;abc&quot;)</span> String a)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> ExampleBean3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于@Autowired是根据class进行注入的，没有@Primary注解的情况下，此处注入会抛出异常，有了@Primary注解使该bean成为@Autowired的首选。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ExampleBean3 bean;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h4><p>指定名称注入，搭配@Autowired使用，解决@Autowired多个匹配的选择问题</p><h4 id="Resource（JSR250规范提供）"><a href="#Resource（JSR250规范提供）" class="headerlink" title="@Resource（JSR250规范提供）"></a>@Resource（JSR250规范提供）</h4><p>javax的注解，定义了资源相关的信息。在IOC中根据bean名称注入，不支持@Primary，不提供required属性</p><h4 id="Inject（JSR330规范提供）"><a href="#Inject（JSR330规范提供）" class="headerlink" title="@Inject（JSR330规范提供）"></a>@Inject（JSR330规范提供）</h4><p>拥有@Autowired的功能，支持@Primary，不提供required属性</p><hr><p>&gt;&gt;&gt; 开始进阶</p><h2 id="ComponentScan自定义过滤方式"><a href="#ComponentScan自定义过滤方式" class="headerlink" title="@ComponentScan自定义过滤方式"></a>@ComponentScan自定义过滤方式</h2><p>@ComponentScan如果什么都不写，默认 basePackages 为当前类所在包，过滤类型为上述<strong>组件型注解</strong>的类。</p><p>@ComponentScan的其它过滤方式很常见了，不再赘述，使用@ComponentScan的过滤类型中的 CUSTOM 类型自定义过滤方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">FilterType</span> </span>&#123;</span><br><span class="line">    ANNOTATION, <span class="comment">// 注解</span></span><br><span class="line">    ASSIGNABLE_TYPE,<span class="comment">// 类</span></span><br><span class="line">    ASPECTJ, <span class="comment">// 切点表达式</span></span><br><span class="line">    REGEX, <span class="comment">// 正则</span></span><br><span class="line">    CUSTOM;<span class="comment">// 自定义</span></span><br><span class="line">    <span class="comment">//*   构造方法...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义FilterType类型过滤器，实现 org.springframework.core.type.filter.TypeFilter 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTypeFilter</span> <span class="keyword">implements</span> <span class="title">TypeFilter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metadataReader 当前类信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metadataReaderFactory 其它类信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// 这里简单处理，根据className选择可匹配通过的类</span></span><br><span class="line">        String className = metadataReader.getClassMetadata().getClassName();</span><br><span class="line">        <span class="keyword">boolean</span> b = ExampleBean.class.getName().equals(className);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在@Configuration上使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">        basePackages = &quot;ws.spring.insight.bean.injection&quot;,</span></span><br><span class="line"><span class="meta">        useDefaultFilters = false,// 默认规则不生效，即仅扫描 basePackages包下符合includeFilters 规则下的bean</span></span><br><span class="line"><span class="meta">        includeFilters = &#123;</span></span><br><span class="line"><span class="meta">                // 自定义扫描规则</span></span><br><span class="line"><span class="meta">                @ComponentScan.Filter(type = FilterType.CUSTOM, classes = &#123;MyTypeFilter.class&#125;)&#125;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>spring会扫描 basePackages 指定包下的所有类，符合过滤规则的都会加入IOC中</p><h2 id="Conditional-条件注入"><a href="#Conditional-条件注入" class="headerlink" title="@Conditional 条件注入"></a>@Conditional 条件注入</h2><p>简单了解：@Conditional在SpringBoot中大量使用，因为SpringBoot父工程集成了很多maven依赖，也就是集成了很多组件，但是子工程不一定能用得到，所以在IOC启动时，通过@Conditional注解进行条件注入，把需要的组件加入IOC中，子工程引入对应的starter时，对应的组件注入条件也就为true，即激活，也符合了SpringBoot特点，开关式的配置（不然你以为application配置文件有个开关图标是干嘛的）。</p><p>实现org.springframework.context.annotation.Condition接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConditional</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conditionContext 判断条件能使用的上下文环境</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotatedTypeMetadata 注解信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可获取ioc bean工厂</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = conditionContext.getBeanFactory();</span><br><span class="line">        <span class="comment">// 获取目标类的加载信息</span></span><br><span class="line">        ClassLoader classLoader = conditionContext.getClassLoader();</span><br><span class="line">        <span class="comment">// 获取环境信息</span></span><br><span class="line">        Environment environment = conditionContext.getEnvironment();</span><br><span class="line">        <span class="comment">// 获取bean定义器，如查看是否有某个类已经注册到容器中</span></span><br><span class="line">        BeanDefinitionRegistry registry = conditionContext.getRegistry();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简单处理，获取操作系统名称</span></span><br><span class="line">        String osName = environment.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> osName != <span class="keyword">null</span>;<span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在组件型注解或@Bean上使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Conditional(MyConditional.class)</span><span class="comment">// 使用自定义条件注入器，决定bean是否可以注入IOC中，搭配组件型注解使用</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">// @Conditional也可用于方法上，搭配@Bean</span></span><br><span class="line">    <span class="comment">// @Conditional(MyConditional.class)</span></span><br><span class="line">    <span class="meta">@Bean(&quot;beanA2&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanA <span class="title">beanA2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Import-引入组件"><a href="#Import-引入组件" class="headerlink" title="@Import 引入组件"></a>@Import 引入组件</h2><h3 id="支持类型"><a href="#支持类型" class="headerlink" title="支持类型"></a>支持类型</h3><p>@Import 支持的value为class，支持三种类型：</p><ul><li>普通bean，被@Configuration注解作用的类也暂且叫做普通bean，Spring会根据该bean注解及接口等信息进行对应的操作，如遇到@Configuration则进行对应配置，遇到@Aspect时进行AOP代理等等</li><li>ImportSelector接口实现类</li><li>ImportBeanDefinitionRegistrar接口实现类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Import &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Configuration <span class="doctag">@Configuration</span>&#125;, &#123;<span class="doctag">@link</span> ImportSelector&#125;,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ImportBeanDefinitionRegistrar&#125;, or regular component classes to import.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    Class&lt;?&gt;[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ImportSelector接口实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportSelect</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotationMetadata 标注使用<span class="doctag">@Import</span>注解的类的注解信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 禁止返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">&quot;ws.spring.insight.bean.ExampleBeanB&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ImportBeanDefinitionRegistrar接口实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportRegister</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> importingClassMetadata 标注使用<span class="doctag">@Import</span>注解的类的注解信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry bean定义器，可进行bean定义相关操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;testBean2&quot;</span>,<span class="keyword">new</span> RootBeanDefinition(BeanB.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>搭配@Configuration使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;</span></span><br><span class="line"><span class="meta">        BeanA.class,// 1、普通类，通过bean的class导入，beanName为全类名</span></span><br><span class="line"><span class="meta">        MyImportSelect.class,// 2、通过选择器导入</span></span><br><span class="line"><span class="meta">        MyImportRegister.class// 3、通过注册器导入</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleConfig2</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PropertySource与-PropertySources"><a href="#PropertySource与-PropertySources" class="headerlink" title="@PropertySource与@PropertySources"></a>@PropertySource与@PropertySources</h2><p>value-properties.properties的配置文件：properties配置文件的方式仅支持spel表达式</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">admin.name</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">admin.age</span>=<span class="string">18</span></span><br><span class="line"><span class="meta">admin.email</span>=<span class="string">email</span></span><br></pre></td></tr></table></figure><p>使用配置文件装载一个bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @PropertySources // 指定多个配置文件</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:value-properties.properties&quot;)</span><span class="comment">// 指定配置文件</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Admin</span> </span>&#123;</span><br><span class="line">    <span class="comment">// @Value支持spel表达式</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;admin.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;admin.age&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;admin.email&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;12*2&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ConfigurationProperties（SpringBoot特有）"><a href="#ConfigurationProperties（SpringBoot特有）" class="headerlink" title="@ConfigurationProperties（SpringBoot特有）"></a>@ConfigurationProperties（SpringBoot特有）</h2><p>yml配置文件：yml支持松散绑定、支持JSR303数据校验、支持复杂类型填充、不支持spel表达式</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 松散绑定 root-admin、root_admin &lt;=&gt; rootAdmin，故yml的属性的键不可大写</span></span><br><span class="line"><span class="attr">root-admin:</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">rootadmin</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">pwd123456</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">email:</span> <span class="number">1245689668</span><span class="string">@qq.com</span></span><br><span class="line">  <span class="attr">birth:</span> <span class="number">2020</span><span class="string">/10/1</span></span><br><span class="line">  <span class="attr">map:</span> &#123;<span class="attr">k1:</span> <span class="string">v1</span>, <span class="attr">k2:</span> <span class="string">v2</span>&#125; <span class="comment"># 支持map</span></span><br><span class="line">  <span class="attr">list:</span> <span class="comment"># 支持 list集合 数组等</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">abd</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">123</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CDF</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;root-admin&quot;)</span> <span class="comment">// prefix不能有大写字母，RootAdmin对应 root-admin 属性 =&gt; 松散绑定</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Validated</span> <span class="comment">// 开启JSR303 数据检验</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RootAdmin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">// 此注解因JSR303检验开启而生效</span></span><br><span class="line">    <span class="comment">// 在创建这个bean的时候，填充到email的值不是邮箱地址格式则抛出异常，异常的message为注解指定的message</span></span><br><span class="line">    <span class="comment">// 其它JSR303的注解以此类推</span></span><br><span class="line">    <span class="meta">@Email(message = &quot;配置参数必须为邮箱&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; map;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring在创建带有@Validated注解（见下文）的bean的时候，就会对其属性进行JSR303数据校验。</p><h2 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h2><p>实现FactoryBean接口成为工厂bean，最终加入Spring IOC容器的bean有两个：</p><ul><li>bean名称 &amp;myFactoryBean，实例是 MyFactoryBean 工厂bean</li><li>bean名称 myFactoryBean，但实例是 ExampleBeanD 对象的实例，调用了getObject()方法。可通过其它方式修改bean名称，如@Component的value属性</li></ul><p>工厂bean的名称 = 目标bean名称前 + &amp;，通过bean名称获取工厂bean时，只需在bean名称前加“&amp;”；</p><p>获取bean时，先获取工厂Bean再调用getObject()方法；bean工厂与bean的作用域相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">ExampleBeanD</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册时，注册了两个bean的信息</span></span><br><span class="line">    <span class="comment">// bean名称 myFactoryBean，但实例是 ExampleBeanD 对象的实例</span></span><br><span class="line">    <span class="comment">// bean名称 &amp;myFactoryBean，实例是 MyFactoryBean 工厂bean</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * spring 调用此方法将返回的对象会加入到容器中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExampleBeanD <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExampleBeanD();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> ExampleBeanD.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bean初始化"><a href="#Bean初始化" class="headerlink" title="Bean初始化"></a>Bean初始化</h2><ul><li><p>实现InitializingBean, DisposableBean接口（官方不建议，与Spring框架强耦合）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleInitBean</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销毁方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@Bean中指定初始化方法与销毁方法（适用于导入第三方库的bean时）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(value = &quot;exampleBean&quot;,initMethod = &quot;init&quot;,destroyMethod = &quot;disposable&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExampleBeanA <span class="title">exampleBeanA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExampleBeanA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用@PostConstruct和@PreDestroy标注初始化和销毁方法（推荐）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBeanE</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disposable</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="初始化与销毁优先级"><a href="#初始化与销毁优先级" class="headerlink" title="初始化与销毁优先级"></a>初始化与销毁优先级</h3><p>当一个bean中同时存在多个初始化方法时，如在@Bean中标注初始化方法与销毁方法、该bean又实现InitializingBean, DisposableBean接口、同时该bean使用了@PostConstruct和@PreDestroy注解标注方法。执行顺序如下：</p><p>@PostConstruct -&gt; InitializingBean接口 -&gt; @Bean(initMethod=””) -&gt; @PreDestroy -&gt; DisposableBean接口 -&gt; @Bean(destroyMethod=””)</p><p>即：注解 &gt; 接口 &gt; @Bean标注</p><h2 id="Bean实现xxxAware接口"><a href="#Bean实现xxxAware接口" class="headerlink" title="Bean实现xxxAware接口"></a>Bean实现xxxAware接口</h2><p>bean实现Spring中xxxAware接口可以拿到对应的Spring组件，如图（仅展示部分）</p><p><img src="/WindShadow/Spring/SpringIOC%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%92%8C%E6%8E%A5%E5%8F%A3/aware.png" alt="aware"></p><h3 id="BeanFactoryAware"><a href="#BeanFactoryAware" class="headerlink" title="BeanFactoryAware"></a>BeanFactoryAware</h3><p>BeanFactory是顶层接口，功能少，面向Spring框架，不建议使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBeanFactoryBean</span> <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// 瓷锤获取bean工厂</span></span><br><span class="line">        <span class="comment">// beanFactory.getBean(&quot;&quot;); // 获取bean</span></span><br><span class="line">        <span class="comment">// beanFactory.containsBean(&quot;&quot;); // 是否包含指定bean</span></span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 转成 DefaultListableBeanFactory 可添加bean</span></span><br><span class="line">        DefaultListableBeanFactory defaultListableBeanFactory = (DefaultListableBeanFactory)beanFactory;</span><br><span class="line">        <span class="comment">// 注册单例bean</span></span><br><span class="line">        defaultListableBeanFactory.registerSingleton(<span class="string">&quot;exampleBean&quot;</span>,<span class="keyword">new</span> ExampleBeanG());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ApplicationContextAware"><a href="#ApplicationContextAware" class="headerlink" title="ApplicationContextAware"></a>ApplicationContextAware</h3><p>ApplicationContext扩展了BeanFactory接口，功能丰富，面向开发者，建议使用；</p><p>setApplicationContext()方法调用时机：ApplicationContextAware是在spring初始化完bean后才注入上下文的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBeanApplicationContextAware</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// 此处获取 applicationContext</span></span><br><span class="line">        <span class="comment">// 获取环境</span></span><br><span class="line">        Environment environment = applicationContext.getEnvironment();</span><br><span class="line">        environment.getProperty(<span class="string">&quot;os.name&quot;</span>);<span class="comment">// 获取操作系统名称</span></span><br><span class="line">        <span class="comment">// applicationContext.getBean(&quot;beanName&quot;); // 获取bean</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EmbeddedValueResolverAware"><a href="#EmbeddedValueResolverAware" class="headerlink" title="EmbeddedValueResolverAware"></a>EmbeddedValueResolverAware</h3><p>提供String 解析器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBeanEmbeddedValueResolverAware</span> <span class="keyword">implements</span> <span class="title">EmbeddedValueResolverAware</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmbeddedValueResolver</span><span class="params">(StringValueResolver stringValueResolver)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// String 解析器，支持spel表达式，可获取配置文件信息</span></span><br><span class="line">        <span class="comment">// os.name 操作系统名称 Windows 7</span></span><br><span class="line">        <span class="comment">// logging.level.root 配置文件中的值：info</span></span><br><span class="line">        String str = stringValueResolver.resolveStringValue(<span class="string">&quot;aaa$&#123;os.name&#125;===#&#123;12*2&#125;+$&#123;logging.level.root&#125;&quot;</span>);</span><br><span class="line">        System.out.println(str);<span class="comment">// aaaWindows 7===24+info</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口方法调用时机"><a href="#接口方法调用时机" class="headerlink" title="接口方法调用时机"></a>接口方法调用时机</h3><p>xxxAware接口方法的调用时机：每个Aware接口一般都用对应的xxxProcessor来处理调用该接口bean的方法，如ApplicationContextAware对应ApplicationContextAwareProcessor。可以看到ApplicationContextAwareProcessor实现了BeanPostProcessor接口，即bean后置处理器，也就是在bean即将可用之前，处理一波。其它Aware接口类似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextAwareProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareInterfaces</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware) &#123;</span><br><span class="line">            ((EnvironmentAware)bean).setEnvironment(<span class="keyword">this</span>.applicationContext.getEnvironment());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) &#123;</span><br><span class="line">            ((EmbeddedValueResolverAware)bean).setEmbeddedValueResolver(<span class="keyword">this</span>.embeddedValueResolver);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware) &#123;</span><br><span class="line">            ((ResourceLoaderAware)bean).setResourceLoader(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware) &#123;</span><br><span class="line">            ((ApplicationEventPublisherAware)bean).setApplicationEventPublisher(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MessageSourceAware) &#123;</span><br><span class="line">            ((MessageSourceAware)bean).setMessageSource(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">            ((ApplicationContextAware)bean).setApplicationContext(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-钩子"><a href="#Spring-钩子" class="headerlink" title="Spring 钩子"></a>Spring 钩子</h2><p>BeanFactoryPostProcessor和BeanPostProcessor这两个接口都是初始化bean时对外暴露的入口之一；</p><h3 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h3><p>bean工厂的bean属性后置处理容器，也就是说，Spring IoC容器允许BeanFactoryPostProcessor在容器实际实例化任何其它的bean之前读取配置元数据，并有可能修改它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取BeanDefinition 可对其进行任何操作</span></span><br><span class="line">       <span class="comment">// BeanDefinition beanDefinition = beanFactory.getBeanDefinition(&quot;&quot;);</span></span><br><span class="line">        <span class="comment">// 获取单例bean数量</span></span><br><span class="line">       <span class="comment">// int singleSize = beanFactory.getSingletonCount();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BeanDefinitionRegistryPostProcessor"><a href="#BeanDefinitionRegistryPostProcessor" class="headerlink" title="BeanDefinitionRegistryPostProcessor"></a>BeanDefinitionRegistryPostProcessor</h3><p>BeanDefinitionRegistryPostProcessor是BeanFactoryPostProcessor的子接口,BeanFactoryPostProcessor的作用是在Spring Bean的定义信息已经加载但还没有初始化的时候执行postProcessBeanFactory()来处理一些额外的逻辑，而BeanDefinitionRegistryPostProcessor的作用是在BeanFactoryPostProcessor增加了一个前置处理，当一个Bean实现了该接口后，始化前先执行该接口的postProcessBeanDefinitionRegistry()方法，然后再执行其父类的方法postProcessBeanFactory()。这样就把一个Spring Bean的初始化周期更加细化，让我们在各个阶段有定制它的可能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBeanDefinitionRegistryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// 先执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// 后执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><p>bean属性后置处理器，方法也是见名知意，实现BeanPostProcessor接口可以在Bean(实例化之后)初始化的前后做一些自定义的操作，但是拿到的参数只有BeanDefinition实例和BeanDefinition的名称，也就是无法修改BeanDefinition元数据,这里说的Bean的初始化是：</p><p>1）bean实现了InitializingBean接口，对应的方法为afterPropertiesSet</p><p>2）在bean定义的时候，通过init-method设置的方法</p><p>PS:BeanFactoryPostProcessor回调会先于BeanPostProcessor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// bean初始化前执行</span></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// bean初始化后执行</span></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC进阶使用</title>
      <link href="WindShadow/Spring/SpringMVC%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/"/>
      <url>WindShadow/Spring/SpringMVC%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Web-MVC相关"><a href="#Web-MVC相关" class="headerlink" title="Web MVC相关"></a>Web MVC相关</h1><p>根据官网文档介绍总结</p><h2 id="BindingResult"><a href="#BindingResult" class="headerlink" title="BindingResult"></a>BindingResult</h2><p>BindingResult作为控制层方法的参数时，它保存了该方法BindingResult之前的参数绑定的结果，和HttpServletRequest对象一样，来自SpringMVC“内部”，暂且称之为“内部参数”，其它需要通过请求参数去转换成java bean的参数称之为“外来参数”。</p><p>例：有5个mvc处理器（控制层的方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">xxxController</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/url0&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> xxx <span class="title">method0</span><span class="params">(User user,Dept dept)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"> <span class="meta">@RequestMapping(&quot;/url1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> xxx <span class="title">bindMethod1</span><span class="params">(User user,BindingResult bindingResult)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bindingResult.hasErrors()) &#123;</span><br><span class="line">            Map&lt;String , String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">     <span class="comment">// 遍历获取检验不通过的属性名以及抛出对应异常的message</span></span><br><span class="line">            bindingResult.getFieldErrors().forEach( (item) -&gt; &#123;</span><br><span class="line">                String message = item.getDefaultMessage();</span><br><span class="line">                String field = item.getField();</span><br><span class="line">                map.put( field , message );</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/url3&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> xxx <span class="title">bindMethod2</span><span class="params">(User user,Dept dept,BindingResult bindingResult)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">     <span class="meta">@RequestMapping(&quot;/url3&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> xxx <span class="title">bindMethod3</span><span class="params">(User user,BindingResult bindingResult,Dept dept)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">     <span class="meta">@RequestMapping(&quot;/url4&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> xxx <span class="title">integerMethod5</span><span class="params">(User user,Integer size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，method0都熟悉了，前端参数直接绑定，找不到的参数则直接为默认值，而当参数转换错误时，即前端传入了非数字的字符串， 而后端要转换成Integer类型，如{id : 123abc}要转换到User对象的id属性，此时mvc会抛出绑定参数相关的异常（<strong>BindException</strong> ，该异常可获取到BindingResult对象），此时前端便会收到400状态码的应答。</p><p>而在bindMethod1中，BindingResult对像则保存了mvc绑定user对象的结果：有无错误、错误的属性field和错误信息message等；因为处理器显式声明了BindingResult对像作为形参，所以上述由绑定异常导致的400错误不会发生，继续进入处理器方法执行业务。</p><ul><li>在bindMethod2和bindMethod3中，处理器需要绑定2个bean到实参，经验证执行过程如下：</li></ul><ol><li><p>从左到右先绑定User，若绑定失败则抛出参数绑定相关的异常</p></li><li><p>绑定User通过，绑定Dept失败，进入控制层方法，BindingResult保存id绑定结果</p></li><li><p>绑定都通过，进入控制层方法，BindingResult保存Dept绑定结果</p><p>故而得出：<strong>BindingResult保存的绑定结果是处理器（控制层的方法）最后一个bean参数的绑定结果【一对一绑定】</strong></p></li></ol><ul><li>在integerMethod5中，有一个普通数据类型的形参，如果对其转换失败时，mvc则直接抛出方法参数类型匹配异常（<strong>MethodArgumentTypeMismatchException</strong>），注意不是绑定异常。</li></ul><p>稍加思考不难得出，mvc处理器参数处理的简单流程：</p><p><img src="/WindShadow/Spring/SpringMVC%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/mvc%E7%BB%91%E5%AE%9A%E6%B5%81%E7%A8%8B.png" alt="mvc绑定流程"></p><p>当我们需要关心客户端传入bean参数的对错时，可以在处理器上使用BindingResult对象，不关心则不需要，直接让mvc自动返回400错误。一般情况下，很少使用BindingResult对象，BindingResult更多的是在参数绑定相关异常中作为绑定结果信息的载体，通过BindingResult先打一下mvc的基础。</p><h2 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="@ControllerAdvice"></a>@ControllerAdvice</h2><p>顾名思义，控制器增强，原理是AOP，结合控制层能干的事和AOP方可理解其作用，不多BB。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice(</span></span><br><span class="line"><span class="meta">    basePackageClasses = &#123;xxxController.class&#125;)</span><span class="comment">// 只切入指定的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandlerAdvice</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="InitBinder参数绑定"><a href="#InitBinder参数绑定" class="headerlink" title="@InitBinder参数绑定"></a>@InitBinder参数绑定</h2><h3 id="PropertyEditor"><a href="#PropertyEditor" class="headerlink" title="PropertyEditor"></a>PropertyEditor</h3><p>先了解这个，<a target="_blank" rel="noopener" href="https://blog.csdn.net/pentiumchen/article/details/44026575">PropertyEditor的使用和原理</a></p><p>@InitBinder可以实现参数绑定，将String类型的数据转换成对应的java对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitBinderController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/initBinder/date&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String str;</span><br><span class="line">        <span class="keyword">if</span> (date == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            str = <span class="string">&quot;date is null&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            str = date.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(str);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/initBinder/bigDecimal&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">(<span class="meta">@RequestParam(&quot;bigDecimal&quot;)</span> BigDecimal number)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String str;</span><br><span class="line">        <span class="keyword">if</span> (number == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            str = <span class="string">&quot;number is null&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">           str  = number.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(str);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InitBinder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBinder</span><span class="params">(WebDataBinder binder)</span> </span>&#123;</span><br><span class="line">        SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        dateFormat.setLenient(<span class="keyword">false</span>);</span><br><span class="line">        binder.registerCustomEditor(Date.class, <span class="keyword">new</span> CustomDateEditor(dateFormat, <span class="keyword">false</span>));</span><br><span class="line">        <span class="comment">// 注册自定义的 大小数转换器</span></span><br><span class="line">        binder.registerCustomEditor(BigDecimal.class,<span class="keyword">new</span> BigDecimalEditor());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>WebDataBinder实现了PropertyEditorRegistry接口，所以只需要注册CustomDateEditor解析器和自定义的大小数转换器（下见代码）就可以了。</p><p>自定义参数转换器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> WindShadow</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2020/9/20.</span></span><br><span class="line"><span class="comment"> * 大小数转换器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigDecimalEditor</span> <span class="keyword">extends</span> <span class="title">PropertyEditorSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsText</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line"></span><br><span class="line">        BigDecimal bigDecimal;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bigDecimal = BigDecimal.valueOf(Double.valueOf(text));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        setValue(bigDecimal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>简而言之@InitBinder：控制层方法参数映射，String =&gt; Java Object（一对一）</strong></p><p><strong>@ControllerAdvice + @InitBinder = 被增强的Controller都拥有共同的数据绑定器</strong></p><p>更详细的参数绑定原理的博客：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/yourbatman/p/11218694.html">https://www.cnblogs.com/yourbatman/p/11218694.html</a></p><h2 id="ExceptionHandler异常处理"><a href="#ExceptionHandler异常处理" class="headerlink" title="@ExceptionHandler异常处理"></a>@ExceptionHandler异常处理</h2><h3 id="几种异常处理方式"><a href="#几种异常处理方式" class="headerlink" title="几种异常处理方式"></a>几种异常处理方式</h3><p>先大致了解一下<a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenzhubing/p/11438902.html">百度上的3中异常处理方式</a></p><p>可得：大致有以下几种异常处理方式</p><ol><li>手动try-catch，自己返回对应视图或数据【原始操作，颗粒细，代码臃肿，分支多】</li><li>Controller + @ExceptionHandler【只能在当前控制器中处理异常】</li><li>BaseController + @ExceptionHandler + 继承【类似 2，但因为继承，具有统一异常处理能力】</li><li>实现 HandlerExceptionResolver 接口【可实现统一异常处理】</li><li> @ControllerAdvice + @ExceptionHandler 【AOP原理，可实现统一异常处理】</li></ol><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-exceptionhandler">@ExceptionHandler支持的参数和返回值类型</a>；</p><p>意思你在@ExceptionHandler的异常处理方法下的操作，类似在@RequestMapping方法下的操作，但是仅限于文档上指明的方法参数类型和返回值。和@RequestMapping一样，返回String依旧默认是视图名称，方法加上@ResponseBody就是json形式返回。</p><p>注意：方法参数为map等具有往视图添加数据的类型时，方法被调用时会报错</p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>既然在SpringMVC中有多种处理异常的方式，那么就存在一个优先级的问题：</p><p>当发生异常的时候，SpringMVC会如下处理：</p><p>（1）SpringMVC会先从配置文件找异常解析器HandlerExceptionResolver</p><p>（2）如果找到了异常异常解析器，那么接下来就会判断该异常解析器能否处理当前发生的异常</p><p>（3）如果可以处理的话，那么就进行处理，然后给前台返回对应的异常视图</p><p>（4）如果没有找到对应的异常解析器或者是找到的异常解析器不能处理当前的异常的时候，就看当前的Controller中有没有提供对应的异常处理器，如果提供了就由Controller自己进行处理并返回对应的视图</p><p>（5）如果配置文件里面没有定义对应的异常解析器，而当前Controller中也没有定义的话，就看有没有全局ControllerAdvice提供的全局异常处理器，如果没有那么该异常就会被抛出来</p><h2 id="Valid数据校验"><a href="#Valid数据校验" class="headerlink" title="@Valid数据校验"></a>@Valid数据校验</h2><p>前提了解：<a target="_blank" rel="noopener" href="https://developer.ibm.com/zh/articles/j-lo-jsr303/"><strong>JSR303数据校验</strong></a></p><h3 id="JSR303注解小细节"><a href="#JSR303注解小细节" class="headerlink" title="JSR303注解小细节"></a>JSR303注解小细节</h3><p>设定一个pojo，下面的字段中，如果前端没有传过来email字段，也就是得到User对象的email属性为null，这是允许的，等同于【选填，格式必须为邮箱】，如果在@Email上再加入@NotNull，即叠加校验，等同于【必填，格式必须为邮箱】，<strong>叠加校验校验顺序从上往下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@NotNull</span> <span class="comment">// 该字段不能为空</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">  <span class="comment">//  @NotNull // 注解可叠加使用</span></span><br><span class="line">    <span class="meta">@Email</span> <span class="comment">// 该字段必须是邮箱格式</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="控制层写法"><a href="#控制层写法" class="headerlink" title="控制层写法"></a>控制层写法</h3><h4 id="参数-BindingResult对象"><a href="#参数-BindingResult对象" class="headerlink" title="参数 + BindingResult对象"></a>参数 + BindingResult对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@RequestMapping(&quot;/url&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> xxx <span class="title">validTest1</span><span class="params">(<span class="meta">@Valid</span> User user,BindingResult bindingResult)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bindingResult.hasErrors()) &#123;</span><br><span class="line">            Map&lt;String , String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">     <span class="comment">// 遍历获取检验不通过的属性名以及抛出对应异常的message</span></span><br><span class="line">            bindingResult.getFieldErrors().forEach( (item) -&gt; &#123;</span><br><span class="line">                String message = item.getDefaultMessage();</span><br><span class="line">                String field = item.getField();</span><br><span class="line">                map.put( field , message );</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// …   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Valid 开启校验功能，紧跟在校验的Bean后添加一个BindingResult，BindingResult会封装前面Bean的校验结果，可见参数校验结果是被视为 参数校验结果的子集。这种处理器的写法缺点很明显，每个需要参数校验的地方都用 BindingResult 获取校验结果。冷门操作。</p><h4 id="结合-ExceptionHandler"><a href="#结合-ExceptionHandler" class="headerlink" title="结合@ExceptionHandler"></a>结合@ExceptionHandler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@RequestMapping(&quot;/url&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> xxx <span class="title">validTest1</span><span class="params">(<span class="meta">@Valid</span> User user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 正常业务...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ResponseStatus(value = HttpStatus.BAD_GATEWAY,reason = &quot;bind异常&quot;)</span><span class="comment">// 以此状态码作为最终响应状态码，若不配置，处理完异常后以正常的200响应</span></span><br><span class="line"><span class="meta">@ExceptionHandler(value = &#123;</span></span><br><span class="line"><span class="meta">    MethodArgumentNotValidException.class,// @RequestBody 参数映射验证失败抛出此类型异常</span></span><br><span class="line"><span class="meta">    BindException.class,// get、post等参数自动绑定到bean的请求方式时，验证失败抛出此类型异常</span></span><br><span class="line"><span class="meta">    ConstraintViolationException.class//  @RequestParam 参数映射验证失败抛出此类型异常</span></span><br><span class="line"><span class="meta"> &#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> xxx <span class="title">validErrEx</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> MethodArgumentNotValidException) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;MethodArgumentNotValidException&quot;</span>);</span><br><span class="line">        BindingResult bindingResult = ((MethodArgumentNotValidException)e).getBindingResult();</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> BindException) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;BindException&quot;</span>);</span><br><span class="line">        BindingResult bindingResult = ((BindException)e).getBindingResult();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ConstraintViolationException) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;ConstraintViolationException&quot;</span>);</span><br><span class="line">        Set&lt;ConstraintViolation&lt;?&gt;&gt; constraintViolationSet =((ConstraintViolationException)e).getConstraintViolations();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @ExceptionHandler注解限定了异常类型，此句不可能被执行到</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;未知异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据校验不起作用的写法"><a href="#数据校验不起作用的写法" class="headerlink" title="数据校验不起作用的写法"></a>数据校验不起作用的写法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@RequestMapping(&quot;/url&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> xxx <span class="title">validTest1</span><span class="params">(<span class="meta">@Valid</span> User user, <span class="meta">@Email</span> String emaill)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="meta">@RequestMapping(&quot;/url&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> xxx <span class="title">validTest2</span><span class="params">(<span class="meta">@Valid</span> User user, <span class="meta">@Valid</span> <span class="meta">@Email</span> String email)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>直接验证基本数据类型是无效的；</strong>可以这样理解：@Valid作用于bean上，表示对此bean开启JSR303数据检验，bean中所有被JSR303注解作用的属性都会被检验。</p><h4 id="多参数验证顺序"><a href="#多参数验证顺序" class="headerlink" title="多参数验证顺序"></a>多参数验证顺序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/url&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> xxx <span class="title">validTest1</span><span class="params">(<span class="meta">@Valid</span> User user, <span class="meta">@Valid</span> Dept dept)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和参数绑定一样，验证顺序从左到右，由此可见<strong>参数校验属于参数绑定的子过程</strong>。</p><h2 id="Validated数据校验"><a href="#Validated数据校验" class="headerlink" title="@Validated数据校验"></a>@Validated数据校验</h2><p>@Valid是java的注解（javax.validation包下），@Validated是Spring的注解，Spring对@Validated的功能支持包含了@Valid的支持，即在Spring环境中，@Valid能干的@Validated都能干，所以在控制层的数据校验时，也可用@Validated代替@Valid。另外Spring对@Validated提供了分组校验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Validated &#123;</span><br><span class="line">    Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h3><p>场景：User bean在新增操作时，id要为空，更新操作时id不能为空。@Valid没有分组功能，@Validated拥有分组功能。</p><p>建立分组类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Group</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Insert</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Update</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>User bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验时分组</span></span><br><span class="line">  <span class="meta">@Null(groups = &#123;Group.Insert.class&#125;)</span></span><br><span class="line">    <span class="meta">@NotNull(groups = &#123;Group.Insert.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制层写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/url&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> xxx <span class="title">addUser</span><span class="params">(<span class="meta">@Validated(Group.Insert.class)</span> User user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 正常业务...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义校验注解"><a href="#自定义校验注解" class="headerlink" title="自定义校验注解"></a>自定义校验注解</h3><p>实现类似上述@Email @Null的检验注解，以行数据逻辑删除属性为例</p><p>行数据类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RowData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer DELETED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer NOT_DELETED = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@MyDeletedCodeValidated</span></span><br><span class="line">    <span class="keyword">private</span> Integer deleted;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getDeleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deleted;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDeleted</span><span class="params">(Integer deleted)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.deleted = deleted;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;RowData&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;deleted=&quot;</span> + deleted +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>校验注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;FIELD, ANNOTATION_TYPE, PARAMETER&#125;)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示处理的这个注解的类是哪一个，可以是多个</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = MyConstraintValidator.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyDeletedCodeValidated &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下面的这俩是必须的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理检验注解的类，必须实现ConstraintValidator接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConstraintValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">MyDeletedCodeValidated</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(MyDeletedCodeValidated constraintAnnotation)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.message = constraintAnnotation.message();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(Integer code, ConstraintValidatorContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!RowData.DELETED.equals(code) &amp;&amp; !RowData.NOT_DELETED.equals(code)) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 禁用默认的消息模板</span></span><br><span class="line">           context.disableDefaultConstraintViolation();</span><br><span class="line">           <span class="comment">// 设置自己的消息模板</span></span><br><span class="line">           context.buildConstraintViolationWithTemplate(<span class="string">&quot;&quot;</span>.equals(message) ? <span class="string">&quot;删除代号只能为0或1&quot;</span> : message)</span><br><span class="line">                   .addConstraintViolation();</span><br><span class="line">           <span class="comment">//不合法，不通过</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制层直接使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@RequestMapping(&quot;/rowData&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">rowDataValidated</span><span class="params">(<span class="meta">@Validated</span> RowData rowData)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rowData == <span class="keyword">null</span> ? <span class="string">&quot;null&quot;</span> : rowData.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义校验器"><a href="#自定义校验器" class="headerlink" title="自定义校验器"></a>自定义校验器</h3><p>定义一个Gender类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAN = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WOMAN = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Gender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Gender</span><span class="params">(Integer code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(Integer code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现对应的校验器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对&#123;<span class="doctag">@link</span> Gender&#125;类的校验器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> WindShadow</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2021-10-21.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenderValidator</span> <span class="keyword">implements</span> <span class="title">Validator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Gender.class.equals(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(Object target, Errors errors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ValidationUtils.rejectIfEmpty(errors,<span class="string">&quot;code&quot;</span>,<span class="string">&quot;code is empty&quot;</span>);</span><br><span class="line">        Gender gender = (Gender) target;</span><br><span class="line">        <span class="keyword">if</span> (Gender.MAN != gender.getCode() &amp;&amp; Gender.WOMAN != gender.getCode()) &#123;</span><br><span class="line"></span><br><span class="line">            errors.reject(String.format(<span class="string">&quot;性别代码只能为%s = 男，%s = 女&quot;</span>,<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制层注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/gender&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">genderValidated</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@RequestBody</span> Gender gender)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> gender == <span class="keyword">null</span> ? <span class="string">&quot;null&quot;</span> : gender.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@InitBinder(&quot;gender&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBinder</span><span class="params">(WebDataBinder binder)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   binder.addValidators(<span class="keyword">new</span> GenderValidator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MatrixVariable-矩阵变量"><a href="#MatrixVariable-矩阵变量" class="headerlink" title="@MatrixVariable 矩阵变量"></a>@MatrixVariable 矩阵变量</h2><p> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/panchanggui/p/9436348.html">RFC3986</a>定义了在URI中包含name-value的规范 。</p><p>使用@MatrixVariable可以方便的进行多条件组合查询</p><h3 id="开启矩阵变量功能"><a href="#开启矩阵变量功能" class="headerlink" title="开启矩阵变量功能"></a>开启矩阵变量功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 矩阵变量配置,关键类UrlPathHelper</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configurePathMatch</span><span class="params">(PathMatchConfigurer configurer)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        UrlPathHelper urlPathHelper = <span class="keyword">new</span> UrlPathHelper();</span><br><span class="line">        urlPathHelper.setRemoveSemicolonContent(<span class="keyword">false</span>);<span class="comment">// 必须 false</span></span><br><span class="line">        configurer.setUrlPathHelper(urlPathHelper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">enable-matrix-variables</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>官方例子：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/web.html#mvc-ann-matrix-variables">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/web.html#mvc-ann-matrix-variables</a></p><ol><li><p>handler入参为Map&lt;String,String&gt; 和 Map&lt;String,List<String></String></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MatrixController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// /matrix/user/userls;id=100;name=ls;age=18;address=nj/com/alibaba;id=1001;address=hz;dept=dept001,dept002</span></span><br><span class="line">    <span class="comment">// /matrix/user/userls;id=100;name=ls;age=18;address=nj/com/alibaba;id=1001;address=hz;dept=dept001;dept=dept002</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/matrix/user/&#123;user&#125;/com/&#123;com&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">matrix1</span><span class="params">(<span class="meta">@PathVariable(&quot;user&quot;)</span> String user, <span class="meta">@PathVariable(&quot;com&quot;)</span> String com,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="meta">@MatrixVariable(pathVar = &quot;user&quot;)</span> Map&lt;String,String&gt; userInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="meta">@MatrixVariable(pathVar = &quot;com&quot;)</span> Map&lt;String,List&lt;String&gt;&gt; comInfo)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> user + <span class="string">&quot;\n&quot;</span> + com + <span class="string">&quot;\n&quot;</span> + JSON.toJSONString(userInfo) + <span class="string">&quot;\n&quot;</span> + JSON.toJSONString(comInfo);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 返回结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">userls</span><br><span class="line">alibaba</span><br><span class="line">&#123;<span class="attr">&quot;id&quot;</span>:<span class="string">&quot;100&quot;</span>,<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;ls&quot;</span>,<span class="attr">&quot;age&quot;</span>:<span class="string">&quot;18&quot;</span>,<span class="attr">&quot;address&quot;</span>:<span class="string">&quot;nj&quot;</span>&#125;</span><br><span class="line">&#123;<span class="attr">&quot;id&quot;</span>:[<span class="string">&quot;1001&quot;</span>],<span class="attr">&quot;address&quot;</span>:[<span class="string">&quot;hz&quot;</span>],<span class="attr">&quot;dept&quot;</span>:[<span class="string">&quot;dept001&quot;</span>,<span class="string">&quot;dept002&quot;</span>]&#125;</span><br></pre></td></tr></table></figure></li><li><p>handler入参为普通简单类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MatrixController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// /matrix2/user/userls;id=100;name=ls;age=18;address=nj</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/matrix2/user/&#123;user&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">matrix2</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@MatrixVariable(pathVar = &quot;user&quot;,name = &quot;name&quot;)</span> String name,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@MatrixVariable(pathVar = &quot;user&quot;,name = &quot;age&quot;)</span> Integer age,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@MatrixVariable(pathVar = &quot;user&quot;,name = &quot;id&quot;)</span> Integer id,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@MatrixVariable(pathVar = &quot;user&quot;,name = &quot;address&quot;)</span> String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot;\n&quot;</span> + age + <span class="string">&quot;\n&quot;</span> + id + <span class="string">&quot;\n&quot;</span> + address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line">nj</span><br></pre></td></tr></table></figure></li><li><p>URL + ? + 参数</p><p>对比 2 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MatrixController</span> </span>&#123;</span><br><span class="line">     <span class="comment">// /matrix2/user/userls;id=100;name=ls;age=18;address=nj?car=lbjn</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/matrix3/user/&#123;user&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">matrix3</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@MatrixVariable(pathVar = &quot;user&quot;,name = &quot;name&quot;)</span> String name,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@MatrixVariable(pathVar = &quot;user&quot;,name = &quot;age&quot;)</span> Integer age,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@MatrixVariable(pathVar = &quot;user&quot;,name = &quot;id&quot;)</span> Integer id,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@MatrixVariable(pathVar = &quot;user&quot;,name = &quot;address&quot;)</span> String address,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@RequestParam</span> String car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot;\n&quot;</span> + age + <span class="string">&quot;\n&quot;</span> + id + <span class="string">&quot;\n&quot;</span> + address + <span class="string">&quot;\n&quot;</span> + car;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line">nj</span><br><span class="line">lbjn</span><br></pre></td></tr></table></figure></li></ol><h3 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h3><ol><li>显然的，如url = <u>/matrix/user/userls;id=100;name=ls;age=18;address=nj/com/alibaba;id=1001;address=hz;dept=dept001,dept002</u>。分号开始的地方当作一个矩阵，遇到一些非矩阵符号（如 / 或 ? ，它们是正常url里有特别意义的字符）时，矩阵视为结束。</li><li>URL格式<ul><li>dept=dp01;dept=dp02 等价于 dept=dp01,dp02</li><li> <u>/matrix3/user/userls;?car=lbjn</u> 此种格式绑定到 @PathVariable(“user”) String user  参数时，user值为 userls; </li><li> <u>/matrix3/user/userls;age=18;?car=lbjn</u> 和  <u>/matrix3/user/userls;age=18?car=lbjn</u> 这两种格式的差别在 ? 之前的分号，但是他们都能正常绑定到参数。即 age 值为 18 而不是 18; </li></ul></li><li>根据 1 2可知，如url = <u>/matrix3/user/userls;?car=lbjn</u>处理器有@PathVariable(“user”) String user。矩阵user并不被认为存在，所以矩阵参数开始的字符是分号 <em>；</em> 。这一点不注意可能会被误导。</li><li>@MatrixVariable(pathVar = “user”,name = “name”)中，显然 pathVar 代表参数所在的矩阵，只有一个矩阵时也可省略</li><li>@MatrixVariable(required = false)表示此参数可以不存在，即required属性控制参数是否必填</li><li>@MatrixVariable(defaultValue = “value”)，通过defaultValue属性表示缺省值</li><li>使用@MatrixVariable后，传入分号作为参数值时需要转义编码啥的，具体转义规则啥的看RFC3986来吧，目前百度上也没看到有个完美可行的说法，可能大多数人矩阵变量用的不是也别多，个人感觉挺方便的</li></ol><h2 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h2><p>@ModelAttribute注解用于将方法的参数或方法的返回值绑定到指定的模型属性上，并返回给Web视图。被@ModelAttribute注解注释的方法会在此controller每个handler方法（处理器）执行前被执行，因此对于一个controller映射多个URL的用法来说，要谨慎使用。</p><ol><li><p>例A：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelAttributeController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modelVoid</span><span class="params">(Model model)</span> </span>&#123;<span class="comment">// 返回值为void时，入参没有 Model类型会报错</span></span><br><span class="line"></span><br><span class="line">        model.addAttribute(<span class="string">&quot;void&quot;</span>,<span class="string">&quot;voidString&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@ModelAttribute(&quot;@ModelAttributeKey&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">model</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;@ModelAttributeValue&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/modelAttribute&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;modelData: &#123;&#125;&quot;</span>, JSON.toJSON(model.asMap()));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;show&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modelData: &#123;&quot;@ModelAttributeKey&quot;:&quot;@ModelAttributeValue&quot;,&quot;void&quot;:&quot;voidString&quot;&#125;</span><br></pre></td></tr></table></figure></li><li><p>例B</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelAttributeController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modelVoid</span><span class="params">(Model model)</span> </span>&#123;<span class="comment">// 返回值为void时，入参没有 Model类型会报错</span></span><br><span class="line"></span><br><span class="line">        model.addAttribute(<span class="string">&quot;void&quot;</span>,<span class="string">&quot;voidString&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="meta">@RequestMapping(value = &quot;/modelAttribute3&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show3</span><span class="params">(<span class="meta">@ModelAttribute(&quot;void&quot;)</span> String voidString)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;voidString: &#123;&#125;&quot;</span>,voidString);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;show&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">voidString: voidString</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>例C</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelAttributeController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 此时 user 来自前端 User必须有无参构造</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/addUser&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show3</span><span class="params">(<span class="meta">@ModelAttribute(&quot;void&quot;)</span> User user)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;user: &#123;&#125;&quot;</span>,user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;show&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>例D</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelAttributeController</span> </span>&#123;  </span><br><span class="line"><span class="comment">// 此时，@RequestMapping内的value表示视图名称，即 show</span></span><br><span class="line">    <span class="comment">// 请求此url后，后端将渲染 show 的视图页面并返回，该视图的 model有键值对 attributeName=hi</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/show&quot;)</span></span><br><span class="line">    <span class="meta">@ModelAttribute(&quot;attributeName&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="RequestAttribute"><a href="#RequestAttribute" class="headerlink" title="@RequestAttribute"></a>@RequestAttribute</h2><p>参照@ModelAttribute的使用，只不过数据放的域不同，此时数据存放于request域，即 request.setAttribute()</p><h2 id="SessionAttribute"><a href="#SessionAttribute" class="headerlink" title="@SessionAttribute"></a>@SessionAttribute</h2><p>参照@ModelAttribute的使用，只不过数据放的域不同，此时数据存放于session域，即 session.setAttribute()</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nginx初入江湖</title>
      <link href="WindShadow/Nginx/Nginx%E5%88%9D%E5%85%A5%E6%B1%9F%E6%B9%96/"/>
      <url>WindShadow/Nginx/Nginx%E5%88%9D%E5%85%A5%E6%B1%9F%E6%B9%96/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx简单入门"><a href="#Nginx简单入门" class="headerlink" title="Nginx简单入门"></a>Nginx简单入门</h1><p>软件位置，不同安装方式可能不同，一般如下：</p><ul><li>docker容器：/usr/sbin/nginx</li><li>centos：/usr/local/nginx/sbin </li></ul><p>配置环境变量即可在任意地方使用nginx命令</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>默认已经配置环境变量</p><ul><li><p>启动与关闭</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nginx    # 启动</span><br><span class="line">nginx -s reload            # 重新载入配置文件，热部署、热加载</span><br><span class="line">nginx -s reopen            # 重启 Nginx</span><br><span class="line">nginx -s stop              # 停止 Nginx</span><br></pre></td></tr></table></figure></li><li><p>检查配置文件nginx.conf的正确性命令 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure></li><li><p>查看版本号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -v</span><br></pre></td></tr></table></figure></li><li><p>第三方模块安装主要命令解释<br>查看已经有的模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -V # 大写V</span><br></pre></td></tr></table></figure><p>nginx第三方模块安装方法 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/你的安装目录  --add-module=/第三方模块目录</span><br></pre></td></tr></table></figure></li></ul><h2 id="Nginx配置文件"><a href="#Nginx配置文件" class="headerlink" title="Nginx配置文件"></a>Nginx配置文件</h2><p>nginx配置文件可以引入其它配置文件，即include操作</p><h3 id="配置文件位置"><a href="#配置文件位置" class="headerlink" title="配置文件位置"></a>配置文件位置</h3><ul><li>docker容器：/etc/nginx/nginx.conf</li><li>centos：/usr/local/nginx/conf/nginx.conf</li></ul><h3 id="配置文件构成"><a href="#配置文件构成" class="headerlink" title="配置文件构成"></a>配置文件构成</h3><p>官方初始的配置文件</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span>  nginx;</span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">error_log</span>  /var/log/nginx/error.log <span class="literal">warn</span>;</span><br><span class="line"><span class="attribute">pid</span>        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line">        <span class="comment">#access_log  /var/log/nginx/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;<span class="comment"># 引入其它配置文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构成如下：</p><ol><li><p>全局块</p><p>文件开始到events块之前的内容，配置影响nginx整体运行的指令；<br>如worker_processes是nginx服务器处理并发服务的关键配置，值越大能力越强（还得看硬件配置）；</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>; <span class="comment"># 可设置值和CPU核心数一致</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment"># worker_processes auto; # 可设置为auto</span></span><br><span class="line">   </span><br><span class="line">   <span class="attribute">error_log</span>  /var/log/nginx/error.log <span class="literal">warn</span>; <span class="comment"># 日志存放位置</span></span><br><span class="line">   </span><br><span class="line">   <span class="attribute">pid</span>        /var/run/nginx.pid;<span class="comment"># 进程id，不用管</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>events块<br>events 块涉及的指令主要影响Nginx 服务器与用户的网络连接</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">worker_connections</span>  <span class="number">1024</span>; <span class="comment"># worker进程支持的最大连接数</span></span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>http块。<ol><li>http全局块（server块之前）<br>http 全局块配置的指令包括文件引入、MIME-TYPE定义、日志自定义、连接超时时间、单链接请求数上限等<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="section">http</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span>       /etc/nginx/mime.types;<span class="comment">#include代表引入一个外部的文件 -&gt;/minle.types中放着大量的媒体类型</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream; <span class="comment"># 默认类型</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;&#125; <span class="comment"># server块</span></span><br><span class="line"><span class="comment"># include /etc/nginx/conf. d/*.conf; -〉引入了conf.d目录下的以.conf为结尾的配置文件</span></span><br><span class="line"><span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>server块（主要关注此处）<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment"># server块</span></span><br><span class="line">     </span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>; <span class="comment">#监听端口</span></span><br><span class="line">     </span><br><span class="line">        <span class="attribute">server_name</span>  localhost;<span class="comment"># 域名</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line">        <span class="comment">#access_log  /var/log/nginx/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;<span class="comment"># 匹配的url的规则</span></span><br><span class="line">   <span class="comment">#root:将接收到的请求根据/usr/share/nginx/html去查找静态资源</span></span><br><span class="line">            <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">            <span class="comment">#index:默认去上述的路径中找到index.html或者index. htm</span></span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>主要修改Http Server块的配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123; <span class="comment"># server块</span></span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>; <span class="comment">#监听端口</span></span><br><span class="line">        <span class="attribute">server_name</span>  <span class="number">192.168.100.100</span>;<span class="comment"># 域名（一个主机可能有多个域名）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配到 /app1 走 http://200.0.0.1:8081</span></span><br><span class="line">        <span class="attribute">location</span> /app1 &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://200.0.0.1:8081;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 匹配到 /app2 走 http://200.0.0.1:8082</span></span><br><span class="line">        <span class="attribute">location</span> /app2 &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://200.0.0.1:8082; </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line"><span class="attribute">upstream</span> myServer &#123; <span class="comment"># 加入 upstream ,服务名 myServer</span></span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.0.100:9001</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.0.100:9002</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123; <span class="comment"># server块</span></span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>; <span class="comment">#监听端口</span></span><br><span class="line">        <span class="attribute">server_name</span>  <span class="number">192.168.100.100</span>;<span class="comment"># 域名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配到 /app1 走 http://myServer</span></span><br><span class="line">        <span class="attribute">location</span> /app1 &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://myServer;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="负载均衡策略："><a href="#负载均衡策略：" class="headerlink" title="负载均衡策略："></a>负载均衡策略：</h3><ul><li><p>轮询（默认）;按照时间顺序分配请求，其中一台服务器挂掉时自动剔除</p></li><li><p>权重 weight；默认权重为 1，权重越高得到的请求越多</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> myServer &#123; <span class="comment"># 加入 upstream ,服务名 myServer</span></span><br><span class="line">  </span><br><span class="line">           <span class="attribute">server</span> <span class="number">192.168.0.100:9001</span> weight = <span class="number">5</span>;<span class="comment"># 权重为 5 </span></span><br><span class="line">  </span><br><span class="line">           <span class="attribute">server</span> <span class="number">192.168.0.100:9002</span> weight = <span class="number">10</span>;<span class="comment"># 权重为 10</span></span><br><span class="line">  </span><br><span class="line">   &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li></ul><ul><li><p>IP hash；每个请求按访问ip的hash结果分配,这样每个访客固定访问一个后端服务器，可以解决session的问题。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> myServer &#123; <span class="comment"># 加入 upstream ,服务名 myServer</span></span><br><span class="line"></span><br><span class="line">    ip_hash</span><br><span class="line"></span><br><span class="line">            <span class="attribute">server</span> <span class="number">192.168.0.100:9001</span>;</span><br><span class="line"></span><br><span class="line">            <span class="attribute">server</span> <span class="number">192.168.0.100:9002</span> ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>fair；按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> myServer &#123; <span class="comment"># 加入 upstream ,服务名 myServer</span></span><br><span class="line">  </span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.100:9001</span>;</span><br><span class="line">  </span><br><span class="line">       <span class="attribute">server</span> <span class="number">192.168.0.100:9002</span>;</span><br><span class="line">  </span><br><span class="line">       fair</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p>Nginx动静分离简单来说就是把动态请求跟静态请求分开，不能理解成只是单纯的把动态页面和静态页面物理分离。严格意义上说应该是动态请求跟静态请求分开，可以理解成使用Nginx处理静态页面，Tomcat处理动态页面。动静分离从目前实现角度来讲大致分为两种：一种是纯粹把静态文件独立成单独的域名,放在独立的服务器上,也是目前主流推崇的方案；另外一种方法就是动态跟静态文件混合在一起发布，通过Nginx来分开。</p><p>通过location 指定不同的后缀名实现不同的请求转发。通过 expires（过期）参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。具体Expires定义:是给一个资源设定一个过期时间,也就是说无需去服务端验证,直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，不建议使用expires来缓存），设置3d，表示在这3天之内访问这个URL，发送一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码304，如果有修改，则直接从服务器重新下载，返回状态码200。</p><p>配置</p><ul><li><p>假设有文件 /mypath/image/a.png</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123; <span class="comment"># server块</span></span><br><span class="line">  </span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>; <span class="comment">#监听端口</span></span><br><span class="line">  </span><br><span class="line">         <span class="attribute">server_name</span>  <span class="number">192.168.100.100</span>;<span class="comment"># 域名</span></span><br><span class="line">  </span><br><span class="line">         <span class="comment"># 匹配到 /image</span></span><br><span class="line">  </span><br><span class="line">         <span class="attribute">location</span> /image/ &#123;</span><br><span class="line">  </span><br><span class="line">           <span class="attribute">root</span>   /mypath/; <span class="comment"># 去此目录下找对应文件</span></span><br><span class="line">  </span><br><span class="line">           <span class="attribute">autoindex</span> <span class="literal">on</span>; <span class="comment"># 列出当前目录下的文件及文件夹</span></span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>访问 192.168.100.100/image 则得到一个类似ftp的页面，列出/mypath/static/image文件夹下的文件（因为配置了 autoindex on;）；<br>访问 192.168.100.100/image/a.png 则得到一张图片，即 /mypath + /image/a.png ；</p></li></ul><p>其它动态请求进行代理配置即可。</p><h2 id="Server块location入门"><a href="#Server块location入门" class="headerlink" title="Server块location入门"></a>Server块location入门</h2><p>匹配类型</p><ol><li><p>= 精准匹配</p>   <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> = /xxx &#123;</span><br><span class="line"><span class="comment">#精准匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   例</p>   <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> = /app &#123;      </span><br><span class="line"></span><br><span class="line">   <span class="attribute">proxy_pass</span> http://127.0.0.1:8082/demo;</span><br><span class="line"><span class="comment"># /app -&gt; http://127.0.0.1:8082/demo</span></span><br><span class="line"><span class="comment"># /app?name=abc -&gt; http://127.0.0.1:8082/demo?name=abc</span></span><br><span class="line"><span class="comment"># /app/userService -&gt; http://127.0.0.1:8082/demo/userService</span></span><br><span class="line"><span class="comment"># /app/ -&gt; 匹配不到</span></span><br><span class="line"><span class="comment"># /app+++ -&gt; 匹配不到</span></span><br><span class="line"><span class="comment"># 精准匹配，可携带query参数</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>通用匹配</p>   <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /xxx&#123;</span><br><span class="line"><span class="comment">#匹配所有以/xxx开头的路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   例</p>   <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /app &#123;      </span><br><span class="line"><span class="attribute">proxy_pass</span> http://127.0.0.1:8082/demo;</span><br><span class="line"><span class="comment"># /app?name=ls -&gt; http://127.0.0.1:8082/demo?name=ls</span></span><br><span class="line"><span class="comment"># /app/ -&gt; http://127.0.0.1:8082/demo/</span></span><br><span class="line"><span class="comment"># /app+++ -&gt; http://127.0.0.1:8082/demo+++</span></span><br><span class="line"><span class="comment"># 即拼接操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>正则匹配</p>   <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ xxx</span> &#123; </span><br><span class="line"><span class="comment"># xxx是一个正则表达式</span></span><br><span class="line"><span class="comment"># ~ 符告诉nginx：xxx是一个正则表达式不是一个普通的字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   例</p>   <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="section">server</span> &#123;</span><br><span class="line">   <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">   <span class="attribute">server_name</span>  <span class="number">127.0.0.1</span>;</span><br><span class="line">   <span class="attribute">location</span> <span class="regexp">~ (/ggg)</span>&#123;</span><br><span class="line">    <span class="comment"># 匹配包含 /ggg 字符串的url， 匹配到的值为 /ggg </span></span><br><span class="line">    <span class="comment"># 第一个匹配到的值为$1，值即为 /ggg </span></span><br><span class="line">        <span class="comment"># 代理到 http://127.0.0.1:8082/demo/ggg</span></span><br><span class="line">   <span class="attribute">proxy_pass</span> http://127.0.0.1:8082/demo<span class="variable">$1</span>; </span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment"># 即 $ 后的数字表示正则匹配到的内容的索引，从1开始，且代理地址proxy_pass必须使用其中之一</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>匹配开头路径</p>   <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span><span class="regexp"> ^~</span> /images/ &#123;</span><br><span class="line"><span class="comment"># 匹配所有以/images/开头的路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   例</p>   <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span><span class="regexp"> ^~</span> /static/ &#123;         </span><br><span class="line"><span class="attribute">proxy_pass</span> http://127.0.0.1:8082/demo;</span><br><span class="line"><span class="comment"># /static/aaa -&gt; http://127.0.0.1:8082/demo/aaa</span></span><br><span class="line"><span class="comment"># 即拼接操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>匹配后缀</p>   <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~* .</span> (gifl jpglpng)$ &#123;</span><br><span class="line"><span class="comment"># 匹配以gif或者jpg或者png为结尾的路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>正则匹配注意点：</p><ul><li>~ 代表进行正则时区分大小写</li><li>~* 代表进行正则时不区分大小写</li></ul><p>优先级：</p><p><code>(location = ) &gt; (location /xxx/yyy/zzz) &gt; (location ^~) &gt; (location ~，~*) &gt; (location /起始路径) &gt; (location /)</code></p><h1 id="Nginx更进一步"><a href="#Nginx更进一步" class="headerlink" title="Nginx更进一步"></a>Nginx更进一步</h1><h2 id="Nginx变量"><a href="#Nginx变量" class="headerlink" title="Nginx变量"></a>Nginx变量</h2><p>Nginx的配置文件使用的就是一门微型的编程语言，变量说白了就是存放“值”的容器。而所谓“值”，在许多编程语言里，既可以是3.14这样的数值，也可以是 hello world 这样的字符串，甚至可以是像数组、哈希表这样的复杂数据结构。然而在 Nginx 配置中，变量只能存放一种类型的值，因为也只存在一种类型的值，那就是字符串。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">set</span> $a <span class="string">&quot;hello world&quot;</span>;</span><br></pre></td></tr></table></figure><p>所有的 Nginx 变量在 Nginx 配置文件中引用时都须带上 $ 前缀，直接把变量嵌入到字符串常量中以构造出新的字符串：</p><p>变量插值</p><p>关键在于引号</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line">$tt=&quot;123&quot; </span><br><span class="line"><span class="attribute">print</span> <span class="string">&#x27;this is $tt.&#x27;</span>; <span class="comment"># this is $tt.</span></span><br><span class="line"><span class="attribute">print</span> <span class="string">&quot;this is $tt.&quot;</span>; <span class="comment"># this is 123.</span></span><br><span class="line"><span class="comment"># 2 </span></span><br><span class="line"><span class="attribute">set</span> $a hello;</span><br><span class="line"><span class="attribute">set</span> $b <span class="string">&quot;$a, $a&quot;</span>; <span class="comment"># hello， hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 获取美元符$</span></span><br><span class="line"><span class="attribute">geo</span> $dollar &#123; <span class="comment"># 借助geo模块定义变量</span></span><br><span class="line">    <span class="attribute">default</span> <span class="string">&quot;$&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line">    <span class="attribute">location</span> /test &#123;</span><br><span class="line">        <span class="attribute">echo</span> <span class="string">&quot;This is a dollar sign: $dollar&quot;</span>; <span class="comment"># This is a dollar sign: $</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用花括号</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attribute">location</span> /test-brace &#123;</span><br><span class="line">        <span class="attribute">set</span> $first <span class="string">&quot;hello &quot;</span>;</span><br><span class="line">        <span class="attribute">echo</span> <span class="string">&quot;<span class="variable">$&#123;first&#125;</span>world&quot;</span>; <span class="comment"># hello world</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变量生命周期"><a href="#变量生命周期" class="headerlink" title="变量生命周期"></a>变量生命周期</h3><p>Nginx 变量的创建和赋值操作发生在全然不同的时间阶段。Nginx 变量的创建只能发生在 Nginx 配置加载的时候，或者说 Nginx 启动的时候；而赋值操作则只会发生在请求实际处理的时候。这意味着不创建而直接使用变量会导致启动失败，同时也意味着我们无法在请求处理时动态地创建新的 Nginx 变量。我们无法在请求处理时动态地创建新的 Nginx 变量。</p><p>Nginx 变量名的可见范围虽然是整个配置，但每个请求都有所有变量的独立副本，或者说都有各变量用来存放值的容器的独立副本，彼此互不干扰。比如前面我们请求了/bar接口后，$foo变量被赋予了值32，但它丝毫不会影响后续对/foo接口的请求所对应的foo值（它仍然是空的！），因为各个请求都有自己独立的foo变量的副本。</p><p>Nginx 变量理解成某种在请求之间全局共享的东西，或者说“全局变量”。而事实上，Nginx 变量的生命期是不可能跨越请求边界的</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line">        <span class="attribute">location</span> /foo &#123;</span><br><span class="line">            <span class="attribute">echo</span> <span class="string">&quot;foo = [$foo]&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">location</span> /bar &#123;</span><br><span class="line">            <span class="attribute">set</span> $foo <span class="number">32</span>;</span><br><span class="line">            <span class="attribute">echo</span> <span class="string">&quot;foo = [$foo]&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求</span></span><br><span class="line">$ curl &#x27;http://localhost:8080/bar&#x27;</span><br><span class="line"><span class="attribute">foo</span> = [<span class="number">32</span>]</span><br><span class="line">$ curl <span class="string">&#x27;http://localhost:8080/foo&#x27;</span></span><br><span class="line">foo = []</span><br></pre></td></tr></table></figure><p>简而言之，nginx的全局变量生命周期是和请求的生命周期一致，每个子请求有自己的全局变量。 </p><h3 id="Nginx内置变量"><a href="#Nginx内置变量" class="headerlink" title="Nginx内置变量"></a>Nginx内置变量</h3><p>在配置基于nginx服务器的网站时，必然会用到 nginx内置变量。内置变量存放在  ngx_http_core_module 模块中，变量的命名方式和apache 服务器变量是一致的。总而言之，这些变量代表着客户端请求头的内容，例如$http_user_agent, $http_cookie, 等等。下面是nginx支持的所有内置变量：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">$arg_name # 请求中的的参数名，即“?”后面的arg_name=arg_value形式的arg_name</span><br><span class="line">$args # 请求中的参数值</span><br><span class="line">$binary_remote_addr # 客户端地址的二进制形式, 固定长度为4个字节</span><br><span class="line">$body_bytes_sent # 传输给客户端的字节数，响应头不计算在内；这个变量和Apache的mod_log_config模块中的“%B”参数保持兼容</span><br><span class="line">$bytes_sent # 传输给客户端的字节数 (1.3.8, 1.2.5)</span><br><span class="line">$connection # TCP连接的序列号 (1.3.8, 1.2.5)</span><br><span class="line">$connection_requests # TCP连接当前的请求数量 (1.3.8, 1.2.5)</span><br><span class="line">$content_length # “Content-Length” 请求头字段</span><br><span class="line">$content_type # “Content-Type” 请求头字段</span><br><span class="line">$cookie_name # cookie名称</span><br><span class="line">$document_root # 当前请求的文档根目录或别名</span><br><span class="line">$document_uri # 同 $uri</span><br><span class="line">$host # 优先级如下：HTTP请求行的主机名&gt;”HOST”请求头字段&gt;符合请求的服务器名</span><br><span class="line">$hostname # 主机名</span><br><span class="line">$http_name # 匹配任意请求头字段； 变量名中的后半部分“name”可以替换成任意请求头字段，如在配置文件中需要获取http请求头：“Accept-Language”，那么将“－”替换为下划线，大写字母替换为小写，形如：$http_accept_language即可。</span><br><span class="line">$https # 如果开启了SSL安全模式，值为“on”，否则为空字符串。</span><br><span class="line">$is_args # 如果请求中有参数，值为“?”，否则为空字符串。</span><br><span class="line">$limit_rate # 用于设置响应的速度限制，详见 limit_rate</span><br><span class="line">$msec # 当前的Unix时间戳 (1.3.9, 1.2.6)</span><br><span class="line">$nginx_version # nginx版本</span><br><span class="line">$pid # 工作进程的PID</span><br><span class="line">$pipe # 如果请求来自管道通信，值为“p”，否则为“.” (1.3.12, 1.2.7)</span><br><span class="line">$proxy_protocol_addr # 获取代理访问服务器的客户端地址，如果是直接访问，该值为空字符串。(1.5.12)</span><br><span class="line">$query_string # 同 $args</span><br><span class="line">$realpath_root # 当前请求的文档根目录或别名的真实路径，会将所有符号连接转换为真实路径。</span><br><span class="line">$remote_addr # 客户端地址</span><br><span class="line">$remote_port # 客户端端口</span><br><span class="line">$remote_user # 用于HTTP基础认证服务的用户名</span><br><span class="line">$request # 代表客户端的请求地址</span><br><span class="line">$request_body # 客户端的请求主体，此变量可在location中使用，将请求主体通过proxy_pass, fastcgi_pass, uwsgi_pass, 和 scgi_pass传递给下一级的代理服务器。</span><br><span class="line">$request_body_file # 将客户端请求主体保存在临时文件中。文件处理结束后，此文件需删除。如果需要之一开启此功能，需要设置client_body_in_file_only。如果将次文件传递给后端的代理服务器，需要禁用request body，即设置proxy_pass_request_body off，fastcgi_pass_request_body off, uwsgi_pass_request_body off, or scgi_pass_request_body off 。</span><br><span class="line">$request_completion # 如果请求成功，值为”OK”，如果请求未完成或者请求不是一个范围请求的最后一部分，则为空。</span><br><span class="line">$request_filename # 当前连接请求的文件路径，由root或alias指令与URI请求生成。</span><br><span class="line">$request_length # 请求的长度 (包括请求的地址, http请求头和请求主体) (1.3.12, 1.2.7)</span><br><span class="line">$request_method # HTTP请求方法，通常为“GET”或“POST”</span><br><span class="line">$request_time # 处理客户端请求使用的时间 (1.3.9, 1.2.6); 从读取客户端的第一个字节开始计时。</span><br><span class="line">$request_uri # 这个变量等于包含一些客户端请求参数的原始URI，它无法修改，请查看$uri更改或重写URI，不包含主机名，例如：”/cnphp/test.php?arg=freemouse”。</span><br><span class="line">$scheme # 请求使用的Web协议, “http” 或 “https”</span><br><span class="line">$sent_http_name # 可以设置任意http响应头字段； 变量名中的后半部分“name”可以替换成任意响应头字段，如需要设置响应头Content-length，那么将“－”替换为下划线，大写字母替换为小写，形如：$sent_http_content_length 4096即可。</span><br><span class="line">$server_addr # 服务器端地址，需要注意的是：为了避免访问linux系统内核，应将ip地址提前设置在配置文件中。</span><br><span class="line">$server_name # 服务器名，www.cnphp.info</span><br><span class="line">$server_port # 服务器端口</span><br><span class="line">$server_protocol # 服务器的HTTP版本, 通常为 “HTTP/1.0” 或 “HTTP/1.1”</span><br><span class="line">$status # HTTP响应代码 (1.3.2, 1.2.2)</span><br><span class="line">$sent_http_location # 是请求响应为302时候响应头Location的值</span><br><span class="line">$tcpinfo_rtt, $tcpinfo_rttvar, $tcpinfo_snd_cwnd, $tcpinfo_rcv_space # 客户端TCP连接的具体信息</span><br><span class="line">$time_iso8601 # 服务器时间的ISO 8610格式 (1.3.12, 1.2.7)</span><br><span class="line">$time_local # 服务器时间（LOG Format 格式） (1.3.12, 1.2.7)</span><br><span class="line">$uri # 请求中的当前URI(不带请求参数，参数位于$args)，可以不同于浏览器传递的$request_uri的值，它可以通过内部重定向，或者使用index指令进行修改，$uri不包含主机名，如”/foo/bar.html”。</span><br></pre></td></tr></table></figure><h2 id="常见模块"><a href="#常见模块" class="headerlink" title="常见模块"></a>常见模块</h2><h3 id="geo模块"><a href="#geo模块" class="headerlink" title="geo模块"></a>geo模块</h3><p>根据客户端地址创建新变量，常见写法</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">geo</span> $remote_addr $geo &#123;<span class="comment"># 跟姐客户端IP定义 $geo 变量的值</span></span><br><span class="line">    <span class="attribute">default</span> <span class="number">0</span>; <span class="comment"># 这里0和1都是可以的</span></span><br><span class="line">    127.0.0.1 1;</span><br><span class="line">    192.168.0.1 1;</span><br><span class="line">    192.168.1.0/24 1; # 网段写法，都可以</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>location中使用</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果不在白名单，返回403</span></span><br><span class="line"><span class="attribute">location</span> = / &#123;</span><br><span class="line">if($geo = 0)&#123;  </span><br><span class="line"><span class="attribute">return</span> <span class="number">403</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点</p><ol><li>如果geo指令后不输入address，那么默认就使用变量remite_addr作为ip地址</li><li>{} 内的指令匹配：优先最长匹配</li></ol><h3 id="map模块"><a href="#map模块" class="headerlink" title="map模块"></a>map模块</h3><ul><li>ngx_http_map_module ；默认编译进Nginx ；通过–without-http_map_module禁用；</li><li>基于已有变量，使用类似switch{case: … default: …}的语法创建新变量，为其他基于变量值实现功能的模块提供更多的可能性。</li></ul><p>简单地说，map 的主要作用是创建自定义变量，通过使用 nginx 的内置变量，去匹配某些特定规则，如果匹配成功则设置某个值给自定义变量。 而这个自定义变量又可以作于他用。</p><p>作用域：  http 块</p><p>三个参数（指令）：</p><ol><li>default ： 指定源变量匹配不到任何表达式时将使用的默认值。当没有设置 default，将会用一个空的字符串作为默认的结果。</li><li>hostnames ： 允许用前缀或者后缀掩码指定域名作为源变量值。这个参数必须写在值映射列表的最前面。</li><li>include ： 包含一个或多个含有映射值的文件。</li></ol><p>case规则：</p><ul><li>字符串严格匹配</li><li>使用hostnames指令，可以对域名使用前缀泛域名匹配</li><li>使用hostnames指令，可以对域名使用后缀泛域名匹配</li><li>～和～*正则表达式匹配，后者忽略大小写</li></ul><p>default规则：</p><ul><li>没有匹配到任何规则时，使用default，缺失default时，返回空字符串给新变量</li></ul><p>map_hash_bucket_size size;指令：</p><ul><li><p>指定一个映射表中的变量在哈希表中的最大值，这个值取决于处理器的缓存。 </p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">map_hash_bucket_size</span> <span class="number">128</span>; <span class="comment"># 变量过长时配置文件加载报错，此处设置为128</span></span><br></pre></td></tr></table></figure></li></ul><p>根据主机名称（请求的域名）给 $name赋值</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">map</span> http_host name &#123;</span><br><span class="line">    hostnames; # hostnames指令</span><br><span class="line">    <span class="attribute">default</span> <span class="number">0</span>;</span><br><span class="line">    ~map!.taolw+l.org.cn 1;</span><br><span class="line">    *.taohui.org.cn 2;</span><br><span class="line">    map.taohui.tech 3;</span><br><span class="line">    map.taohui.* 4;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">10001</span>;</span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    <span class="attribute">location</span> /&#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">&#x27;$name:aaa&#x27;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实用操作之一，重定向处理</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="attribute">map</span> $sent_http_location $location&#123; <span class="comment"># 根据重定向location响应头$sent_http_location给变量$location赋值</span></span><br><span class="line"></span><br><span class="line">    ~http://192.168.100.100/innerApp([\S]+$) http://210.0.0.1:9000/outerApp$1; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"> <span class="attribute">location</span> /outerApp &#123; <span class="comment"># 访问 /outerApp （外网地址），代理到内网地址（/innerApp）</span></span><br><span class="line"> <span class="attribute">proxy_pass</span> http://192.168.100.100/innerApp;</span><br><span class="line"> <span class="comment"># 若后端服务（/innerApp所在服务）响应为302，则替换其location响应头，为对应外网地址，使客户端下次请求不会404</span></span><br><span class="line"> <span class="comment"># more_set_headers指令见headers_more模块</span></span><br><span class="line"> <span class="attribute">more_set_headers</span> -s <span class="string">&#x27;302&#x27;</span> <span class="string">&quot;Location: $location&quot;</span>; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="headers-more模块"><a href="#headers-more模块" class="headerlink" title="headers_more模块"></a>headers_more模块</h3><p> headers_more模块用于 添加、修改或清除 请求/响应头，该模块不是nginx自带的，需要另外安装。openresty默认包含了该模块，可以直接使用。</p><p> headers_more模块主要有4个指令，指令可使用-s选项指定HTTP状态码：</p><ul><li><p>more_set_headers 用于修改响应头，具有相同名称的响应头总是覆盖 ，因为set的特性，故也可达到添加、清除响应头的作用；</p><p>配置段</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http, server, location, location if</span><br></pre></td></tr></table></figure><p>语法  <code>more_set_headers [-t &lt;content-type list&gt;]... [-s &lt;status-code list&gt;]... &lt;new-header&gt;</code></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /app &#123;</span><br><span class="line">    <span class="attribute">more_set_headers</span> <span class="string">&quot;Foo: foo&quot;</span>; <span class="comment"># 任何请求响应后都设置响应头&quot;Foo: foo&quot;</span></span><br><span class="line">    <span class="attribute">more_set_headers</span> -s <span class="number">302</span> <span class="string">&quot;Foo: foo&quot;</span>; <span class="comment"># 响应状态码为302，则设置响应头&quot;Foo: foo&quot;</span></span><br><span class="line">    <span class="comment"># 单一指令中，选项可以多次出现</span></span><br><span class="line">    <span class="attribute">more_set_headers</span> -s <span class="number">302</span> -s <span class="number">301</span> <span class="string">&quot;Foo: foo&quot;</span>; <span class="comment"># 响应状态码为302或301，则设置响应头&quot;Foo: foo&quot;</span></span><br><span class="line">    <span class="attribute">more_set_headers</span> -s <span class="string">&#x27;302 301&#x27;</span> <span class="string">&quot;Foo: foo&quot;</span>;<span class="comment"># 响应状态码为302或301，则设置响应头&quot;Foo: foo&quot;</span></span><br><span class="line">    <span class="comment"># 允许使用Nginx变量# 提前定义 set  $my_var  “ dog” ;more_set_headers  &quot;服务器：$my_var&quot;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新的响应体格式可如下：</p><ul><li><p>name: vlaue</p></li><li><p>name:</p></li><li><p>name<br>注意：more_set_headers允许在location的if块中，但不允许在server的if块中。下面的配置就报语法错误</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># error</span></span><br><span class="line">  <span class="section">server</span> &#123; </span><br><span class="line">  <span class="attribute">if</span> ($args <span class="regexp">~ &#x27;download&#x27;</span> &#123;</span><br><span class="line">  <span class="attribute">more_set_headers</span> <span class="string">&#x27;Foo: Bar&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>more_clear_headers 用于清除响应头：</p><p>配置段</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http, server, location, location if</span><br></pre></td></tr></table></figure><p>语法 <code>more_clear_headers [-t &lt;content-type list&gt;]... [-s &lt;status-code list&gt;]... &lt;new-header&gt;</code>    </p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /app &#123;</span><br><span class="line">    <span class="attribute">more_clear_headers</span> -s <span class="number">404</span> -t <span class="string">&#x27;text/plain&#x27;</span> Foo Baz;<span class="comment"># 响应状态码为404，响应类型为text/plain时 移除响应头 &quot;Foo: Baz&quot;</span></span><br><span class="line">    <span class="attribute">more_set_headers</span> -s <span class="number">404</span> -t <span class="string">&#x27;text/plain&#x27;</span> <span class="string">&quot;Foo:&quot;</span><span class="string">&quot;Baz: &quot;</span>; <span class="comment"># 同上</span></span><br><span class="line">    <span class="attribute">more_set_headers</span> -s <span class="number">404</span> -t <span class="string">&#x27;text/plain&#x27;</span> Foo Baz <span class="comment"># 同上</span></span><br><span class="line">    <span class="comment"># 也可以使用通配符*，如:</span></span><br><span class="line">    more_clear_headers <span class="string">&#x27;x-Hidden-*&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>more_set_input_headers 用于修改请求头，因为set的特性，故也可达到添加、清除请求头的作用；</p><p>配置段</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http, server, location, location if</span><br></pre></td></tr></table></figure><p>语法 <code>more_set_input_headers [-r][-t ]... &lt;new-header&gt;</code> </p><p>类似于more_set_headers，不同之处在于它对输入标头（或请求标头）进行操作，并且仅支持该-t选项。<br>请注意，-t 选项根据请求内容的类型（ Content-Type ）过滤。</p></li><li><p>more_clear_input_headers 用于清除请求头</p><p>配置段</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http, server, location, location if</span><br></pre></td></tr></table></figure><p>语法 <code> more_clear_input_headers [-t &lt;content-type list&gt;]... &lt;new-header&gt;</code></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /app &#123;</span><br><span class="line">    <span class="attribute">more_clear_input_headers</span> -t <span class="string">&#x27;text/plain&#x27;</span> Foo Baz;</span><br><span class="line">    <span class="attribute">more_set_input_headers</span> -t <span class="string">&#x27;text/plain&#x27;</span> Foo Baz</span><br><span class="line">    more_clear_input_headers <span class="string">&quot;Foo&quot;</span> <span class="string">&quot;Baz&quot;</span>;</span><br><span class="line">    <span class="comment"># 也可以使用通配符*，如:</span></span><br><span class="line">    <span class="attribute">more_clear_input_headers</span> <span class="string">&#x27;X-Hidden-*&#x27;</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="sub模块"><a href="#sub模块" class="headerlink" title="sub模块"></a>sub模块</h3><p>ngx_http_sub_filter_module模块，默认未编译进Nginx ,通过–with-http_sub_module启用；</p><p>sub模块用于响应内容的替换，即替换响应中的字符串；指令如下：</p><ol><li><p>sub_filter<br>匹配文本后替换</p></li><li><p>sub_filter_last_modified<br>是否阻止response header中写入Last-Modified，防止缓存，默认是off，即防止缓存 </p></li><li><p>sub_filter_once<br>sub_filter指令是执行一次，还是重复执行，默认是只执行一次 ；即替换一次（on），全部替换（off）</p></li><li><p>sub_filter_types<br>指定类型的MINE TYPE才有效 </p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">     <span class="attribute">sub_filter</span> <span class="string">&#x27;aaa&#x27;</span>  <span class="string">&#x27;bbb&#x27;</span>;<span class="comment"># 忽略大小写，将响应内容内的aaa字符串替换成bbb</span></span><br><span class="line">     <span class="attribute">sub_filter</span> <span class="string">&#x27;name&#x27;</span> <span class="string">&#x27;$host&#x27;</span>;<span class="comment"># 可使用变量</span></span><br><span class="line">   <span class="comment">#sub_filter_once on; </span></span><br><span class="line">     <span class="attribute">sub_filter_once</span> <span class="literal">off</span>;<span class="comment"># 执行一次与否  </span></span><br><span class="line">     <span class="comment">#sub_filter_last_modified on;</span></span><br><span class="line">     <span class="attribute">sub_filter_last_modified</span> <span class="literal">off</span>;<span class="comment"># 防止缓存</span></span><br><span class="line">     <span class="attribute">sub_filter_types</span> application/json; <span class="comment"># 仅响应类型为 application/json 时进行替换</span></span><br><span class="line">     <span class="comment">#sub_filter_types *; # 可使用通配符</span></span><br><span class="line"> &#125;    </span><br></pre></td></tr></table></figure></li></ol><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h3 id="set指令"><a href="#set指令" class="headerlink" title="set指令"></a>set指令</h3><p>set 指令是用于定义一个变量，并且赋值</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server,location,if # 应用环境</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">set</span> $a hello;</span><br><span class="line"><span class="attribute">set</span> $b <span class="string">&quot;$a, $a&quot;</span>; <span class="comment"># hello， hello</span></span><br></pre></td></tr></table></figure><h3 id="return-指令"><a href="#return-指令" class="headerlink" title="return 指令"></a>return 指令</h3><p>return 指令用于返回状态码给客户端</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server,location,if # 应用环境</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~* \.sh$</span> &#123;</span><br><span class="line">   <span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="if指令"><a href="#if指令" class="headerlink" title="if指令"></a>if指令</h3><p>if指令用来判断条件表达式的结果，为true时执行的指令，条件为false时不执行相应的指令</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server,location# 应用环境</span><br></pre></td></tr></table></figure><p>语法格式与编程语言类似<code>if (condition) &#123; ... &#125;</code> </p><p>condition可以是如下类型：</p><ul><li>变量名，如果变量的值是空字符串或者0表示false</li><li>变量使用“=”和“!=”来跟字符串比较</li><li>可以是正则表达式</li><li>检查文件是否存在使用“-f” 和 “!-f”</li><li>检查目录是否存在使用 “-d” 和 “!-d”</li><li>检查文件、目录、符号链接是否存在使用 “-e” 和 “!-e”</li><li>检查是否是可执行文件使用“-x” 和 “!-x”</li></ul><p>if指令不支持多条件、不支持嵌套、不支持else，与常见的条件表达式不同的特点是，if指令使用单个等号＝而不是双等号==表达等值比较。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">if</span> ($http_user_agent <span class="regexp">~* mac)</span> &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">404</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="推荐文章"><a href="#推荐文章" class="headerlink" title="推荐文章"></a>推荐文章</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/pVopNiFSTHJWeSLCpfq_vw">狂神的nginx入门</a></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Location通用匹配的注意点</title>
      <link href="WindShadow/Nginx/NginxLocation/"/>
      <url>WindShadow/Nginx/NginxLocation/</url>
      
        <content type="html"><![CDATA[<p>前提应知：</p><p>先说一下ContextPath：称为web应用的上下文路径，简单理解为web容器最开始路径，所有的web资源（路径）都要挂在它的下面，使用<code>request.getContextPath()</code>可获得，SpringBoot中的配置为<code>server.servlet.context-path</code>，ContextPath的值只能为以下两种形式：</p><ol><li>空字符串：即长度为0的字符串</li><li>/xxx：形如“/xxx”形式的字符串，可以是 /xxx、/xxx/yyy、/xx x/yyy，但 /xxx/在SpringBoot中最终会被处理成/xxx</li></ol><p>在nginx反向代理的location中，我们都知道location的匹配格式（写法）决定了不同的匹配方式，从而影响最终的代理到的url。通用匹配是最常用的写法，比如为了方便管理，需要做一套应用的代理。一套应用意思就是几个项目互相依赖组成一个可用的应用，如分布式架构、sso等。这个时候我们需要将这些应用都挂到一个nginx（nginx服务器）的端口下，这样对用户来说好像就一直在访问一个应用。对外提供接口也比较方便，因为用的都是同一个端口。</p><p>在通用匹配中location和proxy_pass指令的写法还是有必要注意一下ContextPath的值的，避免掉坑。</p><p>都知道通用匹配形如</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /xxx &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://ip:port/xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时若该location块所在的server块监听的端口为8000，那么上述写法可以这样理解：一个代理挂在了8000端口下的，名为 /xxx；因为假如现在需要在此时可以再加个location去代理其它的地址，端口依旧可以用8000,。</p><p>若location如下，</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://ip:port/xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则可以这样理解：一个代理独占了8000端口；再加一个location去代理其它地址就不太好操作，搞不好容易出现代理错误的情况。</p><p>下面以上述两种location写法做个测试。</p><h2 id="通用匹配测试"><a href="#通用匹配测试" class="headerlink" title="通用匹配测试"></a>通用匹配测试</h2><p><strong>nginx服务器</strong>：</p><p>IP：192.168.100.100</p><p><strong>SpringBoot应用</strong>：</p><p>IP：192.168.0.200；</p><p>一个控制层方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NginxController</span> </span>&#123;</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件aplication.properties：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># web容器上下文路径，不写则默认为空字符串</span></span><br><span class="line"><span class="meta">server.servlet.context-path</span>=<span class="string">/demo</span></span><br><span class="line"><span class="comment"># 应用服务 WEB 访问端口</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8080</span></span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>：</p><table><thead><tr><th>context-path</th><th>location</th><th>proxy_pass</th><th>结果</th><th>描述</th></tr></thead><tbody><tr><td>-</td><td>/</td><td>192.168.0.200:8080</td><td>ok</td><td></td></tr><tr><td>-</td><td>/</td><td>192.168.0.200:8080/</td><td>ok</td><td></td></tr><tr><td>-</td><td>/app</td><td>192.168.0.200:8080</td><td>404</td><td>nginx最终代理到：192.168.0.200:8080/app/test</td></tr><tr><td>-</td><td>/app</td><td>192.168.0.200:8080/</td><td>ok</td><td></td></tr><tr><td>/demo</td><td>/</td><td>192.168.0.200:8080/demo</td><td>404</td><td>nginx最终代理到：192.168.0.200:8080/demotest</td></tr><tr><td>/demo</td><td>/</td><td>192.168.0.200:8080/demo/</td><td>ok</td><td></td></tr><tr><td>/demo</td><td>/app</td><td>192.168.0.200:8080/demo</td><td>ok</td><td></td></tr><tr><td>/demo</td><td>/app</td><td>192.168.0.200:8080/demo/</td><td>ok</td><td></td></tr></tbody></table><p>可见，location的写法和要代理到的目标地址还是有讲究的，详细的话就不说了，为了防止出错，简单一句话总结：</p><p>proxy_pass = ip + port + ContextPath，要到的目标应用ContextPath为空字符串时，location写“/”，反之写ContextPath；</p><p>有域名的情况自行适配即可。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git命令大全</title>
      <link href="WindShadow/Git/git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
      <url>WindShadow/Git/git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Git命令大全"><a href="#Git命令大全" class="headerlink" title="Git命令大全"></a>Git命令大全</h1><h2 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h2><p>配置 Git 的相关参数。</p><p>Git 一共有3个配置文件：</p><ol><li>仓库级的配置文件：在仓库的 <code>.git/.gitconfig</code>，该配置文件只对所在的仓库有效。</li><li>全局配置文件：Mac 系统在 <code>~/.gitconfig</code>，Windows 系统在 <code>C:\Users\&lt;用户名&gt;\.gitconfig</code>。</li><li>系统级的配置文件：在 Git 的安装目录下（Mac 系统下安装目录在 <code>/usr/local/git</code>）的 <code>etc</code> 文件夹中的 <code>gitconfig</code>。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看配置信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --<span class="built_in">local</span>：仓库级，--global：全局级，--system：系统级</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config &lt;--<span class="built_in">local</span> | --global | --system&gt; -l</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前生效的配置信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config -l</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑配置文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --<span class="built_in">local</span>：仓库级，--global：全局级，--system：系统级</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config &lt;--<span class="built_in">local</span> | --global | --system&gt; -e</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加配置项</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --<span class="built_in">local</span>：仓库级，--global：全局级，--system：系统级</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config &lt;--<span class="built_in">local</span> | --global | --system&gt; --add &lt;name&gt; &lt;value&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取配置项</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config &lt;--<span class="built_in">local</span> | --global | --system&gt; --get &lt;name&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除配置项</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config &lt;--<span class="built_in">local</span> | --global | --system&gt; --<span class="built_in">unset</span> &lt;name&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置提交记录中的用户信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name &lt;用户名&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email &lt;邮箱地址&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更改Git缓存区的大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果提交的内容较大，默认缓存较小，提交会失败</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 缓存大小单位：B，例如：524288000（500MB）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global http.postBuffer &lt;缓存大小&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 调用 git status/git diff 命令时以高亮或彩色方式显示改动状态</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global color.ui <span class="literal">true</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置可以缓存密码，默认缓存时间15分钟</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global credential.helper cache</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置密码的缓存时间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 缓存时间单位：秒</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global credential.helper <span class="string">&#x27;cache --timeout=&lt;缓存时间&gt;&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置长期存储密码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global credential.helper store</span></span><br></pre></td></tr></table></figure><h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h2><p>从远程仓库克隆一个版本库到本地。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认在当前目录下创建和版本库名相同的文件夹并下载版本到该文件夹下</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;远程仓库的网址&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定本地仓库的目录</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;远程仓库的网址&gt; &lt;本地目录&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># -b 指定要克隆的分支，默认是master分支</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;远程仓库的网址&gt; -b &lt;分支名称&gt; &lt;本地目录&gt;</span><br></pre></td></tr></table></figure><h2 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h2><p>初始化项目所在目录，初始化后会在当前目录下出现一个名为 .git 的目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 初始化本地仓库，在当前目录下生成 .git 文件夹</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure><h2 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h2><p>查看本地仓库的状态。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看本地仓库的状态</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以简短模式查看本地仓库的状态</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 会显示两列，第一列是文件的状态，第二列是对应的文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件状态：A 新增，M 修改，D 删除，?? 未添加到Git中</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status -s</span></span><br></pre></td></tr></table></figure><h2 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h2><p>操作远程库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出已经存在的远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出远程仓库的详细信息，在别名后面列出URL地址</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote --verbose</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote add &lt;远程仓库的别名&gt; &lt;远程仓库的URL地址&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改远程仓库的别名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote rename &lt;原远程仓库的别名&gt; &lt;新的别名&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除指定名称的远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote remove &lt;远程仓库的别名&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改远程仓库的 URL 地址</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote set-url &lt;远程仓库的别名&gt; &lt;新的远程仓库URL地址&gt;</span></span><br></pre></td></tr></table></figure><h2 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h2><p>操作 Git 的分支命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出本地的所有分支，当前所在分支以 <span class="string">&quot;*&quot;</span> 标出</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出本地的所有分支并显示最后一次提交，当前所在分支以 <span class="string">&quot;*&quot;</span> 标出</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -v</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建新分支，新的分支基于上一次提交建立</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch &lt;分支名&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改分支名称</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果不指定原分支名称则为当前所在分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -m [&lt;原分支名称&gt;] &lt;新的分支名称&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 强制修改分支名称</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -M [&lt;原分支名称&gt;] &lt;新的分支名称&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除指定的本地分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d &lt;分支名称&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 强制删除指定的本地分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -D &lt;分支名称&gt;</span></span><br></pre></td></tr></table></figure><h2 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h2><p>检出命令，用于创建、切换分支等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 切换到已存在的指定分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout &lt;分支名称&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建并切换到指定的分支，保留所有的提交记录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 等同于 <span class="string">&quot;git branch&quot;</span> 和 <span class="string">&quot;git checkout&quot;</span> 两个命令合并</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b &lt;分支名称&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建并切换到指定的分支，删除所有的提交记录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout --orphan &lt;分支名称&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 替换掉本地的改动，新增的文件和已经添加到暂存区的内容不受影响</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout &lt;文件路径&gt;</span></span><br></pre></td></tr></table></figure><h2 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h2><p>把已经提交的记录合并到当前分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 把已经提交的记录合并到当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git cherry-pick &lt;commit ID&gt;</span></span><br></pre></td></tr></table></figure><h2 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h2><p>把要提交的文件的信息添加到暂存区中。当使用 git commit 时，将依据暂存区中的内容来进行文件的提交。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 把指定的文件添加到暂存区中</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add &lt;文件路径&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加所有修改、已删除的文件到暂存区中</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add -u [&lt;文件路径&gt;]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add --update [&lt;文件路径&gt;]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加所有修改、已删除、新增的文件到暂存区中，省略 &lt;文件路径&gt; 即为当前目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add -A [&lt;文件路径&gt;]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add --all [&lt;文件路径&gt;]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有修改、已删除但没有提交的文件，进入一个子命令系统</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add -i [&lt;文件路径&gt;]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add --interactive [&lt;文件路径&gt;]</span></span><br></pre></td></tr></table></figure><h2 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h2><p>将暂存区中的文件提交到本地仓库中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 把暂存区中的文件提交到本地仓库，调用文本编辑器输入该次提交的描述信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 把暂存区中的文件提交到本地仓库中并添加描述信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;&lt;提交的描述信息&gt;&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 把所有修改、已删除的文件提交到本地仓库中</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不包括未被版本库跟踪的文件，等同于先调用了 <span class="string">&quot;git add -u&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a -m <span class="string">&quot;&lt;提交的描述信息&gt;&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改上次提交的描述信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend</span></span><br></pre></td></tr></table></figure><h2 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h2><p>从远程仓库获取最新的版本到本地的 tmp 分支上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将远程仓库所有分支的最新版本全部取回到本地</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch &lt;远程仓库的别名&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将远程仓库指定分支的最新版本取回到本地</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch &lt;远程主机名&gt; &lt;分支名&gt;</span></span><br></pre></td></tr></table></figure><h2 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h2><p>合并分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 把指定的分支合并到当前所在的分支下</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge &lt;分支名称&gt;</span></span><br></pre></td></tr></table></figure><h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><p>比较版本之间的差异。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 比较当前文件和暂存区中文件的差异，显示没有暂存起来的更改</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 比较暂存区中的文件和上次提交时的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --staged</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 比较当前文件和上次提交时的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff HEAD</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看从指定的版本之后改动的内容</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff &lt;commit ID&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 比较两个分支之间的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff &lt;分支名称&gt; &lt;分支名称&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看两个分支分开后各自的改动内容</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff &lt;分支名称&gt;...&lt;分支名称&gt;</span></span><br></pre></td></tr></table></figure><h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h2><p>从远程仓库获取最新版本并合并到本地。</p><p>首先会执行 <code>git fetch</code>，然后执行 <code>git merge</code>，把获取的分支的 HEAD 合并到当前分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从远程仓库获取最新版本。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull</span></span><br></pre></td></tr></table></figure><h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><p>把本地仓库的提交推送到远程仓库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 把本地仓库的分支推送到远程仓库的指定分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;远程仓库的别名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除指定的远程仓库的分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;远程仓库的别名&gt; :&lt;远程分支名&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;远程仓库的别名&gt; --delete &lt;远程分支名&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 强制push，慎用！！！</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push -f &lt;远程仓库的别名&gt; :&lt;远程分支名&gt;</span></span><br></pre></td></tr></table></figure><h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><p>显示提交的记录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印所有的提交记录</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印从第一次提交到指定的提交的记录</span></span><br><span class="line">$ git <span class="built_in">log</span> &lt;commit ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印指定数量的最新提交的记录</span></span><br><span class="line">$ git <span class="built_in">log</span> -&lt;指定的数量&gt;</span><br></pre></td></tr></table></figure><h2 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h2><ul><li><strong>对远程分支的rebase是指，将自己的提交追加在别人的提交之后，如果自己的提交和远程的提交有相同的文件的改动，远程提交有可能被刷掉</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打开一个编辑器，显示最后3次提交的日志，从上往下越来越新，与git <span class="built_in">log</span>显示顺序相反</span></span><br><span class="line">git rebase -i HEAD 3</span><br><span class="line"><span class="meta">#</span><span class="bash">完成编辑后执行</span></span><br><span class="line">git rebase -continue</span><br></pre></td></tr></table></figure><p>rebase的目的是打开提交的历史，git会让你在一个新的分支修改内容，git rebase -continue则是让你回到之前的版本</p><ul><li>对本地分支的rebase 是指将自己本地分支的所有提交合并成为一个，可解决多次小改动的重复提交等</li></ul><h2 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h2><p>还原提交记录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重置暂存区，但文件不受影响</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 相当于将用 <span class="string">&quot;git add&quot;</span> 命令更新到暂存区的内容撤出暂存区，可以指定文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 没有指定 commit ID 则默认为当前 HEAD</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset [&lt;文件路径&gt;]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --mixed [&lt;文件路径&gt;]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 HEAD 的指向改变，撤销到指定的提交记录，文件未修改</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset &lt;commit ID&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --mixed &lt;commit ID&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 HEAD 的指向改变，撤销到指定的提交记录，文件未修改</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 相当于调用 <span class="string">&quot;git reset --mixed&quot;</span> 命令后又做了一次 <span class="string">&quot;git add&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --soft &lt;commit ID&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 HEAD 的指向改变，撤销到指定的提交记录，文件也修改了</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard &lt;commit ID&gt;</span></span><br></pre></td></tr></table></figure><h2 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h2><p>生成一个新的提交来撤销某次提交，此次提交之前的所有提交都会被保留。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成一个新的提交来撤销某次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git revert &lt;commit ID&gt;</span></span><br></pre></td></tr></table></figure><h2 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别。</span></span><br><span class="line">git stash &lt;save &quot;save message&quot;&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看stash了哪些存储</span></span><br><span class="line">git stash list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@&#123;<span class="variable">$num</span>&#125;，比如第二个 git stash show stash@&#123;1&#125;</span></span><br><span class="line">git stash show</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示第一个存储的改动，如果想显示其他存存储，命令：git stash show  stash@&#123;<span class="variable">$num</span>&#125;  -p ，比如第二个：git stash show  stash@&#123;1&#125;  -p</span></span><br><span class="line">git stash show -p</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@&#123;0&#125;，如果要使用其他个，git stash apply stash@&#123;<span class="variable">$num</span>&#125; ， 比如第二个：git stash apply stash@&#123;1&#125;</span> </span><br><span class="line">git stash apply</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@&#123;0&#125;，如果要应用并删除其他stash，命令：git stash pop stash@&#123;<span class="variable">$num</span>&#125; ，比如应用并删除第二个：git stash pop stash@&#123;1&#125;</span></span><br><span class="line">git stash pop</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 丢弃stash@&#123;<span class="variable">$num</span>&#125;存储，从列表中删除这个存储</span></span><br><span class="line">git stash drop</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除所有缓存的stash</span></span><br><span class="line">git stash clear</span><br></pre></td></tr></table></figure><h2 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h2><p>操作标签的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打印所有的标签</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加轻量标签，指向提交对象的引用，可以指定之前的提交记录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag &lt;标签名称&gt; [&lt;commit ID&gt;]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加带有描述信息的附注标签，可以指定之前的提交记录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -a &lt;标签名称&gt; -m &lt;标签描述信息&gt; [&lt;commit ID&gt;]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到指定的标签</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout &lt;标签名称&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看标签的信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show &lt;标签名称&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除指定的标签</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -d &lt;标签名称&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将指定的标签提交到远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;远程仓库的别名&gt; &lt;标签名称&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将本地所有的标签全部提交到远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;远程仓库的别名&gt; –tags</span></span><br></pre></td></tr></table></figure><h2 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h2><p>重命名文件或者文件夹。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重命名指定的文件或者文件夹</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git mv &lt;源文件/文件夹&gt; &lt;目标文件/文件夹&gt;</span></span><br></pre></td></tr></table></figure><h2 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h2><p>删除文件或者文件夹。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 移除跟踪指定的文件，并从本地仓库的文件夹中删除</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm &lt;文件路径&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 移除跟踪指定的文件夹，并从本地仓库的文件夹中删除</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm -r &lt;文件夹路径&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 移除跟踪指定的文件，在本地仓库的文件夹中保留该文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm --cached</span></span><br></pre></td></tr></table></figure><h2 id="Git操作场景示例"><a href="#Git操作场景示例" class="headerlink" title="Git操作场景示例"></a>Git操作场景示例</h2><h3 id="1-删除掉本地不存在的远程分支"><a href="#1-删除掉本地不存在的远程分支" class="headerlink" title="1. 删除掉本地不存在的远程分支"></a>1. 删除掉本地不存在的远程分支</h3><p>多人合作开发时，如果远程的分支被其他开发删除掉，在本地执行 <code>git branch --all</code> 依然会显示该远程分支，可使用下列的命令进行删除：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用 pull 命令，添加 -p 参数</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull -p</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 等同于下面的命令</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch -p</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch --prune origin</span></span><br></pre></td></tr></table></figure><h3 id="2-git-stash解决冲突"><a href="#2-git-stash解决冲突" class="headerlink" title="2.git stash解决冲突"></a>2.git stash解决冲突</h3><p>使用IDEA的Stash Changes 和 unStash Changes 来解决冲突。</p><ul><li>Stash Changes ：<br>作用：本地的全部改动临时保存到本地仓库，并撤销了本地的所有改动<br>stash的好处是，可以先将你的改动暂存到本地仓库中，随时可以取出来再用，但是不用担心下次push到服务器时，把不想提交的改动也push到服务器上，因为Stash Changes的内容不参与commit和push。</li><li>unStash Changes<br>作用：将之前保存得临时改动，取出并合并带本地。</li></ul><p>步骤：</p><ol><li><p>我们选择项目右键–Git–Repository–Stash Changes</p><p>stash完后你会发现你本地进行的一些修改都已经不存在了，这样我们就可以和远程仓库合并了，冲突先去掉了，git pull 顺利成功。</p></li><li><p>我们选择项目右键–Git–Repository–pull将线上得代码拉取到本地</p></li><li><p>现在我们再把之前保存的更改取出来 选择项目右键–Git–Repository–UnStash Changes，手动解决冲突</p></li></ol><p>此操作比较实用。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Feign声明式服务调用入门</title>
      <link href="WindShadow/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/Feign%E5%85%A5%E9%97%A8/"/>
      <url>WindShadow/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/Feign%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="小声bb-一些吐槽"><a href="#小声bb-一些吐槽" class="headerlink" title="小声bb + 一些吐槽"></a>小声bb + 一些吐槽</h2><p>下面先bb一些概念性的东西，虽然部分是copy的，但是整理到一起看起来知识点不是那么散，那些上来就哔哔怎么用怎用的博客文章是真没意思，关键写的还不咋的，要么就说的乱七八糟除了他自己没人看得懂，要么就依赖一大堆，搞个Feign的demo还扯那微服务的东西一大堆，依赖Eurake和微服务环境，单独使用不行？除了cv多少带点思考吧。</p><p>相信能看到这篇文章的看客们（可能并没有），多多少少听过微服务的一些概念，也知道Feign能干啥，虽然我也不是特别懂，但我还是会把知识点发散开来，本文就当做一篇随时可以巩固的文章，新手也可通过本文入门。</p><h3 id="啥是“声明式服务调用”"><a href="#啥是“声明式服务调用”" class="headerlink" title="啥是“声明式服务调用”"></a>啥是“声明式服务调用”</h3><p>可以从编程范式入手了解，常见的编程范式有：</p><ul><li>命令式编程（Imperative Programming）</li><li>声明式编程（Declarative Programming）</li><li>函数式编程（Funational Programming）</li><li>面向对象编程（Object-oriented Programming）</li></ul><p>&gt;&gt;&gt; 声明式编程范式：声明式编程表明想要实现什么目的，应该做什么，但是不指定具体怎么做。</p><p>这里有一篇笔者认为关于编程范式的不错的文章，可以拓展一下眼界：【CSDN】<a target="_blank" rel="noopener" href="https://blog.csdn.net/woqutechteam/article/details/88101001">编程范式（author：一位Python高级开发工程师）</a></p><p>那么我们简单理解一下声明式服务调用：声明调用的URL地址，请求方式,和返回结果，但具体如何调用交给底层实现.<br>为什么要使用声明式服务调用?</p><ul><li>对系统使用方，通过设计声明式的接口，开发者无需关心底层实现，而更多的关注上层业务</li><li>对系统实现方，通过声明式的接口，上层使用者接口相对稳定前提下，系统可以不断的迭代优化</li><li>对整个系统而言，能够更系统的收集更多信息，能够依据策略进行系统行为优化，提升系统效率</li></ul><p>使用Feign声明式web客户端，只需要声明一个接口即可，不需要关心传参、发送请求、获取响应内容、关闭连接等细节，Feign全部帮我们做好了。</p><p>SpringCloud集成了Feign组件，一个是 spring-cloud-starter-feign，一个是spring-cloud-starter-openfeign，前者已经过时。openfeign使得SpringCloud服务间调用变得更简单方便，但不是有SpringCloud才有Feign。</p><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><p>这里我们以SpringBoot环境为例，使用SpringCloud的openfeign组件，哎，但是我们不是微服务环境，使用openfeign的原因是让系统配置少些，这段的主要目的是了解Feign的使用而不是配置。</p><h3 id="maven关键配置"><a href="#maven关键配置" class="headerlink" title="maven关键配置"></a>maven关键配置</h3><p>首先，maven依赖与版本，SpringBoot和SpringCloud版本定义如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--还有其它配置 略……--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">spring-boot.version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">spring-boot.version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Hoxton.SR1<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>openfeign的依赖不需要写版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--还有其它配置 略……--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>依赖管理块配置如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!--还有其它SpringBoot的依赖管理 略……--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Feign的服务提供与消费"><a href="#Feign的服务提供与消费" class="headerlink" title="Feign的服务提供与消费"></a>Feign的服务提供与消费</h3><p>idea中创建两个model，一个是普通的web项目，做服务提供者（下称提供端），一个做Feign的消费者（下称消费端）。</p><p><img src="/WindShadow/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/Feign%E5%85%A5%E9%97%A8/models.jpg"></p><p>提供端provider模块配置：</p><p>配置文件如下，启动类正常的默认配置即可。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">fegin-demo-provider</span></span><br><span class="line"><span class="meta">server.servlet.context-path</span>=<span class="string">/provider</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8080</span></span><br></pre></td></tr></table></figure><p>消费端consumer模块配置：</p><p>配置文件省略，仅使用测试类测试service的bean即可。我们需要用到两个注解：</p><ul><li><p><code>@EnableFeignClients</code>开启Feign客户端的功能</p><p>启动类加上<code>@EnableFeignClients</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignDemoConsumerApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(FeignDemoConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@FeignClient</code>使一个接口成为Feign的客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;beanName&quot;, url = &quot;http://ip:port/xxx&quot;, path = &quot;/prefix&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">xxxService</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="编码测试"><a href="#编码测试" class="headerlink" title="编码测试"></a>编码测试</h2><p>为了能更好的展现出Feign的能力，服务提供可以大致分为几种情况进行测试：</p><ol><li>返回值类型不同：基本类型（String、java基本数据类型的包装归为一类）、自定义引用类型（bean）、泛型等，见下文</li><li>参请求数位置不同：控制层方法常见的接收参数情况，请求头、请求体，url等等</li><li>出错情况：服务提供端响应为500或404或400等</li><li>其它非正常使用情况</li></ol><p>先构建pojo类，提供端与消费端都要构建。</p><p>自定义引用类型 User</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型，以常见的REST业务响应格式为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyResponse</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CODE_SUCCESSFUL = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CODE_FAILED = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MESSAGE_SUCCESSFUL = <span class="string">&quot;successful&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MESSAGE_FAILED = <span class="string">&quot;failed&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">MyResponse&lt;T&gt; <span class="title">successful</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyResponse&lt;&gt;(CODE_SUCCESSFUL,MESSAGE_SUCCESSFUL,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">MyResponse&lt;T&gt; <span class="title">successful</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyResponse&lt;&gt;(CODE_SUCCESSFUL,MESSAGE_SUCCESSFUL,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">MyResponse&lt;T&gt; <span class="title">successful</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyResponse&lt;&gt;(CODE_SUCCESSFUL,message,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">MyResponse&lt;T&gt; <span class="title">successful</span><span class="params">(String message, T data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyResponse&lt;&gt;(CODE_SUCCESSFUL,message,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">MyResponse&lt;T&gt; <span class="title">failed</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyResponse&lt;&gt;(CODE_FAILED,MESSAGE_FAILED,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">MyResponse&lt;T&gt; <span class="title">failed</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyResponse&lt;&gt;(CODE_FAILED,MESSAGE_FAILED,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">MyResponse&lt;T&gt; <span class="title">failed</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyResponse&lt;&gt;(CODE_FAILED,message,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">MyResponse&lt;T&gt; <span class="title">failed</span><span class="params">(String message, T data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyResponse&lt;&gt;(CODE_FAILED,message,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="case1：返回值类型不同"><a href="#case1：返回值类型不同" class="headerlink" title="case1：返回值类型不同"></a>case1：返回值类型不同</h2><h3 id="1-1-基本类型、bean、泛型，JSONObejct、ResponseEntity（SpringWeb提供的响应体封装）"><a href="#1-1-基本类型、bean、泛型，JSONObejct、ResponseEntity（SpringWeb提供的响应体封装）" class="headerlink" title="1.1 基本类型、bean、泛型，JSONObejct、ResponseEntity（SpringWeb提供的响应体封装）"></a>1.1 基本类型、bean、泛型，JSONObejct、ResponseEntity（SpringWeb提供的响应体封装）</h3><p>提供端web</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回值类型测试控制层</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> WindShadow</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2020/12/5.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/type&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderTypeController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> User admin = <span class="keyword">new</span> User(<span class="string">&quot;admin&quot;</span>,<span class="number">18</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛型=String类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/myResponse/string&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyResponse&lt;String&gt; <span class="title">returnMyResponseString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> MyResponse.successful(MyResponse.MESSAGE_SUCCESSFUL,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛型=引用类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/myResponse/user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyResponse&lt;User&gt; <span class="title">returnMyResponseUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> MyResponse.successful(admin);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">returnUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> admin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基本类型包装</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/int&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">returnInteger</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JSONObject类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/jsonObject&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JSONObject <span class="title">returnJsonObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String jsonText = JSON.toJSONString(admin);</span><br><span class="line">        <span class="keyword">return</span> JSON.parseObject(jsonText);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SpringWeb封装的响应体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="function">ResponseEntity&lt;User&gt; <span class="title">returnResponseEntityUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费端service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;consumerTypeService&quot;, url = &quot;http://127.0.0.1:8080/provider&quot;, path = &quot;/type&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConsumerTypeService</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛型=String类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/myResponse/string&quot;)</span></span><br><span class="line">    <span class="function">MyResponse&lt;String&gt; <span class="title">returnMyResponseString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛型=引用类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/myResponse/user&quot;)</span></span><br><span class="line">    <span class="function">MyResponse&lt;User&gt; <span class="title">returnMyResponseUser</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="function">User <span class="title">returnUser</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基本类型包装</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/int&quot;)</span></span><br><span class="line">    <span class="function">Integer <span class="title">returnInteger</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JSONObject类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/jsonObject&quot;)</span></span><br><span class="line">    <span class="function">JSONObject <span class="title">returnJsonObject</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SpringWeb封装的响应体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="function">ResponseEntity&lt;User&gt; <span class="title">returnResponseEntityUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费端测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @EnableFeignClients 测试类不能加这个，在主启动类加就可以了，否则报错</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeignDemoConsumerApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ConsumerTypeService consumerTypeService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">feignReturnTypeTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于我们的 ConsumerTypeService 方法没有参数，直接通过class信息遍历方法去执行</span></span><br><span class="line">        Set&lt;String&gt; methodSet = Arrays.stream(Object.class.getMethods()).map(Method::getName).collect(Collectors.toSet());</span><br><span class="line">        Method[] methods = ConsumerCollectionTypeService.class.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (methodSet.contains(method.getName())) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;invoke: &#123;&#125;&quot;</span>,method.getName());</span><br><span class="line">                Object result = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    result = method.invoke(consumerTypeService);</span><br><span class="line">                    log.info(<span class="string">&quot;result: &#123;&#125;&quot;</span>,result.toString());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;result: &#123;&#125; &gt;&gt;&gt; error!&quot;</span>,method.getName());</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(<span class="string">&quot;--------------------------------------&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果自然是ok的，图就不贴了。</p><h3 id="1-2-集合类型"><a href="#1-2-集合类型" class="headerlink" title="1.2 集合类型"></a>1.2 集合类型</h3><p>提供端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/collection&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderCollectionTyoeController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> User admin = <span class="keyword">new</span> User(<span class="string">&quot;admin&quot;</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  list */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/list/string&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">listString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Collections.singletonList(<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/list/user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">listUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Collections.singletonList(admin);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/set/string&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">setString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Collections.singleton(<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/set/user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;User&gt; <span class="title">setUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Collections.singleton(admin);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  map */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/map/string/string&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,String&gt; <span class="title">mapStringString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Collections.singletonMap(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;zs&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/map/string/user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,User&gt; <span class="title">mapStringUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Collections.singletonMap(<span class="string">&quot;admin&quot;</span>,admin);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/map/user/user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;User,User&gt; <span class="title">mapUserUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Collections.singletonMap(admin,admin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费端测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">feignReturnCollectionTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 由于我们的 ConsumerTypeService 方法没有参数，直接通过class信息遍历方法去执行</span></span><br><span class="line">      Set&lt;String&gt; methodSet = Arrays.stream(Object.class.getMethods()).map(Method::getName).collect(Collectors.toSet());</span><br><span class="line">      Method[] methods = ConsumerCollectionTypeService.class.getMethods();</span><br><span class="line">      <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (methodSet.contains(method.getName())) &#123;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              log.info(<span class="string">&quot;invoke: &#123;&#125;&quot;</span>,method.getName());</span><br><span class="line">              Object result = <span class="keyword">null</span>;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  result = method.invoke(consumerCollectionTypeService);</span><br><span class="line">                  log.info(<span class="string">&quot;result: &#123;&#125;&quot;</span>,result.toString());</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                  log.error(<span class="string">&quot;result: &#123;&#125; &gt;&gt;&gt; error!&quot;</span>,method.getName());</span><br><span class="line">              &#125;</span><br><span class="line">              log.info(<span class="string">&quot;--------------------------------------&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><p>可见接收类型为map类型时，键类型为bean是不可以的；</p><p><img src="/WindShadow/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/Feign%E5%85%A5%E9%97%A8/blog\source_posts\Feign入门\map-user-user.png" alt="map-user-user"></p><h2 id="case2：参数位置不同"><a href="#case2：参数位置不同" class="headerlink" title="case2：参数位置不同"></a>case2：参数位置不同</h2><p>提供端web</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/case&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderCaseController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/noParams&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">noParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;have no params&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * url有参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/haveParams&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">haveParams</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;have params &quot;</span> + (name == <span class="keyword">null</span> ? <span class="string">&quot;null&quot;</span> : name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * url路径作为参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> city</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/path/&#123;city&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">path</span><span class="params">(<span class="meta">@PathVariable(&quot;city&quot;)</span> String city)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;path &quot;</span> + (city == <span class="keyword">null</span> ? <span class="string">&quot;null&quot;</span> : city);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数在请求头</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/header&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">header</span><span class="params">(<span class="meta">@RequestHeader(&quot;gender&quot;)</span> String gender)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;header: &quot;</span> + (gender == <span class="keyword">null</span> ? <span class="string">&quot;null&quot;</span> : gender);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从body获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/body&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">body</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;body: &quot;</span> + (user == <span class="keyword">null</span> ? <span class="string">&quot;null&quot;</span> : user.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费端service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;consumerCaseService&quot;, url = &quot;http://127.0.0.1:8080/provider&quot;, path = &quot;/case&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConsumerCaseService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/noParams&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">noParams</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * url有参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/haveParams&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">haveParams</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * url路径作为参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> city</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/path/&#123;city&#125;&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">path</span><span class="params">(<span class="meta">@PathVariable(&quot;city&quot;)</span> String city)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数在请求头</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/header&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">header</span><span class="params">(<span class="meta">@RequestHeader(&quot;gender&quot;)</span> String gender)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从body获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/body&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">body</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费端测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">feignParamsCaseTest</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       log.info(<span class="string">&quot;无参数：&#123;&#125;&quot;</span>, consumerCaseService.noParams());</span><br><span class="line">       log.info(<span class="string">&quot;有参数：&#123;&#125;&quot;</span>, consumerCaseService.haveParams(<span class="string">&quot;root&quot;</span>));</span><br><span class="line">       log.info(<span class="string">&quot;参数在path：&#123;&#125;&quot;</span>, consumerCaseService.path(<span class="string">&quot;北京&quot;</span>));</span><br><span class="line">       log.info(<span class="string">&quot;参数在header：&#123;&#125;&quot;</span>, consumerCaseService.header(<span class="string">&quot;女&quot;</span>));</span><br><span class="line">       log.info(<span class="string">&quot;参数在body：&#123;&#125;&quot;</span>, consumerCaseService.body(<span class="keyword">new</span> User(<span class="string">&quot;ls&quot;</span>,<span class="number">20</span>)));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>测试结果ok，图就不贴了。</p><h2 id="case3：出错情况"><a href="#case3：出错情况" class="headerlink" title="case3：出错情况"></a>case3：出错情况</h2><p>提供端web</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/error&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderErrorController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/runtimeException&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">runtimeException</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;throw RuntimeException&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/exception&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">exception</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Exception&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费端传入非数字字符串即可触发参数绑定异常，即400错误</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/integer/&#123;value&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paramsBindException</span><span class="params">(<span class="meta">@PathVariable(&quot;value&quot;)</span> Integer value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Integer param is &quot;</span> + (value == <span class="keyword">null</span> ? <span class="string">&quot;null&quot;</span> : value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求一个不存在的url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/abcdefg&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">request404</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费端service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;consumerErrorService&quot;, url = &quot;http://127.0.0.1:8080/provider&quot;, path = &quot;/error&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConsumerErrorService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/runtimeException&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">runtimeException</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/exception&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">exception</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 传入非数字字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/integer/&#123;value&#125;&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">paramsBindException</span><span class="params">(<span class="meta">@PathVariable(&quot;value&quot;)</span> String value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费端测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... </span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">feignErrorTest</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;提供端运行时异常&quot;</span>);</span><br><span class="line">            log.info(<span class="string">&quot;请求结果：&#123;&#125;&quot;</span>,consumerErrorService.runtimeException());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            log.error(<span class="string">&quot;捕获到异常&quot;</span>,e);</span><br><span class="line">            log.info(<span class="string">&quot;--------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;提供端检查型异常&quot;</span>);</span><br><span class="line">            log.info(<span class="string">&quot;请求结果：&#123;&#125;&quot;</span>,consumerErrorService.exception());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            log.error(<span class="string">&quot;捕获到异常&quot;</span>,e);</span><br><span class="line">            log.info(<span class="string">&quot;--------------------------------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;提供端参数绑定异常&quot;</span>);</span><br><span class="line">            log.info(<span class="string">&quot;请求结果：&#123;&#125;&quot;</span>,consumerErrorService.paramsBindException(<span class="string">&quot;abc&quot;</span>));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            log.error(<span class="string">&quot;捕获到异常&quot;</span>,e);</span><br><span class="line">            log.info(<span class="string">&quot;--------------------------------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;请求不存在的地址&quot;</span>);</span><br><span class="line">            log.info(<span class="string">&quot;请求结果：&#123;&#125;&quot;</span>,consumerErrorService.request404());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            log.error(<span class="string">&quot;捕获到异常&quot;</span>,e);</span><br><span class="line">            log.info(<span class="string">&quot;--------------------------------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>测试结果</p><ul><li><p>提供端运行时异常</p><p><img src="/WindShadow/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/Feign%E5%85%A5%E9%97%A8/runtimeException.jpg"></p></li><li><p>提供端检查型异常（500）</p><p><img src="/WindShadow/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/Feign%E5%85%A5%E9%97%A8/exception.jpg"></p></li><li><p>提供端参数绑定异常（500）</p><p><img src="/WindShadow/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/Feign%E5%85%A5%E9%97%A8/paramError.jpg"></p></li><li><p>请求不存在的地址（404）</p><p><img src="/WindShadow/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/Feign%E5%85%A5%E9%97%A8/404.jpg"></p></li></ul><p>可以看到提供端出现异常时，消费端这边会抛出FeignException的子类异常，异常信息包含了响应码，FeignException的体系如下（部分子类）</p><p><img src="/WindShadow/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/Feign%E5%85%A5%E9%97%A8/feignException.jpg"></p><h2 id="case4：其它情况"><a href="#case4：其它情况" class="headerlink" title="case4：其它情况"></a>case4：其它情况</h2><h3 id="4-1-消费端以Object接收"><a href="#4-1-消费端以Object接收" class="headerlink" title="4.1 消费端以Object接收"></a>4.1 消费端以Object接收</h3><p>设置新的pojo，内置属性为Object超类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectResponse</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供端web</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/other/objecttype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderObjectTypeController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> User admin = <span class="keyword">new</span> User(<span class="string">&quot;admin&quot;</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/object/string&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">returnString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;---------&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/object/user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">returnUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> admin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * map string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/object/map/string&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">returnMapString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Collections.singletonMap(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;zs&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * map user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/object/map/user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">returnMapUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Collections.singletonMap(<span class="string">&quot;admin&quot;</span>,admin);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/object/set/string&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">returnSetString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Collections.singleton(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/object/set/user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">returnSetUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Collections.singleton(admin);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 封装超类 string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/object/objectResponse/string&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectResponse <span class="title">returnObjectResponseString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ObjectResponse(<span class="string">&quot;msgmsg&quot;</span>,<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 封装超类 user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/object/objectResponse/user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectResponse <span class="title">returnObjectResponseUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ObjectResponse(<span class="string">&quot;msgmsg&quot;</span>,admin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费端service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;consumerObjectTypeService&quot;, url = &quot;http://127.0.0.1:8080/provider&quot;, path = &quot;/other/objecttype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConsumerObjectTypeService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/object/string&quot;)</span></span><br><span class="line">    <span class="function">Object <span class="title">returnString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/object/user&quot;)</span></span><br><span class="line">    <span class="function">Object <span class="title">returnUser</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * map string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/object/map/string&quot;)</span></span><br><span class="line">    <span class="function">Object <span class="title">returnMapString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * map user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/object/map/user&quot;)</span></span><br><span class="line">    <span class="function">Object <span class="title">returnMapUser</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/object/set/string&quot;)</span></span><br><span class="line">    <span class="function">Object <span class="title">returnSetString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/object/set/user&quot;)</span></span><br><span class="line">    <span class="function">Object <span class="title">returnSetUser</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 封装超类 string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/object/objectResponse/string&quot;)</span></span><br><span class="line">    <span class="function">ObjectResponse <span class="title">returnObjectResponseString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 封装超类 user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/object/objectResponse/user&quot;)</span></span><br><span class="line">    <span class="function">ObjectResponse <span class="title">returnObjectResponseUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费端测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">objectTypeTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;响应类型不一致测试&quot;</span>);</span><br><span class="line">        <span class="comment">// 由于我们的 ConsumerObjectTypeService 方法没有参数，直接通过class信息遍历方法去执行</span></span><br><span class="line">        Set&lt;String&gt; methodSet = Arrays.stream(Object.class.getMethods()).map(Method::getName).collect(Collectors.toSet());</span><br><span class="line">        Method[] methods = ConsumerObjectTypeService.class.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (methodSet.contains(method.getName())) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;invoke: &#123;&#125;&quot;</span>,method.getName());</span><br><span class="line">                Object result = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    result = method.invoke(consumerObjectTypeService);</span><br><span class="line">                    <span class="comment">// 以超类Object接收，打印一下class信息看一下</span></span><br><span class="line">                    log.info(<span class="string">&quot;class : &#123;&#125; result: &#123;&#125;&quot;</span>,result.getClass(),result.toString());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                    log.error(<span class="string">&quot;result: &gt;&gt;&gt; error! &#123;&#125;&quot;</span>,method.getName());</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(<span class="string">&quot;--------------------------------------&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>测试结果</p><p>以Objec接收String类型时出错；</p><p>以Objec接收List、Set类型时，其底层为ArrayList；</p><p>以Objec接收Map和其它类型bean时类型时，其底层为LinkedHashMap；</p><p><img src="/WindShadow/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/Feign%E5%85%A5%E9%97%A8/getObjectType.png"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>在接口上使用<code>@FeignClient</code>注解即可配置一个Feign的web客户端，接口方法的书写方式可以同控制层写法类似，支持泛型</li><li>成为Feign的web客户端的接口的方法，在调用时，若服务提供端出现异常，即响应错误类型的响应码，如500、400等，该方法会抛出FeignException，该异常为运行时异常。</li><li>Feign底层使用json序列化传输，使用LinkedHashMap和ArrayList进行存储，上述测试出错的方法张，仔细分析就能发现这些数据是没办法进行反序列化成对于的数据类型的</li></ul><h2 id="Feign客户端的写法"><a href="#Feign客户端的写法" class="headerlink" title="Feign客户端的写法"></a>Feign客户端的写法</h2><h3 id="SpringMVC式写法"><a href="#SpringMVC式写法" class="headerlink" title="SpringMVC式写法"></a>SpringMVC式写法</h3><p>通过demo我们知道作为Feign客户端的接口的方法写法可以和SpringMVC控制层的方法类似，即前者是后者的子集，故而也支持使用REST风格的注解，如<code>@GetMapping</code>等等。服务消费端SpringMVC式写法的传参和服务提供端的取参自然是对应的，不过有一个不一样的地方就是，消费端接口上不能使用<code>@RequestMapping</code>注解来声明前缀，因为<code>@FeignClient</code>注解的 path属性就已经做到了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;beanName&quot;, url = &quot;http://ip:port/xxx&quot;, path = &quot;/prefix&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/yyy&quot;)</span> <span class="comment">// 启动报错，即Feign代理接口时会报错</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">xxxService</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Feign自带写法"><a href="#Feign自带写法" class="headerlink" title="Feign自带写法"></a>Feign自带写法</h3><p>Feign客户单除了mvc式的写法外，还有Feign自带的一种写法，使用<code>@RequestLine</code>注解，注解上使用表达式来声明请求的方式和地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;beanName&quot;, url = &quot;http://ip:port/xxx&quot;, path = &quot;/prefix&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">xxxService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestLine(&quot;GET  /xxx/&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">method</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要开启这种写法需要加一个配置类，往IOC中加入类型为<code>Contract</code>的bean，该类的实例决定了Feign客户端的写法，Feign默认的写法是“mvc式”，加上下面这个配置后即可使用Feign自带的写法，即使用<code>@RequestLine</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignClientConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contract <span class="title">feignContract</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> feign.Contract.Default();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不仅如此，<code>@FeignClient</code>与配置类的搭配也有讲究，分两种：</p><ol><li><p>配置类加<code>@Configuration</code>注解，则Feign客户端接口使用<code>@FeignClient</code>可以和“mvc式”一样不加其它配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;beanName&quot;, url = &quot;http://ip:port/xxx&quot;, path = &quot;/prefix&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">xxxService</span> </span>&#123;</span><br><span class="line">     <span class="meta">@RequestLine(&quot;GET  /xxx&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用@Configuration，全局配置</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignClientConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contract <span class="title">feignContract</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> feign.Contract.Default();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置类不加<code>@Configuration</code>注解，则Feign客户端接口使用<code>@FeignClient</code>需要指定配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;beanName&quot;, url = &quot;http://ip:port/xxx&quot;, path = &quot;/prefix&quot;, configuration = FeignClientConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">xxxService</span> </span>&#123;</span><br><span class="line">     <span class="meta">@RequestLine(&quot;GET  /xxx/&#123;name&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不使用@Configuration，互相搭配</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignClientConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contract <span class="title">feignContract</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> feign.Contract.Default();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>若使用了【1】的配置，即全局配置，则所以的Feign客户端（接口）都必须使用Feign自带的写法。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式与微服务 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>URL、URI、ServletPath、ContextPath、RealPath</title>
      <link href="WindShadow/web%E5%9F%BA%E7%A1%80%E6%89%AB%E7%9B%B2/diffLink/"/>
      <url>WindShadow/web%E5%9F%BA%E7%A1%80%E6%89%AB%E7%9B%B2/diffLink/</url>
      
        <content type="html"><![CDATA[<p>从request请求可以获取URL、URI、ServletPath、ContextPath、RealPath，它们之间有何区别？Let’s go!</p><h2 id="可能的误区"><a href="#可能的误区" class="headerlink" title="可能的误区"></a>可能的误区</h2><p>以SpringBoot配置为例，<code>spring.application.name</code>表示这个Spring应用叫什么，并不代表这个web应用叫什么，决定web应用叫什么的是<code>server.servlet.context-path</code>，也就是我们常说的应用名或者应用前缀或web容器上下文路径。下面这个配置访问应用的所有地址都是以  <a target="_blank" rel="noopener" href="http://ip:8080/demo">http://ip:8080/demo</a> 开头，而不是 <a target="_blank" rel="noopener" href="http://ip:8080/myapp">http://ip:8080/myapp</a> ；而Spring应用名称<code>spring.application.name</code>应用之一便是在SpringCloud微服务框架下服务的标识。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">myapp # Spring应用名称</span></span><br><span class="line"><span class="meta">server.servlet.context-path</span>=<span class="string">/demo # 应用的上下文路径</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8080</span></span><br></pre></td></tr></table></figure><h2 id="实操验证"><a href="#实操验证" class="headerlink" title="实操验证"></a>实操验证</h2><p>以SpringBoot环境为例，本地部署，有如下配置：</p><p>application. properties </p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">myapp</span></span><br><span class="line"><span class="meta">server.servlet.context-path</span>=<span class="string">/demo</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8080</span></span><br></pre></td></tr></table></figure><p>一个控制层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">m</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;URL: &#123;&#125;&quot;</span>,request.getRequestURL());</span><br><span class="line">        log.info(<span class="string">&quot;URI: &#123;&#125;&quot;</span>,request.getRequestURI());</span><br><span class="line">        log.info(<span class="string">&quot;ServletPath: &#123;&#125;&quot;</span>,request.getServletPath());</span><br><span class="line">        log.info(<span class="string">&quot;ContextPath: &#123;&#125;&quot;</span>,request.getContextPath());</span><br><span class="line">        log.info(<span class="string">&quot;RealPath: &#123;&#125;&quot;</span>,request.getRealPath(<span class="string">&quot;/&quot;</span>));</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><table><thead><tr><th>描述</th><th>值</th></tr></thead><tbody><tr><td>application. properties</td><td><code>server.servlet.context-path=/demo</code></td></tr><tr><td>访问链接</td><td><a target="_blank" rel="noopener" href="http://127.0.0.1:8080/demo/test?name=zs">http://127.0.0.1:8080/demo/test?name=zs</a></td></tr><tr><td>URL</td><td><a target="_blank" rel="noopener" href="http://127.0.0.1:8080/demo/test">http://127.0.0.1:8080/demo/test</a></td></tr><tr><td>URI</td><td>/demo/test</td></tr><tr><td>ServletPath</td><td>/test</td></tr><tr><td>ContextPath</td><td>/demo</td></tr><tr><td>RealPath</td><td>C:\Users\WS\AppData\Local\Temp\tomcat-docbase.6884443025746620464.8082\</td></tr></tbody></table><p>结合表格结果，加入官方术语简单直白的总结一波：</p><ul><li><p>URL：即 Uniform Resource Locator（统一资源定位符），资源在网络中的唯一的地址，格式：协议+主机+端口+路径</p></li><li><p>URI：即 Uniform Resource Identifier（统一资源标识符），用于标识某一互联网资源名称的字符串，格式：路径</p></li><li><p>ServletPath：Servlet路径，简单理解为web应用提供资源的路径，其表现之一在SpringMVC中就是控制层的一个完整资源路径</p></li><li><p>ContextPath：web应用的上下文路径，简单理解为web容器最开始路径，所有的web资源（路径）都要挂在它的下面</p></li><li><p>RealPath：真实路径，简单理解为web资源在服务器的真实物理路径，<code>.HttpServletRequest#getRealPath(String)</code>的方法返回的是web容器所在的真实物理地址（也就是根目录）加上该方法的参数的值的结果，说白了算是字符串拼接，没有验证资源是不是存在。使用场景笔者并不是太了解，可能在某个静态资源定位上比较有用吧，在 Servlet 2.1之后该方法已经过期，替代者如下</p><p><img src="/WindShadow/web%E5%9F%BA%E7%A1%80%E6%89%AB%E7%9B%B2/diffLink/HttpServletRequest_getRealPath.jpg" alt="HttpServletRequest#getRealPath"></p></li></ul><h2 id="ContextPath斜杠“-”问题"><a href="#ContextPath斜杠“-”问题" class="headerlink" title="ContextPath斜杠“/”问题"></a>ContextPath斜杠“/”问题</h2><p>现在我们知道application. properties 中<code>server.servlet.context-path</code>配置的 “/demo” 就是 ContextPath的值了，发散一下，如果我们不配置，那ContextPath的值是多少呢？答案是空字符串（长度为0），如果配置了“/”或“/demo/”或“//”呢？结果分别是空字符串和“/demo”和启动异常，话不多说直接看源码，进对应配置类 <code>org.springframework.boot.autoconfigure.web.ServerProperties</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerProperties</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContextPath</span><span class="params">(String contextPath)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.contextPath = cleanContextPath(contextPath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">cleanContextPath</span><span class="params">(String contextPath)</span> </span>&#123;</span><br><span class="line">String candidate = StringUtils.trimWhitespace(contextPath);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(candidate) &amp;&amp; candidate.endsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> candidate.substring(<span class="number">0</span>, candidate.length() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然该配置类是SpringBoot下的，我们知道SpringBoot内置tomcat，故而对外提供web容器（tomcat）的配置，最后转换成web容器对应的配置，所以这个配置类的参数规范肯定是要符合tomcat的要求的。</p><p>通过源码不难看出，SpringBoot对<code>server.servlet.context-path</code>进行了处理：</p><ol><li>两边去空格</li><li>包含有效字符串的情况下，去除末尾的“/”字符</li></ol><p>所以配置“/”或“/demo/”的结果也就解释得通了，而配置两个斜杠“//”的情况下，上述代码得到的结果为“/”，这个配置扔到tomcat肯定是报错了，这也就反映出为什么我们在写<code>@RequestMapping</code>的时候要以“/”开头了，除了协议与主机名之间的分隔之外，一个url不应该以双斜杠“//”出现，大多数情况下多斜杠的url是被允许的，它们只会被当做一个斜杠处理，这是web容器对我们的“宽容”，但开发者不应该乱写，更不能只知其表不知其里。</p>]]></content>
      
      
      <categories>
          
          <category> web基础扫盲 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
