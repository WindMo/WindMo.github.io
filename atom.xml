<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风的影子</title>
  
  <subtitle>千风</subtitle>
  <link href="https://blog.windshadow.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.windshadow.cn/"/>
  <updated>2024-11-01T15:20:59.909Z</updated>
  <id>https://blog.windshadow.cn/</id>
  
  <author>
    <name>浪客千风</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring数据校验体系</title>
    <link href="https://blog.windshadow.cn/Spring%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E4%BD%93%E7%B3%BB/"/>
    <id>https://blog.windshadow.cn/Spring%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E4%BD%93%E7%B3%BB/</id>
    <published>2024-10-27T16:24:24.538Z</published>
    <updated>2024-11-01T15:20:59.909Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>此篇将大致领略一下Spring的数据校验体系及应用，在此之前你需要提前了解<a href="/BeanValidation">Bean Validation</a></p><h2 id="Spring-Validation"><a href="#Spring-Validation" class="headerlink" title="Spring Validation"></a>Spring Validation</h2><p>spring在spring-context中设计了自己的一套校验体系，位于<code>org.springframework.validation</code>包下，与Bean Validation类似，核心也是校验器（<code>org.springframework.validation.Validator</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.validation;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; clazz)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(Object target, Errors errors)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与Bean Validation校验器不同，spring校验器显得更抽象些，前者通过约束注解+约束验证器组合校验JavaBean，后者更多是泛化了校验过程。spring校验器通过supports方法声明了校验器支持的类型，提供validate方法进行后续的校验，校验结果通过Errors对象回调保存。</p><p>就使用场景来说，spring校验器在框架内部应用的比较多，如spring-mvc数据绑定过程、配置bean的数据绑定等。</p><p>下面以数据绑定操作为例</p><p>定义普通的java bean与其spring校验器，基础的非空等校验可使用<code>ValidationUtils</code>辅助之。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... lombok</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonValidator</span> <span class="keyword">implements</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Person.class.isAssignableFrom(clazz);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(Object target, Errors errors)</span> &#123;</span><br><span class="line">            <span class="comment">// 字段名</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">filed</span> <span class="operator">=</span> <span class="string">&quot;email&quot;</span>;</span><br><span class="line">            <span class="comment">// 错误码（通常是国际化消息code）</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">errCode</span> <span class="operator">=</span> <span class="string">&quot;ws.error-code.person.email&quot;</span>;</span><br><span class="line">            ValidationUtils.rejectIfEmptyOrWhitespace(errors, filed, errCode, <span class="string">&quot;邮箱地址不能为空&quot;</span>);</span><br><span class="line">            <span class="comment">// 其它自定义实现的校验</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> (String)errors.getFieldValue(filed);</span><br><span class="line">            <span class="keyword">if</span> (!isEmail(email)) &#123;</span><br><span class="line">                <span class="comment">// 以error对象写入检验结果，以拒绝xx字段等操作写入</span></span><br><span class="line">                errors.rejectValue(filed, errCode, <span class="string">&quot;邮箱地址无效&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">            <span class="comment">// ... todo</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>数据绑定操作使用spring校验器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="comment">// 绑定器</span></span><br><span class="line"><span class="type">DataBinder</span> <span class="variable">binder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataBinder</span>(person);</span><br><span class="line"><span class="comment">// 设置spring校验器</span></span><br><span class="line">binder.setValidator(<span class="keyword">new</span> <span class="title class_">PersonValidator</span>());</span><br><span class="line"><span class="comment">// 属性值键值对</span></span><br><span class="line"><span class="type">MutablePropertyValues</span> <span class="variable">pvs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>();</span><br><span class="line">pvs.addPropertyValue(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;123465ws.com&quot;</span>);</span><br><span class="line"><span class="comment">// 绑定</span></span><br><span class="line">binder.bind(pvs);</span><br><span class="line"><span class="comment">// 验证绑定对象，使用已经添加的Validator</span></span><br><span class="line">binder.validate();</span><br><span class="line"><span class="comment">// 获取绑定结果</span></span><br><span class="line"><span class="type">BindingResult</span> <span class="variable">result</span> <span class="operator">=</span> binder.getBindingResult();</span><br><span class="line"><span class="keyword">if</span> (result.hasFieldErrors()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindException</span>(result);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然spring校验器可自定义的能力更宽泛些，校验逻辑实现完全开放。</p><h2 id="Spring应用Bean-Validation"><a href="#Spring应用Bean-Validation" class="headerlink" title="Spring应用Bean Validation"></a>Spring应用Bean Validation</h2><p>作为框架来说，spring是要把校验这个基础能力单独封装起来的，引入其它的校验框架时，应该要去适配对接spring的校验体系，达到插件化的效果。故而spring在其Validator的实现中也适配了Bean Validation。</p><p>其关键类便是：<code>org.springframework.validation.SmartValidator</code>与<code>org.springframework.validation.beanvalidation.SpringValidatorAdapter</code></p><p>其中<code>SmartValidator</code>重载了validate校验方法，提供了分组校验的可能，即validationHints参数，但此处也是以Object参数化处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.validation;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmartValidator</span> <span class="keyword">extends</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(Object target, Errors errors, Object... validationHints)</span>;</span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">validateValue</span><span class="params">(</span></span><br><span class="line"><span class="params">Class&lt;?&gt; targetType, String fieldName, <span class="meta">@Nullable</span> Object value, Errors errors, Object... validationHints)</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot validate individual value for &quot;</span> + targetType);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>SpringValidatorAdapter</code>更是将Bean Validation适配进来，同时实现两个体系的Validator</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.validation.beanvalidation;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringValidatorAdapter</span> <span class="keyword">implements</span> <span class="title class_">SmartValidator</span>, javax.validation.Validator &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承关系如图</p><p><img src="/Spring%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E4%BD%93%E7%B3%BB/Validator.png"></p><p><code>SpringValidatorAdapter</code>借助Bean Validation的Validator来实现spring的Validator。</p><p>因此在前文数据绑定过程中，我们可使用该校验器来使用Bean Validation的能力</p><p>此时先给Person类加上约束</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... lombok</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="meta">@Size(max = 30, groups = Group.Insert.class)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用SpringValidatorAdapter作为Person的spring校验器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="type">DataBinder</span> <span class="variable">binder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataBinder</span>(person);</span><br><span class="line"><span class="comment">// 构建Bean Validation的校验器，并提供给spring的适配器</span></span><br><span class="line">javax.validation.<span class="type">Validator</span> <span class="variable">javaxValidator</span> <span class="operator">=</span> Validation.buildDefaultValidatorFactory()</span><br><span class="line">                .getValidator();</span><br><span class="line"><span class="type">SpringValidatorAdapter</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringValidatorAdapter</span>(javaxValidator);</span><br><span class="line"><span class="comment">// 设置spring校验器</span></span><br><span class="line">binder.setValidator(adapter);</span><br><span class="line"><span class="comment">// 属性值键值对</span></span><br><span class="line"><span class="type">MutablePropertyValues</span> <span class="variable">pvs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>();</span><br><span class="line">pvs.addPropertyValue(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;123465ws.com&quot;</span>);</span><br><span class="line"><span class="comment">// 绑定</span></span><br><span class="line">binder.bind(pvs);</span><br><span class="line"><span class="comment">// 验证绑定对象</span></span><br><span class="line">binder.validate();</span><br><span class="line"><span class="comment">// 可分组校验</span></span><br><span class="line">binder.validate(Group.Insert.class);</span><br><span class="line"><span class="comment">// 获取绑定结果</span></span><br><span class="line"><span class="type">BindingResult</span> <span class="variable">result</span> <span class="operator">=</span> binder.getBindingResult();</span><br><span class="line"><span class="keyword">if</span> (result.hasFieldErrors()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindException</span>(result);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此Bean Validation与Spring Validation的异同与联系介绍完毕。</p><hr><h2 id="Spring-校验功能的应用"><a href="#Spring-校验功能的应用" class="headerlink" title="Spring 校验功能的应用"></a>Spring 校验功能的应用</h2><p>显然实际场景中spring更多是借助Bean Validation来“成就”自己的校验体系。</p><p>开发者在实际开发中若是使用Bean Validation的原始校验操作，需要编写过于重复的代码，spring肯定不会“坐以待毙”，势必进行了封装。那么在日常开发中，spring的校验体系（能力）是如何激活的呢？</p><p>核心便是</p><p><code>org.springframework.validation.annotation.Validated</code>注解，它便是开启校验的关键开关。</p><h3 id="应用于Spring-Bean的装配验证"><a href="#应用于Spring-Bean的装配验证" class="headerlink" title="应用于Spring Bean的装配验证"></a>应用于Spring Bean的装配验证</h3><p>在SpringBoot中，通常我们在设计配置类时，会有一定约束，此时可以借助spring帮我们进行字段的校验，确保配置类bean的有效。只需要在配置类上加以@Validated注解修饰，spring在创建spring bean过程中，bean初始化之际校验该bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;custom.config&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String adviceEmail;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用于Spring-Bean的方法验证增强"><a href="#应用于Spring-Bean的方法验证增强" class="headerlink" title="应用于Spring Bean的方法验证增强"></a>应用于Spring Bean的方法验证增强</h3><p>Bean Validation提供了方法参数和返回值验证的能力，spring整合Bean Validation后将这一步骤通过aop来增强实现。</p><p>SpringBoot中Validation的自动装配配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot.autoconfigure.validation;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidationAutoConfiguration</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(Validator.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LocalValidatorFactoryBean <span class="title function_">defaultValidator</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> MethodValidationPostProcessor <span class="title function_">methodValidationPostProcessor</span><span class="params">(Environment environment, <span class="meta">@Lazy</span> Validator validator)</span> &#123;</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 LocalValidatorFactoryBean便是实际使用的校验器Validator，MethodValidationPostProcessor 负责处理需要增加方法层面校验的bean，通过aop为其提供校验能力。</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>Spring中<code>@Validated</code> 注解是开启校验的关键。</p><p>在SpringBean上使用<code>@Validated</code> 修饰，Spring将会对其进行动态代理，以提供校验方法参数和返回值的能力</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeService</span> &#123;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line"> <span class="keyword">public</span> Integer <span class="title function_">validateBasic</span><span class="params">(<span class="meta">@NotBlank</span> String str)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后续该SpringBean在任一地方使用时，将会校验方法入参与返回值是否满足约束，校验不通过则以ConstraintViolationException异常通知。</p><h4 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h4><p>具有校验能力的SpringBean如何指定校验的组呢？</p><p>只需要在<code>@Validated</code>注解中声明即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Validated(Group.Update.class)</span> <span class="comment">// 声明校验组</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeService</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="应用于Spring-MVC参数绑定的验证"><a href="#应用于Spring-MVC参数绑定的验证" class="headerlink" title="应用于Spring MVC参数绑定的验证"></a>应用于Spring MVC参数绑定的验证</h3><p>在web-mvc的controller中，在以下参数绑定场景下可以使用@Validated注解对该参数进行校验。</p><ul><li><p>@RequestBody绑定</p><p>通过@RequestBody注解将Request-body的内容（通常是json）绑定到java bean时，可使用@Validated开启校验，由于是在方法参数上开启，所以更能灵活的指定分组，如新增接口使用校验Insert组，更新接口使用Update组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/v1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanValidatedController</span> &#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/person&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RestResponse <span class="title function_">handler</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@RequestBody</span> Person person)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@ModelAttribute绑定</p><p>通过@ModelAttribute注解将web视图<code>org.springframework.ui.Model</code>中的对象绑定到参数上时，可支持校验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/v2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanValidatedController</span> &#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/person&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RestResponse <span class="title function_">handler</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@ModelAttribute</span> Person person)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@RequestPart绑定（非文件类型<code>MultipartFile</code>）</p><p>通过@RequestPart注解将表单中的部分数据绑定到参数上时（如json），可支持校验，<code>MultipartFile</code>不支持校验</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/api/v2&quot;)</span><br><span class="line">public class BeanValidatedController &#123;</span><br><span class="line">    @PostMapping(&quot;/form&quot;)</span><br><span class="line">    public RestResponse handler(@Validated @RequestPart Person person) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>上述参数绑定场景的校验能力均来自于<code>org.springframework.web.bind.WebDataBinder</code>，它是web-mvc参数绑定的核心组件。其继承于前文提到的DataBinder</p><p><img src="/Spring%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E4%BD%93%E7%B3%BB/web-binder.png"></p><p>值得注意的是，在web-mvc参数绑定校验中，参数绑定的能力来源于对应的参数解析器<code>HandlerMethodArgumentResolver</code>，对绑定参数的校验逻辑是其内部解析流程之一，通过源码分析可知，上述几种场景的绑定是支持校验的，激活开关为@Validated注解（实际上@Valid注解也是开关，spring也做了对 @Valid注解的支持）</p><p>而诸如通过@RequestParam注解绑定String等基础类型时，是不支持校验的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/v2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanValidatedController</span> &#123;</span><br><span class="line">    <span class="comment">// 此处web-mvc不支持对 email 的校验</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/query&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RestResponse <span class="title function_">handler</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@RequestParam</span> <span class="meta">@Email</span> String email)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要支持上述校验，我们需要退回到《Bean Validation应用于Spring Bean的方法验证增强》的功能点上，对controller开启校验的aop代理增强。</p><p>改写如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Validated</span> <span class="comment">// 对spring bean 开启校验的aop代理</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/v2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanValidatedController</span> &#123;</span><br><span class="line">    <span class="comment">// 此处web-mvc不支持对 email 的校验</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/query&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RestResponse <span class="title function_">handler</span><span class="params">(<span class="meta">@RequestParam</span> <span class="meta">@Email</span> String email)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就意味着当我们对controller加以@Validated 注解修饰时，controller将得到校验的aop代理增强，同时由于web-mvc对参数绑定的校验支持，会同时有两套校验逻辑加在controller上。</p><p>如果我们代码如下编写时，即如badHandler方法使用@Valid 修饰参数，会触发两次校验！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Validated</span> <span class="comment">// 对spring bean 开启校验的aop代理</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/v2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanValidatedController</span> &#123;</span><br><span class="line">    <span class="comment">// 对参数绑定开启校验</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/person-bad&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RestResponse <span class="title function_">badHandler</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> Person person)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostMapping(&quot;/person-good&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RestResponse <span class="title function_">goodHandler</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@RequestBody</span> Person person)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>一次校验是web-mvc参数绑定过程的校验（开关为 @Valid）</p><p>触发机制为：controller参数绑定机制  + @Valid修饰参数激活校验开关</p><p>此时是spring的校验器在工作；</p></li><li><p>另外一次是aop代理增强的校验</p><p>触发机制为：@Validated开启aop代理 + @Valid修饰参数激活Bean Validation方法级验证</p><p>此时是Bean Validation的校验器在工作；</p></li></ol><p>两者的原理大不相同。</p><p>故上述代码badHandler方法会触发两次校验，goodHandler仅触发web-mvc参数绑定过程的校验。</p><hr><p>到此Spring的数据校验体系的应用与部分原理介绍完毕。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Spring" scheme="https://blog.windshadow.cn/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>TLS证书与自签ca</title>
    <link href="https://blog.windshadow.cn/TLS%E8%AF%81%E4%B9%A6%E4%B8%8E%E8%87%AA%E7%AD%BEca/"/>
    <id>https://blog.windshadow.cn/TLS%E8%AF%81%E4%B9%A6%E4%B8%8E%E8%87%AA%E7%AD%BEca/</id>
    <published>2022-10-03T06:51:38.858Z</published>
    <updated>2024-08-12T17:21:46.359Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="自签CA流程"><a href="#自签CA流程" class="headerlink" title="自签CA流程"></a>自签CA流程</h2><p>自签CA流程如图</p><p><img src="/TLS%E8%AF%81%E4%B9%A6%E4%B8%8E%E8%87%AA%E7%AD%BEca/openssl%E8%87%AA%E7%AD%BEca.svg"></p><p>公网的CA机构签发证书的流程和原理基本也是如此，不过根CA的压力会比较大，所以延伸出了二级ca等，以此保证证书链的完整和有效。</p><p>一般的操作系统出厂时都会内置可用的公网CA的证书拉作为信任证书源，以保证用户访问的网站使用新签发的证书时，通过证书验证。</p><p>所以，一般在双向认证场景下，我们可以只用一套根CA，不断为新的服务签发证书，每个服务只信任根CA签发的证书。</p><h2 id="Keytool简介"><a href="#Keytool简介" class="headerlink" title="Keytool简介"></a>Keytool简介</h2><p>JDK自带的keytool是一个证书工具，位于<JAVA_HOME>\bin\keytool.exe（linux同理），用它也可以生成ssl证书，但笔者觉得openssl更好用些，keytool用于p12格式和jks格式密钥库的转换就行了</p><p>使用 <code>keytool -help</code> 查看可用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-certreq            生成证书请求</span><br><span class="line">-changealias        更改条目的别名</span><br><span class="line">-delete             删除条目</span><br><span class="line">-exportcert         导出证书</span><br><span class="line">-genkeypair         生成密钥对</span><br><span class="line">-genseckey          生成密钥</span><br><span class="line">-gencert            根据证书请求生成证书</span><br><span class="line">-importcert         导入证书或证书链</span><br><span class="line">-importpass         导入口令</span><br><span class="line">-importkeystore     从其他密钥库导入一个或所有条目</span><br><span class="line">-keypasswd          更改条目的密钥口令</span><br><span class="line">-list               列出密钥库中的条目</span><br><span class="line">-printcert          打印证书内容</span><br><span class="line">-printcertreq       打印证书请求的内容</span><br><span class="line">-printcrl           打印 CRL 文件的内容</span><br><span class="line">-storepasswd        更改密钥库的存储口令</span><br></pre></td></tr></table></figure><p>使用<code>keytool -command_name -help</code>查看命令用法。</p><h3 id="keystore-和-truststore"><a href="#keystore-和-truststore" class="headerlink" title="keystore 和 truststore"></a>keystore 和 truststore</h3><p>Keytool 将密钥（key）和证书（certificates）存在一个称为 keystore 的文件中，在 keystore 里，包含两种数据：</p><ol><li>密钥实体（Key entity）— 密钥（secret key）又或者是私钥和配对公钥（采用非对称加密），包含了私钥，所以是一个需要保密的文件</li><li>可信任的证书实体（trusted certificate entries）— 只包含公钥</li></ol><p>证书库中的一条证书可以导出数字证书文件，数字证书文件只包括主体信息和对应的公钥；</p><p>keystore 和 truststore 从其文件格式来看其实是一个东西，只是为了方便管理将其分开；</p><p>keystore 中一般保存的是我们的私钥，用来加解密或者为别人做签名。</p><p>truststore 中保存的是一些可信任的证书，主要是 java 在代码中访问某个 https 的时候对被访问者进行认证的，以确保其实可信任的。</p><p>truststore 里存放的是只包含公钥的数字证书，代表了可以信任的证书，而 keystore 是包含私钥的；</p><h3 id="生成密钥库"><a href="#生成密钥库" class="headerlink" title="生成密钥库"></a>生成密钥库</h3><p>密钥库可以当作证书仓库来看</p><p><code>keytool -genkeypair [option]</code>或<code>keytool -genkey [option]</code> </p><p>选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-alias &lt;alias&gt;                  要处理的条目的别名</span><br><span class="line">-keyalg &lt;keyalg&gt;                密钥算法名称</span><br><span class="line">-keysize &lt;keysize&gt;              密钥位大小</span><br><span class="line">-sigalg &lt;sigalg&gt;                签名算法名称</span><br><span class="line">-destalias &lt;destalias&gt;          目标别名</span><br><span class="line">-dname &lt;dname&gt;                  唯一判别名</span><br><span class="line">-startdate &lt;startdate&gt;          证书有效期开始日期/时间</span><br><span class="line">-ext &lt;value&gt;                    X.509 扩展</span><br><span class="line">-validity &lt;valDays&gt;             有效天数</span><br><span class="line">-keypass &lt;arg&gt;                  密钥口令</span><br><span class="line">-keystore &lt;keystore&gt;            密钥库名称</span><br><span class="line">-storepass &lt;arg&gt;                密钥库口令</span><br><span class="line">-storetype &lt;storetype&gt;          密钥库类型</span><br><span class="line">-providername &lt;providername&gt;    提供方名称</span><br><span class="line">-providerclass &lt;providerclass&gt;  提供方类名</span><br><span class="line">-providerarg &lt;arg&gt;              提供方参数</span><br><span class="line">-providerpath &lt;pathlist&gt;        提供方类路径</span><br><span class="line">-v                              详细输出</span><br><span class="line">-protected                      通过受保护的机制的口令</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>-storetype 指定仓库类型， JKS、 JCEKS、 PKCS12等，默认JKS</li><li>-keyalg 指定密钥的算法， RSA、 DSA 等，默认DSA</li><li>-keysize 指定密钥长度，默认2048</li><li>-alias 指定密钥对的别名，该别名是公开的</li><li>-keystore 密钥库的路径及名称</li></ul><p>例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据提示挨个输入参数</span></span><br><span class="line">keytool -genkey -alias &lt;密钥库别名&gt; -storetype &lt;密钥库类型&gt; -keyalg &lt;密钥算法名称&gt; -keystore &lt;密钥库路径&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输入参数完毕后将在当前路径生成证书</span></span><br><span class="line">keytool -genkey -alias test -storetype jks -keyalg RSA -keystore test-keystore.jks </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一次性搞定</span></span><br><span class="line">keytool -genkey -alias &lt;密钥库别名&gt; -storetype &lt;密钥库类型&gt; -keystore &lt;密钥库路径&gt; -keyalg &lt;密钥算法名称&gt; -keysize &lt;密钥位大小&gt; -storepass &lt;密钥库口令&gt; -keypass &lt;密钥口令&gt;  -validity &lt;有效天数&gt; -dname &lt;dname&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接在当前路径生成证书，CN可填多个如：<span class="string">&quot;CN=test1.com, CN=test2.com, OU=test.com, O=ChinaHonker, L=Beijing, S=Beijing, C=086&quot;</span></span></span><br><span class="line">keytool -genkey -alias ws-ssl-server-keystore -storetype jks -keystore ws-ssl-server-keystore.jks -keyalg RSA -keysize 2048 -storepass 123456serverstore -keypass 123456serverkey -validity 3650 -dname &quot;CN=WindShadow, OU=WindShadow,O=WS-Server, L=Beijing, S=Beijing, C=086&quot;</span><br></pre></td></tr></table></figure><h4 id="dname详解"><a href="#dname详解" class="headerlink" title="dname详解"></a>dname详解</h4><ul><li>CN：Common Name 公用名称，对于 SSL 证书，一般为网站域名；而对于代码签名证书则为申请单位名称；而对于客户端证书则为证书申请者的姓名</li><li>OU：Organization Name 单位名称，对于 SSL 证书，一般为网站域名；而对于代码签名证书则为申请单位名称；而对于客户端单位证书则为证书申请者所在单位名称</li><li>O：Organization 组织</li><li>L： Locality 所在城市</li><li>S：State 所在省份</li><li>C：Country 所在国家，只能填代表国家的双字母或地区代码，如中国：CN或086</li></ul><h3 id="导出证书（-cer文件）"><a href="#导出证书（-cer文件）" class="headerlink" title="导出证书（.cer文件）"></a>导出证书（.cer文件）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keytool -keystore &lt;密钥库路径&gt; -alias &lt;密钥库别名&gt; -storepass &lt;密钥库口令&gt; -export -file &lt;证书路径&gt;</span><br><span class="line">keytool -keystore ws-ssl-server-keystore.jks -alias ws-ssl-server-keystore -storepass 123456serverstore -export -file ws-ssl-server-keystore.cer</span><br></pre></td></tr></table></figure><h3 id="导入证书（-cer文件）到密钥库"><a href="#导入证书（-cer文件）到密钥库" class="headerlink" title="导入证书（.cer文件）到密钥库"></a>导入证书（.cer文件）到密钥库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keytool -import -alias &lt;密钥库别名&gt; -storepass &lt;密钥库口令&gt; -file &lt;证书路径&gt; -keystore &lt;密钥库路径&gt;</span><br><span class="line">keytool -import -alias ws-ssl-server-keystore -storepass 123456serverstore -file ws-ssl-server-keystore.cer -keystore ws-ssl-trust-keystore.jks</span><br></pre></td></tr></table></figure><h3 id="转换密钥库格式"><a href="#转换密钥库格式" class="headerlink" title="转换密钥库格式"></a>转换密钥库格式</h3><p>jks转pkcs12，p12的密钥库其实不需要使用<code>keypass</code>，但是使用keytool进行转换还是要指定一下参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">keytool -importkeystore \</span><br><span class="line">-srckeystore &lt;源密钥库路径&gt; -srcstoretype &lt;源密钥库类型&gt; -srcalias &lt;源密钥库别名&gt; -srcstorepass &lt;源密钥库口令&gt; -srcstorepass &lt;源密钥口令&gt; \</span><br><span class="line">-destkeystore &lt;目标密钥库路径&gt; -deststoretype &lt;目标密钥库类型&gt; -destalias &lt;源密钥库别名&gt; -deststorepass &lt;目标密钥库口令&gt;  -destkeypass &lt;目标密钥口令&gt;</span><br><span class="line"></span><br><span class="line">keytool -importkeystore -srckeystore ws-ssl-server-keystore.jks -srcstoretype jks -srcalias ws-ssl-server-keystore  -srcstorepass 123456serverstore  -srckeypass 123456serverkey -destkeystore ws-ssl-server-keystore.p12 -deststoretype pkcs12 -destalias ws-ssl-server-keystore -deststorepass 123456serverstore -destkeypass 123456serverkey</span><br></pre></td></tr></table></figure><h3 id="列出密钥库条目"><a href="#列出密钥库条目" class="headerlink" title="列出密钥库条目"></a>列出密钥库条目</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">keytool -list -keystore  &lt;密钥库路径&gt;  -storepass &lt;密钥库口令&gt; -keypass &lt;密钥口令&gt;</span><br><span class="line"></span><br><span class="line">keytool -list -keystore ws-ssl-server-keystore.jks  -storepass 123456serverstore -keypass 123456serverkey</span><br></pre></td></tr></table></figure><h2 id="openssl自签ca示例"><a href="#openssl自签ca示例" class="headerlink" title="openssl自签ca示例"></a>openssl自签ca示例</h2><p>cagen.sh脚本（Linux），用到的openssl配置文件可从此地址下载：<a target="_blank" rel="noopener" href="http://web.mit.edu/crypto/openssl.cnf">http://web.mit.edu/crypto/openssl.cnf</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── cagen.sh</span><br><span class="line">└── openssl.cnf</span><br></pre></td></tr></table></figure><p>cagen.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## rootca</span></span></span><br><span class="line">readonly rootca=&quot;ws-rootca&quot;</span><br><span class="line">readonly rootcaKeyPwd=&quot;rootcaKeyPwd&quot;</span><br><span class="line">readonly rootDname=&quot;/CN=WindShadow-root/OU=WindShadow/O=WS/L=Beijing/S=Beijing/C=CN&quot;</span><br><span class="line">readonly opensslCnf=&quot;openssl.cnf&quot;</span><br><span class="line">readonly globalValidity=3650</span><br><span class="line"></span><br><span class="line">readonly trustKeystore=&quot;ws-trust&quot;</span><br><span class="line">readonly trustKeystorePwd=&quot;ws-trustKeystorePwd&quot;</span><br><span class="line"></span><br><span class="line">function clean() &#123;</span><br><span class="line"></span><br><span class="line">    rm -f *.p12</span><br><span class="line">    rm -f *.jks</span><br><span class="line">    rm -f *.cer</span><br><span class="line">    rm -f *.csr</span><br><span class="line">    rm -f *.crt</span><br><span class="line">    rm -f *.key</span><br><span class="line">    rm -f *.pem</span><br><span class="line">    rm -f *.crl</span><br><span class="line">    rm -f *.pass</span><br><span class="line">    rm -rf ./demoCA</span><br><span class="line">    rm -rf ./gen</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function CrtToP12() &#123;</span><br><span class="line"></span><br><span class="line">    crtFile=$&#123;1&#125;</span><br><span class="line">    keyFile=$&#123;2&#125;</span><br><span class="line">    keyPwd=$&#123;3&#125;</span><br><span class="line">    keystore=$&#123;4&#125;</span><br><span class="line">    keystoreAlias=$&#123;5&#125;</span><br><span class="line"></span><br><span class="line">    openssl pkcs12 -export -clcerts \</span><br><span class="line">    -in $&#123;crtFile&#125; \</span><br><span class="line">    -inkey $&#123;keyFile&#125; -passin pass:$&#123;keyPwd&#125; \</span><br><span class="line">    -out $&#123;keystore&#125; -name $&#123;keystoreAlias&#125; -password pass:$&#123;keyPwd&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function CrtToCer() &#123;</span><br><span class="line"></span><br><span class="line">    crtFile=$&#123;1&#125;</span><br><span class="line">    cerFile=$&#123;2&#125;</span><br><span class="line">    openssl x509 -in $&#123;crtFile&#125; -out $&#123;cerFile&#125; -outform der</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function genRootCA() &#123;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## openssl genrsa -aes256 -passout pass:$&#123;keyPwd&#125; -out $&#123;caName&#125;.key 2048 # 加密为pkcs1的格式</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## pkcs1 转 pkcs8 要先解密再加密。即指定 -passin 和 -passout</span></span></span><br><span class="line"></span><br><span class="line">    # 无加密</span><br><span class="line">    openssl genrsa -out $&#123;rootca&#125;.key 2048</span><br><span class="line">    # 加密为 pkcs8</span><br><span class="line">    openssl pkcs8 -topk8 -in $&#123;rootca&#125;.key -out $&#123;rootca&#125;.key.e -passout pass:$&#123;rootcaKeyPwd&#125; \</span><br><span class="line">    &amp;&amp; rm -f $&#123;rootca&#125;.key \</span><br><span class="line">    &amp;&amp; mv $&#123;rootca&#125;.key.e $&#123;rootca&#125;.key</span><br><span class="line">    openssl req -new -key $&#123;rootca&#125;.key -passin pass:$&#123;rootcaKeyPwd&#125; \</span><br><span class="line">    -out $&#123;rootca&#125;.csr \</span><br><span class="line">    -days $&#123;globalValidity&#125; \</span><br><span class="line">    -subj $&#123;rootDname&#125;</span><br><span class="line"></span><br><span class="line">    openssl x509 -req \</span><br><span class="line">    -in $&#123;rootca&#125;.csr \</span><br><span class="line">    -signkey $&#123;rootca&#125;.key -passin pass:$&#123;rootcaKeyPwd&#125; \</span><br><span class="line">    -extfile $&#123;opensslCnf&#125; -extensions v3_ca \</span><br><span class="line">    -out $&#123;rootca&#125;.crt \</span><br><span class="line">    -days $&#123;globalValidity&#125;</span><br><span class="line"></span><br><span class="line">    CrtToCer $&#123;rootca&#125;.crt $&#123;rootca&#125;.cer</span><br><span class="line">    rm -f $&#123;rootca&#125;.csr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function rootCAIssue() &#123;</span><br><span class="line"></span><br><span class="line">    caName=$&#123;1&#125;</span><br><span class="line">    keyPwd=$&#123;2&#125;</span><br><span class="line">    dname=$&#123;3&#125;</span><br><span class="line">    validity=$&#123;4&#125;</span><br><span class="line"></span><br><span class="line">    openssl genrsa -out $&#123;caName&#125;.key 2048</span><br><span class="line">    openssl pkcs8 -topk8 -in $&#123;caName&#125;.key -out $&#123;caName&#125;.key.e -passout pass:$&#123;keyPwd&#125; \</span><br><span class="line">    &amp;&amp; rm -f $&#123;caName&#125;.key \</span><br><span class="line">    &amp;&amp; mv $&#123;caName&#125;.key.e $&#123;caName&#125;.key</span><br><span class="line">    openssl req -new -key $&#123;caName&#125;.key -passin pass:$&#123;keyPwd&#125; \</span><br><span class="line">    -out $&#123;caName&#125;.csr \</span><br><span class="line">    -days $&#123;validity&#125; \</span><br><span class="line">    -subj $&#123;dname&#125;</span><br><span class="line"></span><br><span class="line">    openssl x509 -req \</span><br><span class="line">    -in $&#123;caName&#125;.csr \</span><br><span class="line">    -CAkey $&#123;rootca&#125;.key -passin pass:$&#123;rootcaKeyPwd&#125; \</span><br><span class="line">    -CA $&#123;rootca&#125;.crt -CAcreateserial \</span><br><span class="line">    -extfile $&#123;opensslCnf&#125; -extensions v3_ca \</span><br><span class="line">    -out $&#123;caName&#125;.crt \</span><br><span class="line">    -days $&#123;validity&#125;</span><br><span class="line"></span><br><span class="line">    rm -f $&#123;caName&#125;.csr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function add2Trust() &#123;</span><br><span class="line"></span><br><span class="line">    caName=$&#123;1&#125;</span><br><span class="line">    caFile=$&#123;2&#125;</span><br><span class="line">    keytool -importcert -trustcacerts -deststoretype pkcs12 -alias $&#123;caName&#125; -keystore $&#123;trustKeystore&#125;.p12 -storepass $&#123;trustKeystorePwd&#125; -file $&#123;caFile&#125; -noprompt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function main() &#123;</span><br><span class="line"></span><br><span class="line">    ### serverca</span><br><span class="line">    readonly serverca=&quot;ws-serverca&quot;</span><br><span class="line">    readonly servercaKeyPwd=&quot;ws-servercaKeyPwd&quot;</span><br><span class="line">    readonly serverDname=&quot;/CN=WindShadow-server/OU=WindShadow/O=WS/L=Beijing/S=Beijing/C=CN&quot;</span><br><span class="line">    rootCAIssue $&#123;serverca&#125; $&#123;servercaKeyPwd&#125; $&#123;serverDname&#125; $&#123;globalValidity&#125;</span><br><span class="line"></span><br><span class="line">    ###</span><br><span class="line">    CrtToP12 $&#123;rootca&#125;.crt $&#123;rootca&#125;.key $&#123;rootcaKeyPwd&#125; $&#123;rootca&#125;.p12 $&#123;rootca&#125;</span><br><span class="line">    CrtToP12 $&#123;serverca&#125;.crt $&#123;serverca&#125;.key $&#123;servercaKeyPwd&#125; $&#123;serverca&#125;.p12 $&#123;serverca&#125;</span><br><span class="line"></span><br><span class="line">    ### 高版本jdk的keytool的p12密钥库在低版本JDK使用时不兼容</span><br><span class="line"></span><br><span class="line">    # 导入rootCa根证书到信任库中</span><br><span class="line">    add2Trust $&#123;rootca&#125; $&#123;rootca&#125;.cer</span><br><span class="line"></span><br><span class="line">    ### 整理</span><br><span class="line">    cp $&#123;rootca&#125;.crt $&#123;trustKeystore&#125;.crt</span><br><span class="line">    mkdir -p gen/ca/</span><br><span class="line">    mkdir -p gen/certificate/</span><br><span class="line">    mkdir -p gen/trust/</span><br><span class="line">    mv $&#123;rootca&#125;.* gen/ca/</span><br><span class="line">    mv $&#123;serverca&#125;.* gen/certificate/</span><br><span class="line">    mv $&#123;trustKeystore&#125;.* gen/trust/</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">set -x</span><br><span class="line">clean</span><br><span class="line">genRootCA</span><br><span class="line">main</span><br></pre></td></tr></table></figure><p>得到以下文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">gen</span><br><span class="line">├── ca</span><br><span class="line">│   ├── ws-rootca.cer</span><br><span class="line">│   ├── ws-rootca.crt</span><br><span class="line">│   ├── ws-rootca.key</span><br><span class="line">│   ├── ws-rootca.p12</span><br><span class="line">│   └── ws-rootca.srl</span><br><span class="line">├── certificate</span><br><span class="line">│   ├── ws-serverca.crt</span><br><span class="line">│   ├── ws-serverca.key</span><br><span class="line">│   └── ws-serverca.p12</span><br><span class="line">└── trust</span><br><span class="line">    ├── ws-trust.crt</span><br><span class="line">    └── ws-trust.p12</span><br></pre></td></tr></table></figure><p>serverca可以部署到服务上作为服务端证书，trust可作为双向认证时的可信证书（crt）或可信密钥库（p12），保存rootca可用于新服务证书的签发</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="web基础" scheme="https://blog.windshadow.cn/categories/web%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Bean Validation</title>
    <link href="https://blog.windshadow.cn/BeanValidation/"/>
    <id>https://blog.windshadow.cn/BeanValidation/</id>
    <published>2021-11-21T03:43:28.106Z</published>
    <updated>2024-10-29T16:38:25.915Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>此篇将全面领略一下<a target="_blank" rel="noopener" href="http://jcp.org/en/jsr/detail?id=303">JSR-303</a>中提议的Bean Validation特性</p><h2 id="Bean-Validation"><a href="#Bean-Validation" class="headerlink" title="Bean Validation"></a>Bean Validation</h2><p>Bean Validation是一种规范，为 JavaBean 和方法验证定义了一组元数据模型和 API 规范，而Hibernate Validator 目前来说应该算是最佳实现，Spring框架底层也依赖了Hibernate Validator。</p><p>Bean Validation中核心概念之一是：“约束”（constraint），其提供了一系列用于约束JavaBean的属性的注解，</p><p>位于javax.validation.constraints包下，使用这些注解和校验器(<code>javax.validation.Validator</code>)，我们可以很好的对JavaBean进行校验。</p><p><img src="/./BeanValidation/constraints.png"></p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>定一个JavaBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... lombok</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Email</span> <span class="comment">// 字符串约束为邮箱</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过校验器校验JavaBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ValidatorFactory</span> <span class="variable">validatorFactory</span> <span class="operator">=</span> Validation.buildDefaultValidatorFactory();</span><br><span class="line"><span class="type">Validator</span> <span class="variable">validator</span> <span class="operator">=</span> validatorFactory.getValidator();</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;123456@xx.com&quot;</span>);</span><br><span class="line">Set&lt;ConstraintViolation&lt;Person&gt;&gt; violations = validator.validate(person);</span><br><span class="line"><span class="keyword">if</span> (!violations.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// 有违反约束的属性，可抛出ConstraintViolationException异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConstraintViolationException</span>(violations);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：每种约束都有支持的类型，如@Email显然不能约束Integer类型的属性，具体可用访问以文档或源代码注释为准。如果错误使用则将抛出UnexpectedTypeException异常。属性需要有对应的符合JavaBean规范的getter&#x2F;setter</p><h3 id="多重约束"><a href="#多重约束" class="headerlink" title="多重约束"></a>多重约束</h3><p>可使用多个注解或重复使用同一注解（前提带有@Repeatable元注解）约束</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Email</span></span><br><span class="line"><span class="meta">@Size(max = 30)</span> <span class="comment">// 约束邮箱地址长度最大为30个字符</span></span><br><span class="line"><span class="keyword">private</span> String email;</span><br></pre></td></tr></table></figure><h3 id="Null值特殊性"><a href="#Null值特殊性" class="headerlink" title="Null值特殊性"></a>Null值特殊性</h3><p>通常情况对于JavaBean属性的约束是除了null值以外的，即必须有值才进行约束。如下约束，当email为null时，不进行约束校验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Email</span></span><br><span class="line"><span class="keyword">private</span> String email;</span><br></pre></td></tr></table></figure><p>如果需要约束其值不能为null可使用@NotNull注解。这么设计的目的应该是使每个注解的职责足够单一</p><p>值得注意的是，对于字符串约束的注解@NotBlank（javax的注解，hibernate也有一个同名注解但已弃用），源码中已经表示除了约束空白字符串，还会约束null值。</p><p>故若要设计自定义的约束注解时，应该也要遵循这个特性。</p><h3 id="级联校验"><a href="#级联校验" class="headerlink" title="级联校验"></a>级联校验</h3><p>如有JavaBean中还有JavaBean，可通过@Valid触发级联校验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... lombok</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... lombok</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="meta">@Valid</span> <span class="comment">// 校验此字段时，继续内校验该JavaBean</span></span><br><span class="line">    <span class="keyword">private</span> Company company;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Valid可以看作是对JavaBean 的一种约束，即告诉Validation具体约束请进入JavaBean解析</p><h3 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h3><p>指定约束的分组，即在该分组（使用Class作为标识）下，才进行约束</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Email(groups = Group.Insert.class)</span> <span class="comment">// 字符串约束为邮箱，在Group.Insert组下</span></span><br><span class="line"><span class="keyword">private</span> String email;</span><br></pre></td></tr></table></figure><p>校验时指定要校验的组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;ConstraintViolation&lt;Person&gt;&gt; violations = validator.validate(person， Group.Insert.class);</span><br></pre></td></tr></table></figure><p>可以指定多个组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Email(groups = &#123;Group.Insert.class, Group.Update.class&#125;)</span></span><br><span class="line"><span class="keyword">private</span> String email;</span><br></pre></td></tr></table></figure><p>其实所有的约束默认分组为<code>javax.validation.groups.Default</code>，校验时不指定分组的情况下，默认使用Default组</p><h4 id="分组转换"><a href="#分组转换" class="headerlink" title="分组转换"></a>分组转换</h4><p>在级联校验中，如果内部的JavaBean使用了其它分组，可以使用@ConvertGroup注解，通过分组转换，触发其内部的分组校验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... lombok</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(groups = CompanyGroup.Chain.class)</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... lombok</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="comment">// 校验Person的Group.Insert.class组时校验Company内的CompanyGroup.Chain.class组</span></span><br><span class="line">    <span class="meta">@ConvertGroup(from = Group.Insert.class, to = CompanyGroup.Chain.class)</span></span><br><span class="line">    <span class="comment">// Default默认组也可转为其它组</span></span><br><span class="line">    <span class="meta">@ConvertGroup(from = Default.class, to = CompanyGroup.Chain.class)</span></span><br><span class="line">    <span class="keyword">private</span> Company company;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态默认组策略-hibernate"><a href="#动态默认组策略-hibernate" class="headerlink" title="动态默认组策略(hibernate)"></a>动态默认组策略(hibernate)</h4><p>在Hibernate Validator中，我们可以通过制定默认组策略，额外提供要校验的组。</p><p>实现<code>org.hibernate.validator.spi.group.DefaultGroupSequenceProvider</code>接口提供额外组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... lombok</span></span><br><span class="line"><span class="meta">@GroupSequenceProvider(PotGroup.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pot</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(groups = Group.Query.class)</span></span><br><span class="line">    <span class="meta">@Null(groups = Group.Insert.class)</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PotGroup</span> <span class="keyword">implements</span> <span class="title class_">DefaultGroupSequenceProvider</span>&lt;Pot&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Class&lt;?&gt;&gt; getValidationGroups(Pot pot) &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; groups = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        groups.add(Pot.class);</span><br><span class="line">        <span class="keyword">if</span> (pot != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">code</span> <span class="operator">=</span> pot.getCode();</span><br><span class="line">            <span class="keyword">if</span> (code != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (code) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                        groups.add(Group.Insert.class);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        groups.add(Group.Query.class);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        groups.add(Group.Update.class);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> groups;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ul><li>实现DefaultGroupSequenceProvider接口的getValidationGroups方法时，必须至少返回指定的泛型本身的class</li><li>此操作是提供额外的组，内置的Default依旧有效 ，如Provider提供了Group.Insert.class，则会校验Default组和Group.Insert.class组</li><li><strong>只有触发默认组的校验时</strong>，才会以Provider提供的组进一步进行对应组的校验</li></ul><p>如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pot</span> <span class="variable">pot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pot</span>();</span><br><span class="line">pot.setCode(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// ... pot other setter</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不指定分组，触发默认组，code == 0, 进一步校验Group.Insert.class组与Default组，即id和color都会被校验</span></span><br><span class="line">validator.validate(pot); </span><br><span class="line"><span class="comment">// 指定分组，未触发默认组，仅校验Group.Query.class组</span></span><br><span class="line">validator.validate(pot, Group.Query.class); </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意的是，校验组的顺序是根据返回的列表确定的，若途中有一组校验未通过，则后续的组将不会继续校验，且Default组优先级最高</p><h3 id="违反约束的提示消息"><a href="#违反约束的提示消息" class="headerlink" title="违反约束的提示消息"></a>违反约束的提示消息</h3><p>通过message字段确定消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Email(message = &quot;邮箱无效&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String email;</span><br></pre></td></tr></table></figure><p>获取消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;ConstraintViolation&lt;Person&gt;&gt; violations = validator.validate(person);</span><br><span class="line"><span class="keyword">for</span> (ConstraintViolation&lt;T&gt; violation : violations) &#123;</span><br><span class="line">    System.out.println(violation.getMessage()); <span class="comment">// 打印消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然标准场景消息肯定是要支持国际化，在官方约束注解中已经有默认实现，如@Email消息为“{javax.validation.constraints.Email.message}”，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Email &#123;</span><br><span class="line">String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&#123;javax.validation.constraints.Email.message&#125;&quot;</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Hibernate Validator实现中提供了国际化消息，即classpath下的<code>ValidationMessages.properties</code>文件</p><p><img src="/./BeanValidation/message.png"></p><h3 id="脚本断言-hibernate"><a href="#脚本断言-hibernate" class="headerlink" title="脚本断言(hibernate)"></a>脚本断言(hibernate)</h3><p>在Hibernate Validator中，提供了脚本约束<code>@ScriptAssert</code>注解，顾名思义，你可以通过脚本来对JavaBean进行更灵活更复杂的校验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ScriptAssert(script = &quot;_this.id == null || _this.desc != null&quot;, alias = &quot;_this&quot;, lang = &quot;javascript&quot;, message = &quot;&#123;ws.spring.validate.pojo.Phone.message&#125;&quot;)</span></span><br><span class="line"><span class="comment">// ...lombok</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的@ScriptAssert注解中，script部门便是要编写的脚本，语法则是使用lang属性指定的javascript，而alias表示脚本中使用”_this”代表当前JavaBean对象。</p><p>需要注意的是，该脚本更像是表达式，其返回的结果必须是布尔值。</p><p>为了方便维护及灵活编码，笔者常用实践更多是在JavaBean中提供判定方法，在脚本中调用该方法</p><p>如下，提供的方法必须是public的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ScriptAssert(script = &quot;_this.isValid()&quot;, alias = &quot;_this&quot;, lang = &quot;javascript&quot;, message = &quot;&#123;ws.spring.validate.pojo.Phone.message&#125;&quot;)</span></span><br><span class="line"><span class="comment">// ...lombok</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 可进行其它更复杂的逻辑校验</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.id == <span class="literal">null</span> || <span class="built_in">this</span>.desc != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于脚本的执行，实际是通过JSR233 引入的脚本引擎<code>javax.script.ScriptEngineManager</code> 来支持的，默认提供了javascript的支持。在java9后<code>ScriptEngineManager</code> 被<code>ServiceLoader</code>  代替。</p><h3 id="约束泛型"><a href="#约束泛型" class="headerlink" title="约束泛型"></a>约束泛型</h3><p>考虑以下JavaBean，是否可以约束集合内部的字符串为邮箱地址？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... lombok</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; emails;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上我们只要编写成以下形式即可做到约束集合内的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;<span class="meta">@Email</span> String&gt; emails;</span><br></pre></td></tr></table></figure><p>那么再考虑一种情况，自定义的类型，如果也带了泛型，是否支持约束呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... lombok</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T entity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是否支持以下约束声明，以约束Box内部的entity为邮箱地址？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... lombok</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Box&lt;<span class="meta">@Email</span> String&gt; box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很遗憾不支持！</p><p>以List之一的ArrayList举例，Bean Validation是怎么知道要校验的是ArrayList内部保存元素的数组，而不是其它如size等字段的呢？很显然背后有一套机制在支持，而我们自定义的类型Box明显是不被识别的，也就不会支持。</p><p>这便是提取器<code>javax.validation.valueextraction.ValueExtractor</code></p><h4 id="提取器"><a href="#提取器" class="headerlink" title="提取器"></a>提取器</h4><p>Bean Validation能够识别泛型类型并校验器内部的值依靠的正是ValueExtractor提取器。</p><p>不仅集合，对数组、Optional对象等进行校验时，Validation会通过ValueExtractor提取真正要进行校验的值。</p><p>Hibernate Validator提供了常用集合数组等的提取器</p><p><img src="/./BeanValidation/extractor.png"></p><p>如果要实现上述我们对Box泛型的约束校验，就需要实现它的提取器，其中泛型部分使用@ExtractedValue注明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoxValueExtractor</span> <span class="keyword">implements</span> <span class="title class_">ValueExtractor</span>&lt;Box&lt;<span class="meta">@ExtractedValue</span> ?&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NODE_NAME</span> <span class="operator">=</span> <span class="string">&quot;&lt;Box entity&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ValueExtractorDescriptor</span> <span class="variable">DESCRIPTOR</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ValueExtractorDescriptor</span>(<span class="keyword">new</span> <span class="title class_">BoxValueExtractor</span>());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">extractValues</span><span class="params">(Box&lt;?&gt; originalValue, ValueReceiver receiver)</span> &#123;</span><br><span class="line">        <span class="comment">// 实际校验 Box内部的entity</span></span><br><span class="line">        receiver.value(NODE_NAME, originalValue.getEntity());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提取器通过SPI注册，文件名为<code>META-INF/services/javax.validation.valueextraction.ValueExtractor</code></p><p><img src="/./BeanValidation/box-extractor.png"></p><h3 id="方法参数约束"><a href="#方法参数约束" class="headerlink" title="方法参数约束"></a>方法参数约束</h3><p>Bean Validation还支持对方法参数和返回值进行约束校验，而非仅限于JavaBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeService</span> &#123;</span><br><span class="line">     <span class="meta">@NotNull</span></span><br><span class="line"> <span class="keyword">public</span> Integer <span class="title function_">validateBasic</span><span class="params">(<span class="meta">@NotBlank</span> String str)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>ExecutableValidator</code>校验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ValidatorFactory</span> <span class="variable">validatorFactory</span> <span class="operator">=</span> Validation.buildDefaultValidatorFactory();</span><br><span class="line"><span class="type">Validator</span> <span class="variable">validator</span> <span class="operator">=</span> validatorFactory.getValidator();</span><br><span class="line"><span class="comment">// 获取方法参数校验器</span></span><br><span class="line"><span class="type">ExecutableValidator</span> <span class="variable">ev</span> <span class="operator">=</span> validator.forExecutables();</span><br><span class="line"></span><br><span class="line"><span class="type">SomeService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SomeService</span>();</span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> SomeService.class.getMethod(<span class="string">&quot;validateBasic&quot;</span>, String.class);</span><br><span class="line"><span class="comment">// 校验方法参数</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">ExecutableValidator</span> <span class="variable">ev</span> <span class="operator">=</span> validator.forExecutables();</span><br><span class="line">Set&lt;ConstraintViolation&lt;SomeService&gt;&gt; violations1 = ev.validateParameters(service, method, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;str&#125;);</span><br><span class="line"><span class="keyword">if</span> (!violations1.isEmpty()) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConstraintViolationException</span>(violations1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 校验方法返回值</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">retuenValue</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">Set&lt;ConstraintViolation&lt;SomeService&gt;&gt; violations2 = ev.validateReturnValue(service, method, retuenValue);</span><br><span class="line"><span class="keyword">if</span> (!violations2.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConstraintViolationException</span>(violations2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，Method需要和给定的service是对应契合的，如果存在继承或实现接口等操作，方法获取不当则抛出ConstraintViolationException异常，通常是因为方法签名与给定的目标对象不匹配。</p><p>其它诸如分组校验等操作，在方法约束校验上不再赘述。</p><h4 id="方法参数脚本断言-hibernate"><a href="#方法参数脚本断言-hibernate" class="headerlink" title="方法参数脚本断言(hibernate)"></a>方法参数脚本断言(hibernate)</h4><p>同样Hibernate Validator也提供了，对于方法参数的脚本断言<code>@ParameterScriptAssert</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeService</span> &#123;</span><br><span class="line"><span class="meta">@ParameterScriptAssert(lang = &quot;javascript&quot;, script = &quot;a + b == 10&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validateBasic</span><span class="params">(Integer a, Integer b)</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> Objects.requireNonNull(a) + Objects.requireNonNull(b) == <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，在javascript中 null与数字运算时被当作0，即 null + 5 &#x3D; 5。所以上述脚本，a &#x3D; null, b &#x3D; 10时，验证也会通过。故java方法内需要留意空指针问题</p><h3 id="约束扩展"><a href="#约束扩展" class="headerlink" title="约束扩展"></a>约束扩展</h3><h4 id="基本扩展"><a href="#基本扩展" class="headerlink" title="基本扩展"></a>基本扩展</h4><p>扩展Bean Validation的约束需要通过注解+约束验证器（<code>javax.validation.ConstraintValidator</code>）的形式。</p><p>声明一个约束注解，必须使用<code>@Constraint</code>修饰，约束注解必须至少包含message(String)、groups(Class数组)、payload(Class数组)属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="comment">// 一般我们支持注解可应用在大多数场合，没必要缩小范围</span></span><br><span class="line"><span class="meta">@Target(&#123;METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE&#125;)</span></span><br><span class="line"><span class="comment">// 指明约束验证器，可以是多个</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = &#123;ColorConstraintValidator.class&#125;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Color &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">BLUE</span> <span class="operator">=</span> <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">RED</span> <span class="operator">=</span> <span class="string">&quot;red&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">YELLOW</span> <span class="operator">=</span> <span class="string">&quot;yellow&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">GREEN</span> <span class="operator">=</span> <span class="string">&quot;green&quot;</span>;</span><br><span class="line">    <span class="comment">// 国际化消息key，若不支持国际化可使用固定消息如 &quot;颜色取值错误&quot; 等</span></span><br><span class="line">    String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&#123;ws.spring.validate.annotation.Color.message&#125;&quot;</span>;</span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现约束验证器，值得注意的是，验证器在每次验证操作时都会被实例化，也就是说可设计成有状态的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示支持验证Color注解修饰的对象，并支持验证String类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ColorConstraintValidator</span> <span class="keyword">implements</span> <span class="title class_">ConstraintValidator</span>&lt;Color, String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; COLORS = Stream.of(Color.BLUE, Color.GREEN, Color.RED, Color.YELLOW).collect(Collectors.toSet());</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(Color constraintAnnotation)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化操作，这里可以拿到注解内容</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String value, ConstraintValidatorContext context)</span> &#123;</span><br><span class="line">        <span class="comment">// 验证操作</span></span><br><span class="line">        <span class="keyword">return</span> COLORS.contains(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，@Color注解使用的消息我们需要支持国际化，需要按照官方“套路”，在classpath下提供ValidationMessages.properties。</p><p><img src="/./BeanValidation/validation-message.png"></p><p>到此扩展完成</p><h4 id="组合扩展"><a href="#组合扩展" class="headerlink" title="组合扩展"></a>组合扩展</h4><p>如果扩展约束时，只是想把现有的约束整合到一起，可不提供约束验证器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE&#125;)</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = &#123;&#125;)</span></span><br><span class="line"><span class="meta">@Size</span></span><br><span class="line"><span class="meta">@Pattern(regexp = &quot;[a-zA-Z]*&quot;)</span></span><br><span class="line"><span class="meta">@ReportAsSingleViolation</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LetterText &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 覆盖&#123;<span class="doctag">@link</span> Size#min()&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OverridesAttribute(constraint = Size.class, name = &quot;min&quot;)</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 覆盖&#123;<span class="doctag">@link</span> Size#max()&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OverridesAttribute(constraint = Size.class, name = &quot;max&quot;)</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用&#123;<span class="doctag">@link</span> ReportAsSingleViolation&#125;注解时，表示忽略组合注解的校验结果message消息，使用自身&lt;code&gt;message&lt;/code&gt;消息作为最终的校验消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&#123;ws.spring.validate.annotation.LetterText.message&#125;&quot;</span>;</span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，@LetterText约束由@Size约束与@Pattern约束组合而成，限制了字符串内容必须为字母，且长度默认为0到5。</p><p>使用@OverridesAttribute覆盖（或传递）注解的属性值。</p><p>使用@ReportAsSingleViolation注解则表明，校验未通过时，使用的消息以@LetterText的为准，@Size和@Pattern的消息将被忽略，即无论数据违反了@Size还是@Pattern的约束，都使用@LetterText的消息</p><h4 id="特殊扩展"><a href="#特殊扩展" class="headerlink" title="特殊扩展"></a>特殊扩展</h4><p>在方法参数脚本断言@ParameterScriptAssert中，并不像@Email这样单一校验某个参数，而是涉及了多个参数。</p><p>这是Bean Validation比较特殊的一种验证器：跨参数验证器</p><p>即跨多个方法参数的验证器</p><p>如我们自定义一个@AnyNotNull约束注解，来约束方法参数至少有一个不为null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="comment">// 因为是校验方法参数，所以仅可修饰构造（器）方法或普通方法</span></span><br><span class="line"><span class="meta">@Target(&#123;METHOD, CONSTRUCTOR&#125;)</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = AnyNotNullConstraintValidator.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnyNotNull &#123;</span><br><span class="line">    String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&#123;ws.spring.validate.annotation.AnyNotNull.message&#125;&quot;</span>;</span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@AnyNotNull的验证器，使用<code>@SupportedValidationTarget</code>  + <code>ValidationTarget.PARAMETERS</code> 注明此为跨参数验证器（即指定验证目标为方法参数），跨参数验证器要验证的目标是方法参数，所以必须以Object[]接收（Object也可，但本质还是Object[]）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SupportedValidationTarget(&#123;ValidationTarget.PARAMETERS&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnyNotNullConstraintValidator</span> <span class="keyword">implements</span> <span class="title class_">ConstraintValidator</span>&lt;AnyNotNull, Object[]&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(Object[] value, ConstraintValidatorContext context)</span> &#123;</span><br><span class="line">        <span class="comment">// 参数至少有一个不为null</span></span><br><span class="line">        <span class="keyword">for</span> (Object o : value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，<strong>跨参数验证器约束注解不能作用在无参方法上</strong></p><p>注意到<code>ValidationTarget</code>枚举有两种类型（版本：jakarta.validation-api: 2.0.2）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public enum ValidationTarget &#123;</span><br><span class="line">ANNOTATED_ELEMENT,</span><br><span class="line">PARAMETERS</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当@SupportedValidationTarget 注解内部指定的验证目标为PARAMETERS，说明验证器为跨参数验证器，若为ANNOTATED_ELEMENT，说明验证器是普通的验证器，也就是说此时约束注解验证时是对方法的返回值进行验证，即避免了歧义。</p><p>下面讨论更复杂的场景，若我们的验证器想支持上述两种ValidationTarget，消除歧义是必须的。</p><p>以@AnyNotNull 为例，再增加对返回值的校验支持，即返回值不可为null。</p><p>根据Bean Validation的约定，@AnyNotNull 需要设定额外的属性<code>validationAppliesTo</code>以标识要的验证目标，以消除上述歧义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;METHOD, CONSTRUCTOR&#125;)</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = AnyNotNullConstraintValidator.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnyNotNull &#123;</span><br><span class="line">    String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&#123;ws.spring.validate.annotation.AnyNotNull.message&#125;&quot;</span>;</span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 默认值必须是 IMPLICIT</span></span><br><span class="line">    ConstraintTarget <span class="title function_">validationAppliesTo</span><span class="params">()</span> <span class="keyword">default</span> ConstraintTarget.IMPLICIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证器需做如下改造，其中通过target保存此次验证的目标，验证目标对象使用Object接收以兼容验证返回值的场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SupportedValidationTarget(&#123;ValidationTarget.ANNOTATED_ELEMENT, ValidationTarget.PARAMETERS&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnyNotNullConstraintValidator</span> <span class="keyword">implements</span> <span class="title class_">ConstraintValidator</span>&lt;AnyNotNull, Object&gt; &#123;</span><br><span class="line">    <span class="comment">// 保存要验证的目标</span></span><br><span class="line">    <span class="keyword">private</span> ConstraintTarget target;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(AnyNotNull constraintAnnotation)</span> &#123;</span><br><span class="line">        target = constraintAnnotation.validationAppliesTo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(Object value, ConstraintValidatorContext context)</span> &#123;</span><br><span class="line">        <span class="comment">// 验证返回值</span></span><br><span class="line">        <span class="keyword">if</span> (target == ConstraintTarget.RETURN_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> value != <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target == ConstraintTarget.PARAMETERS) &#123;</span><br><span class="line">            <span class="comment">// 验证参数</span></span><br><span class="line">            Object[] arr = (Object[])value;</span><br><span class="line">            <span class="keyword">for</span> (Object o : arr) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unsupported ConstraintTarget&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用@AnyNotNull约束注解时，则需要指明<code>validationAppliesTo</code>属性为（RETURN_VALUE或PARAMETERS）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AnyNotNull(validationAppliesTo = ConstraintTarget.RETURN_VALUE)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">someMethod</span><span class="params">(String str, Integer size)</span> &#123;</span><br><span class="line"><span class="comment">// ...   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，如果约束注解存在多个验证器，且这些验证器既有普通验证器又有跨参数验证器时，也需要设定<code>validationAppliesTo</code>属性来消除歧义。</p><hr><p>到此，Bean Validation介绍完毕，如果想更详细的了解Bean Validation可参考此篇文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43341842/article/details/127560164">https://blog.csdn.net/qq_43341842/article/details/127560164</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Java特项" scheme="https://blog.windshadow.cn/categories/Java%E7%89%B9%E9%A1%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收入门</title>
    <link href="https://blog.windshadow.cn/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%85%A5%E9%97%A8/"/>
    <id>https://blog.windshadow.cn/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%85%A5%E9%97%A8/</id>
    <published>2021-09-11T06:20:09.586Z</published>
    <updated>2024-08-12T17:11:06.140Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JVM垃圾回收入门"><a href="#JVM垃圾回收入门" class="headerlink" title="JVM垃圾回收入门"></a>JVM垃圾回收入门</h1><p>本文JVM以常用的Hotspot虚拟机为例。</p><h2 id="JVM内存分区"><a href="#JVM内存分区" class="headerlink" title="JVM内存分区"></a>JVM内存分区</h2><p>Java垃圾回收也叫GC（Garbage Collection），了解GC之前先了解JVM内存分区。</p><p>JVM将内存分为5大部分：方法区、堆、虚拟机栈、程序计数器、本地方法栈</p><p>如图（图片来自互联网）</p><p><img src="/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%85%A5%E9%97%A8/jvm%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.png" alt="JVM内存分区"></p><p>垃圾回就是释放垃圾占用的空间，防止内存泄露。有效的使用可以使用的内存，Java中主要对内存<strong>堆（Heap）</strong>中已经死亡的或者长时间没有使用的对象进行清除和回收。 </p><p>下文《分代回收模型与分代回收算法》小节着重讲方法区和堆，此处先照个面。</p><h2 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h2><p>知道垃圾回收大体概念后，那么什么是垃圾呢？或者说什么样的对象才能称之为垃圾？</p><p>定义：没有任何引用指向的一个对象或多个对象（循环引用，见下文）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;admin&quot;</span>);<span class="comment">// new 了一个名为&quot;admin&quot;的User对象，其引用给到了变量a</span></span><br><span class="line">a = <span class="literal">null</span>; <span class="comment">// 此时名为&quot;admin&quot;的User对象没有被引用了，成为了垃圾，GC被触发时会被回收</span></span><br></pre></td></tr></table></figure><h2 id="如何定位垃圾"><a href="#如何定位垃圾" class="headerlink" title="如何定位垃圾"></a>如何定位垃圾</h2><h3 id="引用计数法（reference-count）"><a href="#引用计数法（reference-count）" class="headerlink" title="引用计数法（reference count）"></a>引用计数法（reference count）</h3><p>给每个对象添加一个计数器，当有地方引用该对象时计数器加1，当引用失效时计数器减1。用对象计数器是否为0来判断对象是否可被回收。 </p><p><img src="/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%85%A5%E9%97%A8/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95.svg"></p><p>缺点：无法解决循环引用。</p><p>显然循环引用的多个对象也要被认为是垃圾，但是引用计数法无法定位到它们。</p><p><img src="/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%85%A5%E9%97%A8/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95%E7%BC%BA%E7%82%B9.svg"></p><h3 id="根可达算法（roots-searching）"><a href="#根可达算法（roots-searching）" class="headerlink" title="根可达算法（roots searching）"></a>根可达算法（roots searching）</h3><p>顾名思义，一种以某种对象为起点的搜索算法，可以被搜索到（可达性）的对象就不认为是垃圾，反之不可达对象就是垃圾，这种作为起点的对象称之为GC Roots。</p><p>GC Roots主要有：线程栈变量、静态变量、常量池、JNI指针等</p><p><img src="/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%85%A5%E9%97%A8/%E6%A0%B9%E5%8F%AF%E8%BE%BE%E7%AE%97%E6%B3%95.svg"></p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记清除（Mark-Sweep）"><a href="#标记清除（Mark-Sweep）" class="headerlink" title="标记清除（Mark - Sweep）"></a>标记清除（Mark - Sweep）</h3><p>优点：快</p><p>缺点：可用内存位置不连续，产生碎片</p><p><img src="/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%85%A5%E9%97%A8/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.svg"></p><h3 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h3><p>优点：不产生内存碎片</p><p>缺点：浪费空间（8G的内存实际只能用4G）</p><p><img src="/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%85%A5%E9%97%A8/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.svg"></p><h3 id="标记压缩（Mark-Compact）"><a href="#标记压缩（Mark-Compact）" class="headerlink" title="标记压缩（Mark - Compact）"></a>标记压缩（Mark - Compact）</h3><p>标记清除之后再进行一次压缩。</p><p>缺点：效率偏低</p><p><img src="/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%85%A5%E9%97%A8/%E6%A0%87%E8%AE%B0%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95.svg"></p><h2 id="分代回收模型与分代回收算法"><a href="#分代回收模型与分代回收算法" class="headerlink" title="分代回收模型与分代回收算法"></a>分代回收模型与分代回收算法</h2><h3 id="JVM方法区（Method-Area）"><a href="#JVM方法区（Method-Area）" class="headerlink" title="JVM方法区（Method Area）"></a>JVM方法区（Method Area）</h3><p>JVM方法区中存在roots searching算法所需的GC Roots，所以还是要提一提。</p><p><strong>方法区只是一个逻辑概念（jvm规范中有言），对应1.7的永久代和1.8的元空间</strong></p><p><img src="/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%85%A5%E9%97%A8/jvm%E6%96%B9%E6%B3%95%E5%8C%BA.svg"></p><p>永久代和元空间：</p><ul><li>永久代必须指定大小限制，元空间可设置也可不设置，无上限（受限于物理内存）</li><li>字符串常量1.7时存在于永久代，1.8后存在于堆中</li></ul><h3 id="JVM堆（Heap）"><a href="#JVM堆（Heap）" class="headerlink" title="JVM堆（Heap）"></a>JVM堆（Heap）</h3><p>JVM将堆内存区域分成新生代 + 老年代，各区域默认比例如图所示（可通过启动参数配置）</p><p><img src="/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%85%A5%E9%97%A8/GC%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E6%A8%A1%E5%9E%8B.svg"></p><h3 id="Young-GC、Full-GC"><a href="#Young-GC、Full-GC" class="headerlink" title="Young GC、Full GC"></a>Young GC、Full GC</h3><p>在新生代触发的GC叫Young GC，即YGC，也叫Minor GC，在老年代触发的GC叫Full GC，即FGC，也叫Major GC。</p><h3 id="Eden区"><a href="#Eden区" class="headerlink" title="Eden区"></a>Eden区</h3><p>大多数情况下，对象会在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机会发起一次YGC。</p><h3 id="Survivor区"><a href="#Survivor区" class="headerlink" title="Survivor区"></a>Survivor区</h3><p>Survivor区相当于是Eden区和Tenured区的一个缓冲区，Survivor区又分为2个区，一个是From区，一个是To区。每次执行YGC时，会将Eden区中存活的对象放到Survivor的From区，在From区中仍存活的对象会移动到To区。From区和To区的逻辑关系会发生交换： From变To，To变From，目的是保证有连续的空间存放对方，避免内存碎片化。</p><h3 id="Tenured区（老年代）"><a href="#Tenured区（老年代）" class="headerlink" title="Tenured区（老年代）"></a>Tenured区（老年代）</h3><p>JVM给每个对象定义了一个对象年龄（Age）计数器；</p><p>如果对象在Eden出生并经过第一次YGC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每经历一次YGC（正常情况下，对象经历YGC后存活下来的时，会不断在Survivor的From与To区之间移动），年龄就增加1岁，当它的年龄增加到阈值（默认15岁，可以通过参数 <code>XX:MaxPretenuringThreshold</code> 设置 ），就将会晋升到老年代中。</p><h3 id="对象内存分配规则"><a href="#对象内存分配规则" class="headerlink" title="对象内存分配规则"></a>对象内存分配规则</h3><p>大多数情况下，对象会在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机会发起一次YGC。YGC相比FGC更频繁，回收速度也更快。而较大的对象（需要大量连续内存空间的Java对象 ）直接进入老年代。</p><p>通过YGC之后，Eden区中绝大部分对象会被回收，而那些存活对象，将会送到Survivor的From区，若From区空间不够，则直接进入老年代 。</p><h3 id="分代回收算法"><a href="#分代回收算法" class="headerlink" title="分代回收算法"></a>分代回收算法</h3><p>分代回收算法是融合上述3种基础垃圾回收算法的思想，而产生针对分代回收模型中不同代采用不同算法的一套组合拳。</p><ul><li>在新生代中，每次YGC都会有大批对象死去，少量对象存活，选用复制算法（Copying）来回收垃圾，只需复制出少量存活对象就可完成收集。复制成本低，效率高。</li><li>在老年代触发的FGC，虽然触发了GC，但是对象存活率高，没有额外空间对它进行分配担保，一般使用标记压缩（Mark - Compact）来进行回收，保证可用空间的连续性。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JVM" scheme="https://blog.windshadow.cn/categories/JVM/"/>
    
    <category term="Garbage Collection" scheme="https://blog.windshadow.cn/categories/JVM/Garbage-Collection/"/>
    
    
  </entry>
  
  <entry>
    <title>何为Java线程中断</title>
    <link href="https://blog.windshadow.cn/%E4%BD%95%E4%B8%BAJava%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/"/>
    <id>https://blog.windshadow.cn/%E4%BD%95%E4%B8%BAJava%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/</id>
    <published>2021-09-03T07:28:43.518Z</published>
    <updated>2021-10-31T09:39:13.366Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="何为Java线程中断"><a href="#何为Java线程中断" class="headerlink" title="何为Java线程中断"></a>何为Java线程中断</h1><p>Java线程中断是一个大多熟人不太关心的知识点，有的人可能一辈子也用不到，这是一位网络上的大牛说的。</p><p>Java线程的中断其实非常简单，说白了就是一个中断标志位的改变。先来看<code>Thread</code>类3个关于中断的方法：</p><ul><li><p>interrupt()：</p><p>实例方法，中断该线程；意思就是把中断标志位改为true。</p></li><li><p>isInterrupted()</p><p>实例方法，测试该线程是否被中断；显然，根据中断标志位返回true或false。</p></li><li><p>Thread.interrupted()</p><p>静态方法，测试当前线程是否中断；该方法与isInterrupted()类似，只不过，如果线程发生了中断，则把中断标志清除，也就是改为false。</p></li></ul><p>与中断相关的自然就是中断异常<code>InterruptedException</code>，当线程执行某些方法时不希望被中断，若被中断则抛出中断异常，如Thread.sleep()方法、Object#wait()方法。</p><h2 id="中断线程sleep休眠"><a href="#中断线程sleep休眠" class="headerlink" title="中断线程sleep休眠"></a>中断线程sleep休眠</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadInterruptedTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">currentTime</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> second)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(second * <span class="number">1000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;sleep中断异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建子线程 t 并启动</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程start - &quot;</span> + currentTime());</span><br><span class="line">            sleep(<span class="number">10</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;线程end - &quot;</span> + currentTime());</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程在2s后中断子线程 t</span></span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线程start - 16:13:53</span><br><span class="line">sleep中断异常</span><br><span class="line">线程end - 16:13:55</span><br></pre></td></tr></table></figure><h2 id="中断线程因调用Object-wait-方法进入等待的状态"><a href="#中断线程因调用Object-wait-方法进入等待的状态" class="headerlink" title="中断线程因调用Object#wait()方法进入等待的状态"></a>中断线程因调用Object#wait()方法进入等待的状态</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadInterruptedTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">currentTime</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">COMMON</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">waitOfCommon</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (COMMON) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                COMMON.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;等待COMMON被中断&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建子线程 t 并启动</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程start - &quot;</span> + currentTime());</span><br><span class="line">            waitOfCommon();</span><br><span class="line">            System.out.println(<span class="string">&quot;线程end - &quot;</span> + currentTime());</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程在2s后中断子线程 t</span></span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线程start - 16:20:43</span><br><span class="line">等待COMMON被中断</span><br><span class="line">线程end - 16:20:45</span><br></pre></td></tr></table></figure><p>如果不执行中断线程t，由于COMMON没有其它线程调用notify()方法或notifyAll()方法，线程 t 永远不会醒来。</p><p>我们知道，线程调用Object#wait()方法时，会释放该对象的锁，当其他线程拿到该对象的锁时，是否可以中断调用Object#wait()方法的线程？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadInterruptedTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">currentTime</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> second)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(second * <span class="number">1000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;sleep中断异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">COMMON</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建子线程 t1 并启动</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (COMMON) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1 start - &quot;</span> + currentTime());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    COMMON.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1 等待COMMON被中断&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1 end - &quot;</span> + currentTime());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">2</span>);<span class="comment">// 主线程休眠2s确保线程1 进入等待状态</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (COMMON) &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;线程2 start - &quot;</span> + currentTime());</span><br><span class="line">                <span class="comment">// 每过一秒打印数字，打印6次</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;println &quot;</span> + i);</span><br><span class="line">                    sleep(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                COMMON.notifyAll(); <span class="comment">// 最后唤醒其它线程</span></span><br><span class="line">                System.out.println(<span class="string">&quot;线程2 end - &quot;</span> + currentTime());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程在2s后中断子线程 t1</span></span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;main end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">线程1 start - 16:56:10</span><br><span class="line">线程2 start - 16:56:12</span><br><span class="line">println 0</span><br><span class="line">println 1</span><br><span class="line">main end</span><br><span class="line">println 2</span><br><span class="line">println 3</span><br><span class="line">println 4</span><br><span class="line">println 5</span><br><span class="line">线程2 end - 16:56:18</span><br><span class="line">线程1 等待COMMON被中断</span><br><span class="line">线程1 end - 16:56:18</span><br></pre></td></tr></table></figure><p>可以看出，线程t 在等待状态时，虽然被中断，但此时 COMMON 对象的锁被线程2 持有，所以没有响应中断，当线程2 调用COMMON.notifyAll()方法，线程 1获得 COMMON 对象的锁，发现自己被中断了。</p><p><strong>推测线程在调用Object#wait()方法时，并没有立即让出锁，此时锁还在自己手上，但允许其它线程过来抢，直到有其它线程拿走锁后，才真正的失去锁。</strong></p><p><strong>所以对于Object#wait()方法，线程只有在获得监视对象的锁时才能响应该方法的中断。</strong></p><h2 id="中断线程因调用LockSupport-park-方法进入等待的状态"><a href="#中断线程因调用LockSupport-park-方法进入等待的状态" class="headerlink" title="中断线程因调用LockSupport.park()方法进入等待的状态"></a>中断线程因调用LockSupport.park()方法进入等待的状态</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="comment">// 创建子线程 t 并启动</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;线程 start - &quot;</span> + currentTime());</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 end - &quot;</span> + currentTime());</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程在2s后中断子线程 t</span></span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        t.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;main end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线程1 start - 17:16:23</span><br><span class="line">main end</span><br><span class="line">线程1 end - 17:16:27</span><br></pre></td></tr></table></figure><p>当线程调用LockSupport.park()使cpu对其不再进行调度时，可以通过中断的方式唤醒（当然LockSupport.unpark(Thread)也可以），继续执行该线程。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>说了这么多，一般开发中线程中断用到的场景少之又少，更多的是出现在线程调度相关的操作中，如AQS，都是大佬们玩的。</p><p>似乎线程中断的设计就是为线程调度而设计的。开发中就算强行为了用而用，用其作为线程通信的手段，也会有更好的方案代替。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Java多线程" scheme="https://blog.windshadow.cn/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Java线程池原理（二）</title>
    <link href="https://blog.windshadow.cn/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://blog.windshadow.cn/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-08-28T09:30:13.294Z</published>
    <updated>2024-11-28T15:40:15.944Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java线程池原理（二）"><a href="#Java线程池原理（二）" class="headerlink" title="Java线程池原理（二）"></a>Java线程池原理（二）</h1><p>承接上文，我们知道了线程池可以复用线程去执行任务，<code>Executors</code>工具类通过设置不同的参数来得到一些特性的线程池，那么继续深入，了解线程池是如何实现线程复用、核心线程的维持、非核心线程的存活控制，这些核心功能整体是如何运作的。</p><h2 id="线程复用、核心线程的维持、非核心线程的存活控制"><a href="#线程复用、核心线程的维持、非核心线程的存活控制" class="headerlink" title="线程复用、核心线程的维持、非核心线程的存活控制"></a>线程复用、核心线程的维持、非核心线程的存活控制</h2><h3 id="线程复用"><a href="#线程复用" class="headerlink" title="线程复用"></a>线程复用</h3><p>此小节重点讲线程池线程复用的机制，遇到一些影不易读懂的代码我们可以跳过。</p><p>首先，线程池executor方法是线程池的入口，顺着该方法分析，不难发现一个关键的方法：<code>addWorker(Runnable firstTask, boolean core)</code>，这个方法是负责添加Worker以执行任务的。</p><p>那么我们目的很明确，在此只需要关心3个点：1、具体添加了什么。2、任务怎么被执行的。3、firstTask和core参数怎么运用的。</p><h4 id="ThreadPoolExecutor的addWorker方法"><a href="#ThreadPoolExecutor的addWorker方法" class="headerlink" title="ThreadPoolExecutor的addWorker方法"></a>ThreadPoolExecutor的addWorker方法</h4><p><strong>这里我们先入为主一波：</strong></p><p>猜测该方法添加了一个叫Worker的东西，Worker内部使用一个boolean变量标识其内部Thread的性质是核心还是非核心线程，按照我们的常规的编程思路确实容易这样想。</p><p>接下来分析addWorker方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">        retry:<span class="comment">/// java 类似goto语句的语法，此处不重要</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                   firstTask == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                   ! workQueue.isEmpty()))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">                <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">break</span> retry;</span><br><span class="line">                c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">                <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">                <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/// 0.1、前半段的代码的作用是通过cas进行自旋，先不必关心自旋干啥</span></span><br><span class="line">    <span class="comment">/// 0.2、只需知道 core 参数的作用也是参与到了其中，到此 core 参数的使命已经完成！后面已经用不到了</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">/// 1、标识worker是否启动的变量</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">/// 2、标识worker是否已经添加的变量</span></span><br><span class="line">        <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">/// 3、声明一个worker</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);<span class="comment">/// 4、new 一个worker</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;<span class="comment">/// 5、拿到 worker 内的线程</span></span><br><span class="line">            <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">                mainLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                    <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                    <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                        workers.add(w);<span class="comment">/// 6、经过一系列状态等判断后，添加worker到workers中，阅读源码发现workers是ThreadPoolExecutor内部的一个保存worker的HashSet</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line">                        workerAdded = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                    t.start();<span class="comment">/// 7、worker添加成功，启动worker内的线程</span></span><br><span class="line">                    workerStarted = <span class="literal">true</span>;<span class="comment">/// 8、worker启动成功</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> workerStarted;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>总结：addWorker方法添加一个<code>Worker</code>到<code>ThreadPoolExecutor</code>保存worker的一个HashSet中，之后<code>Worker</code>内的Thread被启动。而firstTask参数作为<code>Worker</code>构造参数被使用，core参数仅参与了一个cas自旋操作，和<code>Worker</code>没啥关系。</p><p>显然，<strong>我们先入为主的想法并不正确</strong>。</p><p>前文讲到线程池内是通过<code>Worker</code>干活的，其内部有一个Thread在工作，<code>Worker</code>是线程池实现线程复用的关键。要了解线程池线程复用等原理势必要先了解<code>Worker</code>对象如何工作的。</p><h4 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h4><p><code>Worker</code>类是<code>ThreadPoolExecutor</code>的私有非静态内部类，继承了AQS且实现了<code>Runnable</code>接口，Java中的AQS在此不展开讲，到这里我们只需知道<code>Worker</code>继承了AQS使自身可对外提供加解锁的方法，外部的合理编码保证并发访问的安全性即可，即使不太了解AQS也没关系。通过<code>Worker</code>类的方法名也可大致知道是干什么的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/// 内部维护了一个线程，该线程通过线程池的线程工厂创建</span></span><br><span class="line">       <span class="keyword">final</span> Thread thread;</span><br><span class="line">       <span class="comment">/// 第一个任务</span></span><br><span class="line">       Runnable firstTask;</span><br><span class="line">       <span class="comment">/// 该参数保存已经完成的任务的数量</span></span><br><span class="line">       <span class="keyword">volatile</span> <span class="type">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/// 构造方法，传入第一个任务，</span></span><br><span class="line">       Worker(Runnable firstTask) &#123;</span><br><span class="line">           setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">           <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">           <span class="comment">/// 将自身引用传入，通过线程池的线程工厂创建线程，</span></span><br><span class="line">           <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，<code>Worker</code>内部的Thread运行时，会调用<code>Worker</code>自身的run方法，看看<code>Worker</code>的run方法做了哪些事。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            runWorker(<span class="built_in">this</span>);<span class="comment">/// 调用外部ThreadPoolExecutor实例的runWorker方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ThreadPoolExecutor的runWorker方法"><a href="#ThreadPoolExecutor的runWorker方法" class="headerlink" title="ThreadPoolExecutor的runWorker方法"></a>ThreadPoolExecutor的runWorker方法</h4><p>来到<code>ThreadPoolExecutor</code>的runWorker方法，这个方法极其关键！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();<span class="comment">/// 1、获取当前线程，也就是worker内的线程</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;<span class="comment">/// 2、获取worker内的firstTask，第一个任务</span></span><br><span class="line">        w.firstTask = <span class="literal">null</span>;<span class="comment">/// 3、worker内的firstTask置空</span></span><br><span class="line">        w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">/// 4、worker内的线程是否突然结束的标志</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;<span class="comment">/// 5、判断任务是否为空，否则通过getTask方法从工作队列获取任务</span></span><br><span class="line">                w.lock();</span><br><span class="line">                <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">                <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">                <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">                <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforeExecute(wt, task);<span class="comment">/// 6、调用任务之前的通知，空实现，子类可覆盖实现</span></span><br><span class="line">                    <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        task.run();<span class="comment">/// 7、调用任务的run方法执行任务！！！</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        afterExecute(task, thrown);<span class="comment">/// 8、调用任务结束之后的通知，空实现，子类可覆盖实现</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="literal">null</span>;<span class="comment">/// 9、任务执行结束后，置空</span></span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly = <span class="literal">false</span>;<span class="comment">/// 10、worker执行任务期间没有抛异常，worker内的线程正常结束工作</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            processWorkerExit(w, completedAbruptly); <span class="comment">/// 11、处理worker的退出逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>到这里，线程复用的机制很明了了：<strong>通过循环不断从工作队列中获取任务并执行</strong>；</p><p>不难总结出<code>Worker</code>的工作机制：<strong>worker通过实现Runnable接口，内部维护一个Thread线程对象，将自身作为“跳板”，优先执行自身初始化时携带的任务，之后不断消费（执行）线程池工作队列中的任务，直到队列中任务没有任务为止，worker的任务就结束了。</strong></p><p>用图表示<code>ThreadPoolExecutor</code>的runWorker方法主要的执行过程如下：</p><p><img src="/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/%E7%BA%BF%E7%A8%8B%E6%B1%A0runWorker%E6%96%B9%E6%B3%95.svg"></p><p>不过目前为止，我们还是没发现和核心线程与非核心线程相关的痕迹，带着疑问继续往下走。</p><h3 id="核心线程的维持、非核心线程的存活控制"><a href="#核心线程的维持、非核心线程的存活控制" class="headerlink" title="核心线程的维持、非核心线程的存活控制"></a>核心线程的维持、非核心线程的存活控制</h3><p>阅读<code>ThreadPoolExecutor</code>的runWorker方法，不难发现，每个<code>Worker</code>对象结束使命后，都会走到<code>ThreadPoolExecutor</code>的processWorkerExit方法执行退出逻辑。该方法入参除了<code>Worker</code>对象以外还需要传入一个boolean类型的completedAbruptly参数，见明之意，该参数表示该<code>Worker</code>对象是否是“突然结束”，不难发现只有任务task执行期间抛出异常或error，<code>Worker</code>对象才算是“突然结束”，completedAbruptly为true，反之正常结束，completedAbruptly为false。</p><h4 id="ThreadPoolExecutor的processWorkerExit方法"><a href="#ThreadPoolExecutor的processWorkerExit方法" class="headerlink" title="ThreadPoolExecutor的processWorkerExit方法"></a>ThreadPoolExecutor的processWorkerExit方法</h4><p>综上所述，processWorkerExit方法职责就是处理<code>Worker</code>对象正常与非正常的结束，也可以理解为对<code>Worker</code>的回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processWorkerExit</span><span class="params">(Worker w, <span class="type">boolean</span> completedAbruptly)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">            decrementWorkerCount();<span class="comment">/// 1、从上一行的英文注释和该方法的意义可知，对于非正常的结束的worker，需要调整当前线程池记录的worker数量，这里暂时不必关心如何调整</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            completedTaskCount += w.completedTasks;<span class="comment">/// 2、记录worker完成的任务数量到总完成数上</span></span><br><span class="line">            workers.remove(w);<span class="comment">/// 3、从HashSet中移除该worker</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tryTerminate();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;<span class="comment">/// 4、如果此时线程池状态不是结束状态</span></span><br><span class="line">            <span class="keyword">if</span> (!completedAbruptly) &#123;<span class="comment">/// 5、如果worker正常结束，if 内的逻辑可不关心</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">                <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                    min = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">            &#125;</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);<span class="comment">/// 6、worker非正常结束，说明执行任务时抛了异常，需要补充一个新的worker，因为是补充的，其firstTask是null，而且是以非核心线程的设置去补充的</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>小总结一下processWorkerExit主要干了几件事：</p><ol><li>记录<code>Worker</code>对象完成的任务数到总记录中</li><li>移除该<code>Worker</code>对象</li><li>处理非正常结束<code>Worker</code>对象时，调整线程池记录的worker数量，补充一个新的worker且是以非核心线程的设定去补充的</li></ol><p>提一下为什么<code>Worker</code>非正常结束时要补充新的<code>Worker</code>：</p><ul><li>再仔细看runWorker方法，因为<code>Worker</code>非正常结束说明任务task的run方法抛出了异常（或error），尽管做了try-catch处理，作者的做法是把异常继续往抛出，而处理<code>Worker</code>的回收工作processWorkerExit方法是在finally块执行的，也就是说processWorkerExit方法执行完之后，异常就要被抛出去了，虚拟机接受到异常之后，就会销毁该线程，也就是销毁<code>Worker</code>内的Thread（线程死亡），此时需要补充新的<code>Worker</code>继续干活。</li><li><em>此处给读者留下一个小思考：既然runWorker方法catch到了异常或error，可以不抛出去吗？</em></li></ul><p>不过跟踪到这里还是没发现核心线程与非核心线程相关的操作，而且在补充新的worker时，还是以非核心线程去补充的，这也是疑问点，并且如果每个<code>Worker</code>使命结束后都要移除了，<code>Worker</code>内的线程也执行完代码也要结束生命了，说好的核心线程不会被销毁呢？</p><h4 id="ThreadPoolExecutor的getTask方法"><a href="#ThreadPoolExecutor的getTask方法" class="headerlink" title="ThreadPoolExecutor的getTask方法"></a>ThreadPoolExecutor的getTask方法</h4><p>回过头看，我们还差一个方法没有分析，那就是<code>ThreadPoolExecutor</code>的getTask方法，在runWorker方法中<code>Worker</code>通过getTask从工作队列中获取任务，不难得出：<strong>如果获取的任务为null，Worker将被回收</strong>。而工作队列是阻塞队列，所以如果<code>Worker</code>在获取任务时被阻塞，那么就不会被回收，从而实现<code>Worker</code>内Thread的“常驻”效果，这确实是个思路。话不多说进源码。</p><p>下列代码笔者将保留原生的官方英文注释，增加自己的注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/// 1、超时的标记变量，官方注释很明了：是否是因为上一次执行阻塞队列poll 方法导致的超时</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// 2、注意这里的判断，如果为true，说明线程池状态不处于running，如果是shutdow，则再判断工作队列是否为空，为空则返回null，其余的状态也返回null，worker将被回收</span></span><br><span class="line">            <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">                decrementWorkerCount();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);<span class="comment">/// 3、获取当前worker数量</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/// 4、当允许核心线程超时（默认是不允许false）或当前worker数量大于核心线程数时，表示该worker可能需要回收，这里利用一个boolean来标记</span></span><br><span class="line">            <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"><span class="comment">/// 5、满足指定条件（注意两个逻辑或运算以及逻辑或运算的特点），说明该worker的确需要回收</span></span><br><span class="line">            <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">                &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))<span class="comment">/// 6、尝试比较并将worker总记录数减1，成功返回null，失败则进入下一次循环</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ? </span><br><span class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<span class="comment">/// 7、该worker可能需要回收，则调用 poll 方法等待一定时间</span></span><br><span class="line">                    workQueue.take();<span class="comment">/// 8、该worker不需要回收，take 方法一直等待直到获取到任务</span></span><br><span class="line">                <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                timedOut = <span class="literal">true</span>;<span class="comment">/// 9、如果为null，那一定是调用 poll 方法超时了</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;<span class="comment">/// 10、捕获队列出队时可能的中断异常，暂时不必关系</span></span><br><span class="line">                timedOut = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码比较短但是比较精妙，需要反复揣摩，下面贴出笔者制作的流程图</p><p><img src="/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/ThreadPoolExecutor%E7%9A%84getTask%E6%96%B9%E6%B3%95.svg"></p><p>到此，终于看到线程池七八成左右的真身了：runWorker方法使worker不断执行任务和任务通知，processWorkerExit方法负责worker的回收工作，而<strong>getTask方法负责从工作队列获取任务进一步控制worker内Thread的阻塞等待，进一步控制worker的回收，从而实现核心线程的常驻效果和非核心线程的存活控制。</strong></p><h2 id="提交优先级与执行优先级"><a href="#提交优先级与执行优先级" class="headerlink" title="提交优先级与执行优先级"></a>提交优先级与执行优先级</h2><p>有如下程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>,<span class="number">20</span>,</span><br><span class="line">               <span class="number">300L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>),</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">           System.out.println(<span class="string">&quot;execute: &quot;</span> + i);</span><br><span class="line">           <span class="keyword">final</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;</span><br><span class="line">           executor.execute(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">               System.out.println(<span class="string">&quot;start run number: &quot;</span> + n);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   TimeUnit.SECONDS.sleep(<span class="number">100000L</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问：提交到第几个任务（i &#x3D; ?）时，线程池拒绝执行任务而抛出异常？</p><p>答：i &#x3D; 31时。</p><p>线程池可接受的最大任务数量为：最大线程数+工作队列容量&#x3D;30。上述每个任务都进行了一次长时间睡眠，显然for循环体积任务执行完之前，线程池内没有一个任务执行完。</p><p>值得注意的是，控制台打印的“start run number: {n}”字符串，应该是1到10左右先被打印，其次是21到130后被打印，最后是11到120区间的数字被打印，而不是我们生活中任务认为的“先提交就先得到执行”。</p><p>于是结合addWorker方法得出线程池<strong>提交优先级</strong>：</p><p>核心线程 &gt; 工作队列 &gt; 非核心线程</p><p>于是结合getTask方法得出线程池<strong>执行优先级</strong>：</p><p>核心线程 &gt; 非核心线程 &gt; 工作队列</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过以上4个方法的解读，我们可以重新认识worker对象：</p><ul><li>通俗的说每个worker被创建之后，其使命就是不断从工作队列领取任务去执行，在<strong>无任务可执行</strong>（不是任务全部执行完毕，两者概念差别很大），即领取不到任务之后，就要被回收。</li></ul><p>不仅如此，核心线程与非核心线程也要重新理解：</p><ul><li>核心线程：worker对象内的线程在获取任务前，线程池状态处于running，此时若当前worker数（反应线程池内的线程数）小于等于设置的核心线程数，该线程以<strong>poll</strong>方式方式获取任务，若工作队列无任务，则该线程将一直等待新的任务提交进来，该线程也就顺理成章的成为线程池常驻线程，也就是核心线程</li><li>非核心线程：worker对象内的线程在获取任务前，线程池状态处于running，此时若当前worker数（反应线程池内的线程数）大于设置的核心线程数，该线程以<strong>take</strong>方式方式获取任务，若工作队列无任务，则该线程将等待新的任务提交进来，等待时长为<strong>keepAliveTime</strong>，超时之后便会被对应worker被回收，等待期间该线程也就成为线程池非核心线程。</li></ul><p>所以每个worker内的线在启动工作期间都是相同的性质，不分核心与非核心，只有工作队列<strong>无任务可执行</strong>时，才能明确线程的性质是核心还是非核心，同时也决定了worker的回收与否（既分高下，也决生死？！）。</p><p>回过头来看addWorker方法中表示线程类型的core参数，也只是参与了当前worker数与核心线程数或非核心线程数的比较，再无他用，这也说的通了。</p><p>在阅读这些方法中，我们跳过了一些“影响阅读”的代码，如worker自身的lock和unlock究是为了防止啥，<code>ThreadPoolExecutor</code>成员变量中<code>ReentrantLock</code>的mainLock保证了什么的线程安全，以及线程池自身的其它功能，如线程池的worker数量和状态等如何感知的……请听下回合分解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Java多线程" scheme="https://blog.windshadow.cn/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="Java线程池原理" scheme="https://blog.windshadow.cn/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>MySql索引详解</title>
    <link href="https://blog.windshadow.cn/MySql%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/"/>
    <id>https://blog.windshadow.cn/MySql%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-07-14T08:20:46.904Z</published>
    <updated>2024-08-12T17:18:55.345Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>了解索引之前先了解一下约束。</p><h2 id="约束（constraint）"><a href="#约束（constraint）" class="headerlink" title="约束（constraint）"></a>约束（constraint）</h2><p>约束实际上就是表中数据的限制条件 ，表在设计的时候加入约束的目的就是为了保证表中的记录完整和有效 ，常见约束如下</p><h3 id="非空约束（not-null）"><a href="#非空约束（not-null）" class="headerlink" title="非空约束（not null）"></a>非空约束（not null）</h3><p>约束的字段不能为null</p><h3 id="唯一性约束（unique）"><a href="#唯一性约束（unique）" class="headerlink" title="唯一性约束（unique）"></a>唯一性约束（unique）</h3><p>约束的字段是唯一的（可以为null），Mysql会为该字段会自动创建索引。</p><p>唯一性约束也称<strong>列级约束</strong>。</p><h3 id="主健约束（primary-key-简称PK-）"><a href="#主健约束（primary-key-简称PK-）" class="headerlink" title="主健约束（primary key(简称PK)）"></a>主健约束（primary key(简称PK)）</h3><p>表中的某个字段添加主键约束后，该字段为主键字段，主键字段中出现的每一个数据都称为主键值，必须唯一且不能为null，即primary key &#x3D; unique + not null。当一个字段同时被非空约束和唯一性约束时，自动成为主键。<strong>但oracle并不如此。</strong></p><p>主键约束也称<strong>表级约束</strong>。</p><ul><li>单一主键：给一个字段添加主键约束</li><li>复合主键：给多个字段联合添加一个主键约束(只能用表级定义)，用的少</li></ul><h3 id="外键约束（foreign-key-简称FK-）"><a href="#外键约束（foreign-key-简称FK-）" class="headerlink" title="外键约束（foreign key (简称FK)）"></a>外键约束（foreign key (简称FK)）</h3><p>若有两个表A、B，id是A的主键，而B中也有id字段，则id就是表B的外键，外键约束主要用来维护两个表之间数据的一致性。</p><p>某个字段添加外键约束之后，该字段称为外键字段，外键字段中每个数据都是外键值。</p><ul><li>外键必须至少是受唯一性约束的。</li><li>外键值可以为null。</li><li>一张表可以有多个外键字段。</li></ul><h3 id="检查约束（check-mysql不支持，oracle支持））"><a href="#检查约束（check-mysql不支持，oracle支持））" class="headerlink" title="检查约束（check (mysql不支持，oracle支持））"></a>检查约束（check (mysql不支持，oracle支持））</h3><p>略</p><h2 id="索引概念"><a href="#索引概念" class="headerlink" title="索引概念"></a>索引概念</h2><p>MySql官方对索引的定义为：索引（Index)）是帮助MySql高效获取数据的数据结构。</p><p>提取句子主干，就可以得到索引的本质：索引是数据结构。</p><p>在mysql当中，使用<code>explain</code>关键字查看一个SQL语句是否使用了索引进行检索</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_user</span><br></pre></td></tr></table></figure><p>观察查询结果<code>key</code>列中是否列出了显示MySQL实际决定使用的键(索引) ，未使用则为null。</p><p>同时，<strong>索引是各种数据库进行优化的重要手段</strong>。</p><h2 id="索引实现原理"><a href="#索引实现原理" class="headerlink" title="索引实现原理"></a>索引实现原理</h2><ul><li>在MySql当中，索引是一个单独的对象，不同的存储引擎以不同的形式存在。</li><li>在MyISAM存储引擎中，索引存储在一个.MYI文件中。</li><li>在InnoDB存储引擎中索引存储在表空间（tablespace）中。</li><li>在MEMORY存储引擎当中索引被存储在内存当中。</li><li>不管索引存储在哪里，索引在mysql当中都是一个<strong>B+树</strong>的形式存在。</li></ul><p><em>（至于为啥MySql使用B+树作为存储的数据结构，一时半会也说不明白，笔者也是略知一二，不想在这强行装X，目前知道B+树的结构就好了）</em></p><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><p>是最基本的索引，它没有任何限制。</p><p>创建示例：</p><ul><li><p>直接创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name ON table(column(length));</span><br></pre></td></tr></table></figure></li><li><p>修改表结构创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &#x27;table_name&#x27; ADD INDEX index_name ON (column(length));</span><br></pre></td></tr></table></figure></li><li><p>创建表时创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `table` (</span><br><span class="line">    `id` int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">    `org` char(255) CHARACTER NOT NULL ,</span><br><span class="line">    PRIMARY KEY (`id`),</span><br><span class="line">    INDEX index_name (org(length))</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><p>删除索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX index_name ON table</span><br></pre></td></tr></table></figure><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>与普通索引类似，不同之处在于：索引列的值必须唯一，但允许有空值，即列受<strong>唯一性约束（unique</strong>）；显然的，一张表可以有多个唯一索引。</p><p>创建唯一索引：</p><ul><li><p>直接创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX index_name ON table(column(length));</span><br></pre></td></tr></table></figure></li><li><p>修改表结构创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &#x27;table_name&#x27; ADD UNIQUE index_name ON (column(length));</span><br></pre></td></tr></table></figure></li><li><p>创建表时创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `table` (</span><br><span class="line">    `id` int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">    `org` char(255) CHARACTER NOT NULL ,</span><br><span class="line">    PRIMARY KEY (`id`),</span><br><span class="line">    UNIQUE  index_name (org(length))</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>一种特殊的唯一索引。</p><ul><li>主键不可重复，只能有一个列作为主键</li><li>一张表中主键索引只能存在一个</li></ul><p>一般是在建表的时候同时创建主键索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `table_name` (</span><br><span class="line">    `id` int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">    `org` char(255) CHARACTER NOT NULL ,</span><br><span class="line">    PRIMARY KEY (`id`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="组合（复合、联合）索引"><a href="#组合（复合、联合）索引" class="headerlink" title="组合（复合、联合）索引"></a>组合（复合、联合）索引</h3><p>指多个字段上创建的索引</p><ul><li>组合索引中，列值的组合必须唯一。</li><li>只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。</li><li>使用组合索引时遵循最左前缀集合</li></ul><p>创建方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &#x27;table_name&#x27; ADD INDEX fa_fb_fc (fa,fb,fc); </span><br></pre></td></tr></table></figure><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p> InnoDB 存储引擎在MySql 5.6 之后才支持。</p><p>只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &#x27;table_name&#x27; ADD FULLTEXT INDEX index_name (column1,column2,...);</span><br></pre></td></tr></table></figure><p>跟普通索引稍有不同，使用全文索引的格式<code>MATCH (columnName) AGAINST (&#39;string&#39;)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `table_name` WHERE MATCH(`name`) AGAINST(&#x27;马&#x27;)</span><br></pre></td></tr></table></figure><p>match() 函数中指定的列必须和全文索引中指定的列完全相同，否则就会报错，无法使用全文索引，这是因为全文索引不会记录关键字来自哪一列。如果想要对某一列使用全文索引，需要单独为该列创建全文索引。</p><h2 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h2><p>常见的索引失效情况：</p><ol><li><p>以”%”开头进行模糊查询，索引失效（后缀有%时 不失效）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 有索引</span><br><span class="line">ALTER TABLE tableName ADD INDEX （col); </span><br><span class="line">select * from tableName where col like &#x27;%T&#x27;;</span><br></pre></td></tr></table></figure><p>尽量避免模糊查询的时候以”%”开始,这是一种优化的手段&#x2F;策略。</p></li><li><p>or 操作两边未同时使用索引，索引失效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 有索引</span><br><span class="line">ALTER TABLE tableName ADD INDEX （col1); </span><br><span class="line"># or 查询</span><br><span class="line">select * from tableName where col1 = 100 or col2 = &#x27;tom&#x27;;</span><br></pre></td></tr></table></figure><p>如果使用or那么要求or两边的条件字段都要有索引，才会走索引，如果其中一边有一个字段没有索引，那么另一个字段上的索引也会失效。</p></li><li><p>使用组合（复合）索引时，未使用左侧的列，索引失效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 有索引</span><br><span class="line">ALTER TABLE tableName ADD INDEX fa_fb_fc (fa,fb,fc); </span><br><span class="line"># 查询时未使用左侧的列</span><br><span class="line">select * from tableName where fc = 100;</span><br></pre></td></tr></table></figure><p>遵循最左前缀集合。</p></li><li><p>数据类型出现隐式转化。如varchar不加单引号的话可能会自动转换为int型，使索引无效，产生全表扫描</p></li><li><p>在索引字段上使用not，&lt;&gt;，!&#x3D;。不等于操作符是永远不会用到索引，对它的处理只会产生全表扫描。 优化方法： key&lt;&gt;0 改为 key&gt;0 or key&lt;0。很显然，索引是想知道你要什么而不是你不要什么，你品你细品。</p></li><li><p>索引的列参加了运算，索引失效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 有索引</span><br><span class="line">ALTER TABLE tableName ADD INDEX fa_fb_fc (fa,fb,fc); </span><br><span class="line"># 查询</span><br><span class="line">select * from tableName where fa + 1 = 101;</span><br></pre></td></tr></table></figure><p>说实话，没人写这种sql吧。</p></li><li><p>索引的列使用了函数，索引失效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 有索引</span><br><span class="line">ALTER TABLE tableName ADD INDEX fa_fb_fc (fa,fb,fc); </span><br><span class="line"># 查询</span><br><span class="line">select * from tableName where lower(fb)= &#x27;tom&#x27;;</span><br></pre></td></tr></table></figure></li></ol><p>还有一点要注意的是：当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效。</p><p>说白了就一句话：索引是想要你直接告诉它你想要什么，而不是你不要什么，也不是你把这个东西（字段）包装之后，说包装完就是这样子，给我找。<code>┐(´-｀)┌</code>  </p><h2 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h2><p>mysql的索引分为两大类：<strong>聚簇索引、非聚簇索引</strong>，<strong>它们不是一种单独的索引类型，而是一种数据存储方式</strong></p><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>将数据存储与索引放到了一块，找到索引也就找到了<strong>数据（严格来说这里的数据指的是行的物理位置</strong>），由于聚簇索引是将数据跟索引结构放到一块，因此一个表仅有一个聚簇索引。</p><p>如果表中没有定义主键，则第一个not NULL unique列是聚集索引。如果没有这样的索引，InnoDB 会隐式定义一个主键来作为聚簇索引。</p><p>下面是聚簇索引B+树的结构示意图</p><p><img src="/MySql%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/MySql%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.svg"></p><h3 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h3><p>非聚簇索引也叫辅助索引或二级索引，非聚簇索引叶子节点存储的不再是<strong>数据（行的物理位置</strong>），而是主键值</p><p>下面是非聚簇索引B+树的结构示意图</p><p><img src="/MySql%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/MySql%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.svg"></p><h3 id="回表-1"><a href="#回表-1" class="headerlink" title="回表"></a>回表</h3><p>先通过非聚簇索引定位到主键值，在通过聚簇索引定位到行记录，这就是所谓的<strong>回表或回表查询</strong>，先定位主键值，再定位行记录，它的性能较扫一遍索引树更低。</p><h2 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h2><p>MySql官网类似的说法是：使用explain查询计划时，explain的输出结果Extra字段为Using index时，能够触发索引覆盖。</p><p>也就是如果触发了索引覆盖，那么explain输出的Extra字段为Using index。</p><p>一般的说法是：索引中已经包含所有需要读取的列的查询称为覆盖索引。</p><p>就是利用优化器的优化机制，只搜索了非聚簇索引，不进行回表操作，然后达到select的目的。一般主要适用于select出的字段很少的情况。</p><p>举例：</p><p>有张user表（PK id,name, age, email, address，……），我们的模板是<code>select name, age</code> ，然后只需要建立一个name和age的复合索引，然后这个非聚簇索引的叶子节点有了这两个字段和主键字段（虽然主键在这里没啥用）。然后执行器只需要搜索这个二级索引即可，不需要回表操作就完成了select查询操作。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>主键上以及unique字段是上都会自动添加索引</li><li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行insert、update和delete时。因为更新表时，不仅要保存数据，还要保存一下索引文件。</li><li>建立索引会占用磁盘空间的索引文件。一般情况影响不大，但如果在一个大的表上创建了多种组合索引，索引文件大小会增长的很快。</li><li>索引只是提高效率的一个因素，如果有大数据量的表，就需要花时间研究建立最优的索引，或优化查询语句。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="MySql" scheme="https://blog.windshadow.cn/categories/MySql/"/>
    
    
  </entry>
  
  <entry>
    <title>MySql事务</title>
    <link href="https://blog.windshadow.cn/MySql%E4%BA%8B%E5%8A%A1/"/>
    <id>https://blog.windshadow.cn/MySql%E4%BA%8B%E5%8A%A1/</id>
    <published>2021-07-14T07:24:30.795Z</published>
    <updated>2021-07-15T05:35:08.460Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前提摘要：MySql只有使用InnoDB 引擎时才支持事务，MyISAM 引擎不支持事务</p><p><strong>存储引擎</strong>：存储引擎是MySql中特有的一个术语，其它数据库中没有，比如oracle中有，但是不叫这个名字。</p><p>存储引擎听着高端大气上档次，实际上存储引擎是一个表存储&#x2F;组织数据的方式。不同的存储引擎，表存储数据的方式不同。</p><h2 id="事务的基础知识点"><a href="#事务的基础知识点" class="headerlink" title="事务的基础知识点"></a>事务的基础知识点</h2><ul><li><strong>只有DM语句（insert、delete、update）才会有事务这一说</strong>，其它语句和事务无关! ! !因为只有以上的三个语句是数据库表中数据进行增、删、改的。只要操作一旦涉及到数据的增、删、改，那么就一定要考虑安全问题。</li><li><strong>InnoDB存储引擎提供一组用来记录事务性活动的日志文件</strong></li><li>MySql默认开启自动提交<code>auto commit</code>，开启MySql的事务<code>start transcation</code>可关闭自动提交，需要手动提交会回滚事务。</li><li>提交事务（commit）：清空事务性活动的日志文件，将数据全部彻底持久化到数据库表中。提交事务标志着，事务的结束。并且是一种全部成功的结束。</li><li>回滚事务(rollback)：将之前所有的DML操作全部撤销，并且清空事务性活动的日志文件。回滚事务标志着，事务的结束。并且是一种全部失败的结束。</li></ul><h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><p>ACID：</p><ul><li>A（Atomicity）原子性：指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</li><li>C（Consistency）一致性：事务前后数据的<strong>完整性</strong>必须保持一致。</li><li>I（Isolation）隔离性：事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。</li><li>D（Durability）持久性：持久性是指一个事务一旦被提交，它对数据库中数据的改变应该永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</li></ul><h2 id="MySql事务隔离级别"><a href="#MySql事务隔离级别" class="headerlink" title="MySql事务隔离级别"></a>MySql事务隔离级别</h2><p>4个隔离级别，从低到高</p><h3 id="1-读未提交（-read-uncommitted）"><a href="#1-读未提交（-read-uncommitted）" class="headerlink" title="1. 读未提交（ read uncommitted）"></a>1. 读未提交（ read uncommitted）</h3><p>描述：事务A可读取到事务B的未提交的数据；</p><p>存在问题：<strong>脏读</strong></p><p>这种隔离级别一般都是理论上的，大多数的数据库隔离级别都是2档起步！</p><h3 id="2-读已提交（-read-committed）"><a href="#2-读已提交（-read-committed）" class="headerlink" title="2. 读已提交（ read committed）"></a>2. 读已提交（ read committed）</h3><p>描述：事务A只能读取到事务B的提交后的数据；</p><p>解决了脏读问题；</p><p>存在问题：<strong>不可重复读</strong></p><p>这种隔离级别是比较真实的数据，每一次读到的数据是绝对的真实。oracle数据库默认的隔离级别是: read committed。</p><h3 id="3-可重复读（repeatable-read）"><a href="#3-可重复读（repeatable-read）" class="headerlink" title="3. 可重复读（repeatable read）"></a>3. 可重复读（repeatable read）</h3><p>描述：事务A开启之后，不管是多久，每一次在事务A中读取到的数据都是一致的。即使事务B将数据已经修改，并且提交了，事务A读取到的数据还是没有发生改变，这就是可重复读。</p><p>存在问题：<strong>幻读</strong></p><p>mysql中默认的事务隔离级别是：repeatable read。</p><h3 id="4-串行化（serializable）"><a href="#4-串行化（serializable）" class="headerlink" title="4. 串行化（serializable）"></a>4. 串行化（serializable）</h3><p>事务最高隔离级别，效率最低，类似Java中使用synchronize进行线程同步，此处便是事务同步，将事务串行化执行。</p><h3 id="事务并发问题"><a href="#事务并发问题" class="headerlink" title="事务并发问题"></a>事务并发问题</h3><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据。</p><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>事务 A 多次读取同一条数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致（不能重复读）。</p><p>举例，有事务T1、T2</p><p>T1：1、根据条件X查询一组数据；2、对该组的每条记录进行修改；3、根据条件X查询一组数据；</p><p>T2：1、插入满足条件X的一条记录；</p><p>当T2的步骤1在T1的步骤1之后执行，提交之后，T1的步骤3再次查询时，发现有一条记录没有被更改，这就是不可重复读。</p><p>不可重复读通常针对数据更新（UPDATE）操作来说的。</p><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>举例，有两个事务T1、T2</p><p>T1：1、查询主键id为1001的数据，结果为不存在；2、插入id为1001的数据；</p><p>T2：1、插入id为1001的数据；</p><p>当T2的步骤1在T1的步骤1之后执行，提交之后，T1的步骤2因为主键冲突将无法执行。就好比T1“见鬼”了，明明查询不存在但是插入失败。</p><p>幻读更针对于对数据插入（INSERT）操作和删除（DELETE）来说的。</p><p><strong>不可重复读和幻读的区别</strong></p><p>网上有很多幻读的例子，但是讲的都略微牵强，经笔者查阅和理解，不可重复的侧重于两次读的操作，即：读-读。而幻读侧重于：读-写。上述幻读的例子中，T1的步骤1不能支持其步骤2的进行。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交（read uncommitted）</td><td>是</td><td>是</td><td>是</td></tr><tr><td>读已提交（read committed）</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读（repeatable read）</td><td>否</td><td>否</td><td>是</td></tr><tr><td>串行化（serializable）</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><p>隔离级别越高，越能保证数据的完整性和一致性，对并发性能的影响也越大。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="MySql" scheme="https://blog.windshadow.cn/categories/MySql/"/>
    
    
  </entry>
  
  <entry>
    <title>Java线程池原理（一）</title>
    <link href="https://blog.windshadow.cn/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://blog.windshadow.cn/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-07-10T10:57:11.024Z</published>
    <updated>2024-08-12T17:10:04.583Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java线程池原理（一）"><a href="#Java线程池原理（一）" class="headerlink" title="Java线程池原理（一）"></a>Java线程池原理（一）</h1><p>众所周知<strong>Executor</strong>框架中的<code>ExecutorService</code>接口的实现就是<code>ThreadPoolExecutor</code>线程池，本文《Java线程池原理》系列从源码角度捋一捋线程池的重点实现。</p><p>在此之前先聊聊<code>ThreadPoolExecutor</code>的作者：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Doug%20Lea/6319404?fr=aladdin">Doug Lea</a></p><p><img src="/./Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/Doug.jpg" alt="Doug Lea"></p><p>Doug Lea是 java.util.concurrent 包（JUC）的作者，不少网友评价Doug Lea是JDK史上最牛*的程序员，甚至有人感叹：“编程不识Doug Lea，写尽java也枉然”。</p><p><img src="/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/nb.gif"></p><p>接下来盘点<code>ThreadPoolExecutor</code>线程池的基本工作原理和<code>Executors</code>工具类提供的几种常见线程池的效果，简单入个门。</p><h2 id="线程池存在的意义"><a href="#线程池存在的意义" class="headerlink" title="线程池存在的意义"></a>线程池存在的意义</h2><p>我们知道当下常见的jvm使用的线程都是内核级线程（KLT）。显然，线程是稀缺资源，它的创建与销般是一个相对偏重且耗资源的操作，而Java线程依赖于内核线程，创建线程需要进行操作系统状态切换，<strong>为避免资源过度消耗需要设法重用线程执行多个任务</strong>。</p><p>所以线程池就是一个线程缓存，负责对线程进行统一分配、调优与监控。</p><p>一般什么时候使用线程池？</p><ul><li>单个任务处理时间比较短</li><li>需要处理的任务数量很大</li><li>比较耗时的任务不建议使用线程池，因为容易造成任务的堆积</li></ul><h2 id="线程池基本工作原理"><a href="#线程池基本工作原理" class="headerlink" title="线程池基本工作原理"></a>线程池基本工作原理</h2><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>jdk提供的线程池实现为<code>ThreadPoolExecutor</code>类（常用就这个类）</p><p><img src="/./Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/ThreadPoolExecutor.png" alt="ThreadPoolExecutor"></p><p>其中前3个构造方法都依赖最后一个构造方法，其含义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, /// 核心线程数</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize, /// 最大线程数</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime, /// 非核心线程空闲后的存活时间的数量值</span></span><br><span class="line"><span class="params">                          TimeUnit unit, /// 非核心线程空闲后的存活时间的单位</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue, /// 工作队列（阻塞队列）</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory, /// 线程工厂，主要负责创建线程</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123; <span class="comment">/// 拒绝策略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拓扑如下</p><p><img src="/./Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BB%84%E6%88%90.svg" alt="Java 线程池 ThreadPoolExecutor "></p><ul><li><p>线程工厂：负责创建线程</p></li><li><p>工作队列：一个保存任务的阻塞队列（阻塞队列：多线程下保证队列的FIFO特性）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">    <span class="comment">// 通过Runnable对象创建线程</span></span><br><span class="line">    Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Worker：线程池实现线程复用以执行任务的核心对象（见下文），自身实现了<code>Runnable</code>接口且内部维护了一个<code>Thread</code>线程对象</p></li><li><p>核心线程：Worker对象内的线程，线程池常驻线程，成为核心线程的线程不会被销毁</p></li><li><p>非核心线程：Worker对象内的线程，成为非核心线程的线程进入空闲后，只会存活一定时间（keepAliveTime），之后便正常结束线程。</p></li><li><p>拒绝策略：任务无法添加时，线程池执行拒绝策略。<code>ThreadPoolExecutor</code>提供四种如图所示的拒绝策略，实现<code>RejectedExecutionHandler</code>接口自身定义拒绝策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h3><p>类似线程的状态，线程池也有自己的状态</p><ul><li><p>Running：运行状态，接受新任务，也能处理工作队列里的任务</p></li><li><p>Shutdown：关闭状态，不接受新任务，但是处理工作队列里的任务</p></li><li><p>Stop：停止状态，不接受新任务，不处理工作队列里的任务，中断正在处理中的任务</p></li><li><p>Tidying：整理状态，当所有的任务都执行完了，当前线程池已经没有工作线程，这时线程池将会转换为Tidying状态，并且将要调用terminated方法。terminated方法调用完毕之后，线程池进入Terminated状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">terminated</span><span class="params">()</span> &#123; &#125; <span class="comment">/// ThreadPoolExecutor terminated方法为空实现，子类可覆盖实现</span></span><br></pre></td></tr></table></figure></li><li><p>Terminated：终止状态，terminated方法调用完毕之后，线程池进入Terminated状态。</p></li></ul><p>其关系如图（对线程池工作原理有所了解后再回头看此状态转换图会更好）。</p><p><img src="/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81.svg"></p><h3 id="线程池添加任务流程"><a href="#线程池添加任务流程" class="headerlink" title="线程池添加任务流程"></a>线程池添加任务流程</h3><p>我相信大多数人都比较清楚线程池添加任务的流程，各种博客网图巴拉巴拉，这里再哔哔一下线程池提交任务的流程，如下：</p><p><img src="/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E6%B5%81%E7%A8%8B.svg" alt="线程池执行任务流程"></p><p>我们通常通过执行<code>ThreadPoolExecutor</code>实现<code>Executor</code>接口的execute方法（<code>Executor#execute(Runnable)</code>）来提交任务，这个流程就是来自该方法的实现！！！</p><p>贴一下源码，官方注释给你讲的明明白白，代码也很清晰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">         * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">         * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">         * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">         * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">         * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">         * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">         * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">         * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">         * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">         * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">         * and so reject the task.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123; <span class="comment">/// 1、核心线程是否已经满</span></span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))<span class="comment">/// 2、添加worker，以核心线程消费任务(第二个参数为true)</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<span class="comment">/// 3、添加到工作队列是否可行</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))<span class="comment">/// 4、添加worker，以非核心线程消费任务(第二个参数为false)</span></span><br><span class="line">            reject(command);<span class="comment">/// 5、如果添加失败，说明非核心线程是否已经满，执行拒绝策略</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Executors工具类提供的常见线程池"><a href="#Executors工具类提供的常见线程池" class="headerlink" title="Executors工具类提供的常见线程池"></a>Executors工具类提供的常见线程池</h2><h3 id="可缓存线程池Executors-newCachedThreadPool"><a href="#可缓存线程池Executors-newCachedThreadPool" class="headerlink" title="可缓存线程池Executors.newCachedThreadPool()"></a>可缓存线程池Executors.newCachedThreadPool()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：核心线程数为0，最大线程数为<code>Integer.MAX_VALUE</code>，工作队列为<strong>同步移交队列</strong>；</p><p>新增任务：核心线程数为0 &#x3D;&gt; 任务提交到工作队列 &#x3D;&gt; 工作队列提交时阻塞直到有线程从队列获取任务。</p><p>很显然，每个任务都会交由非核心线程来完成。而非核心线程在任务全部执行完毕后只会存在一定时间（60s），所以这是具有缓存效果的线程池（Cached）。</p><h3 id="固定线程数量线程池Executors-newFixedThreadPool"><a href="#固定线程数量线程池Executors-newFixedThreadPool" class="headerlink" title="固定线程数量线程池Executors.newFixedThreadPool()"></a>固定线程数量线程池Executors.newFixedThreadPool()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>分析：核心线程数为固定值，最大线程数与核心线程数相同，工作队列为<strong>无界队列</strong>；</p><p>无界队列：队列可存储的元素没有上限，概念上是如此，但实际受数据类型值范围限制，所以无界队列在Java中指可存放元素的最大值为<code>Integer.MAX_VALUE</code>的队列。</p><p><code>LinkedBlockingQueue</code>无参构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>(Integer.MAX_VALUE);<span class="comment">// 队列元素最大数量为Integer.MAX_VALUE</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>新增任务：当核心线程数已满时，任务都存到工作队列，由于工作队列是无界的，所以队列永远不会满（概念上不会满），所以非核心线程没有存在的必要，即maximumPoolSize - corePoolSize &#x3D; 0。</p><p>很显然，在固定线程数量线程池中，提交的每个任务都会交由核心线程来完成，核心线程数量固定，非核心线程数量为0，线程池常驻线程数量固定，所以称之为拥有固定线程数量的线程池（Fixed）。</p><h3 id="单线程线程池Executors-newSingleThreadExecutor"><a href="#单线程线程池Executors-newSingleThreadExecutor" class="headerlink" title="单线程线程池Executors.newSingleThreadExecutor()"></a>单线程线程池Executors.newSingleThreadExecutor()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">           (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                   <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                   <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>FinalizableDelegatedExecutorService</code>，仅重写了finalize方法，调用父类<code>DelegatedExecutorService</code>线程池shutdown方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FinalizableDelegatedExecutorService</span> <span class="keyword">extends</span> <span class="title class_">DelegatedExecutorService</span> &#123;</span><br><span class="line">      FinalizableDelegatedExecutorService(ExecutorService executor) &#123;</span><br><span class="line">          <span class="built_in">super</span>(executor);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="built_in">super</span>.shutdown();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>DelegatedExecutorService</code>，该类实现的线程池内部维护了一个实际真正工作的线程池对象，实质是对线程池<code>ExecutorService</code>的一个静态代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DelegatedExecutorService</span> <span class="keyword">extends</span> <span class="title class_">AbstractExecutorService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService e;<span class="comment">/// 我才是干活的线程池</span></span><br><span class="line">    DelegatedExecutorService(ExecutorService executor) &#123; e = executor; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123; e.execute(command); &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>分析：阅读源码后，不难发现该种线程池最终工作的线程池还是<code>ThreadPoolExecutor</code>的实例，而<code>ThreadPoolExecutor</code>实例的核心线程数为1，最大线程数也为1，工作队列为<strong>无界队列</strong>；</p><p>单线程线程池无非就是数量为1的固定数量线程池（Fixed，corePoolSize &#x3D; maximumPoolSize &#x3D; 1），与Fixed线程池不同的是，Single线程池对象在被GC回收时可自动关闭，比较安全，而Fixed线程池的关闭依赖于第三方调用者。</p><p>Single线程池更像一个“孤儿”，干活都是同一个Worker，自生自灭。</p><h2 id="定时任务线程池"><a href="#定时任务线程池" class="headerlink" title="定时任务线程池"></a>定时任务线程池</h2><p>TODO</p><hr><p>PS：在下博客里的图绝大部分都是自己通过<a target="_blank" rel="noopener" href="https://processon.com/">ProcessOn</a>做的，均带有**@WindShadow**水印，这么认真的开发人员哪里找哦</p><p><code>（ ’ - ’ * )</code> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Java多线程" scheme="https://blog.windshadow.cn/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="Java线程池原理" scheme="https://blog.windshadow.cn/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>线程基础与Executor</title>
    <link href="https://blog.windshadow.cn/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8EExecutor/"/>
    <id>https://blog.windshadow.cn/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8EExecutor/</id>
    <published>2021-07-10T04:50:25.252Z</published>
    <updated>2024-08-12T17:22:29.966Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h2><p>线程在现代操作系统中的大致分两种（参考来源：<a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/641914">https://developer.aliyun.com/article/641914</a>）</p><ol><li><p>内核级线程（KLT，Kernel Level Thread）</p><p>线程管理的所有工作（创建和撤销）由操作系统内核完成；操作系统内核提供一个应用程序设计接口API，供开发者使用KLT；</p><p>线程交给内核管理，内核需要维护线程表，线程表保存了寄存器、状态和其他信息。当然每个线程所属进程的进程表也是维护在内核的，内核创建和销毁线程的代价是比较大的。</p></li><li><p>用户级线程（ULT，User Level Thread）</p><p>应用程序可以通过使用用户空间运行线程库被设计成多线程程序。线程的创建，消息传递，调度，保存&#x2F;恢复上下文都有线程库来完成。内核感知不到多线程的存在。内核继续以进程为调度单位，并且给该进程指定一个执行状态（就绪、运行、阻塞等）。</p><p>对照一下，就是将线程的调度放在用户态执行，对于内核来说就像是单线程一样。</p></li></ol><p>而<strong>Java线程创建是依赖于系统内核，通过JVM调用系统库创建内核线程，内核线程与Java-Thread是1:1的映射关系</strong>，当然也有其它映射关系如1：N、N：N，如go语言使用的就是1：N，所以常常go语言被硬吹并发比java高很多就归功于其线程模型。</p><p>KLT与ULT（图片来自于网络）</p><p><img src="/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8EExecutor/ULT%E4%B8%8EKLT.webp" alt="KLT与ULT"></p><h2 id="Java线程基础"><a href="#Java线程基础" class="headerlink" title="Java线程基础"></a>Java线程基础</h2><h3 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h3><ol><li><p>继承<code>Thread</code>类，重写<code>run</code>方法，新建<code>Thread</code>类对象，使用该对象调用<code>Thread</code>类的<code>start</code>方法启动线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWorker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">myWorker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyWorker</span>();</span><br><span class="line">    myWorker.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现<code>Runnable</code>接口，使用<code>Runnable</code>的实例作为构造方法的参数新建<code>Thread</code>类对象，调用<code>Thread</code>对象的<code>start</code>方法创建线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunner</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyRunner</span> <span class="variable">myRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunner</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRunner);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现<code>Callable</code>接口，将<code>Callable</code>实例提交到一个线程池（见下文）<code>ExecutorService</code>中执行任务；准确的说这并不算是创建线程的一个方式，因为<code>ExecutorService</code>接收任务后并不一定创建线程去执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCaller</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;call end&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyCaller</span> <span class="variable">myCaller</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCaller</span>();</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(myCaller);</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="Callable接口出现的必然性"><a href="#Callable接口出现的必然性" class="headerlink" title="Callable接口出现的必然性"></a>Callable接口出现的必然性</h4><p><code>Callable</code>接口与<code>Runnable</code>接口：<code>Callable</code>的<code>call</code>方法有返回值的，且允许抛出异常，<code>Runnable</code>接口的<code>run</code>方法无返回值，不允许抛出异常（这里的异常肯定是检查型异常）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk提供<code>Runnable</code>接口，我们可以在当前线程之外开启子线程去干一些事情（异步），根据<code>Runnable</code>接口的<code>run</code>方法的特点，这个子线程执行了就执行了，我们不清楚这个线程允许情况如何，有时候我们希望子线程执行结束后，我们能拿到些东西，<code>Runnable</code>接口显然并不能满足，于是<code>Callable</code>接口出现了。</p><p>显然“<strong>任务</strong>”这个概念更适合我们对子线程的描述，我们可以这样理解：</p><p><code>Runnable</code>是一个不期望有结果的任务，执行了就执行了，自己做好异常处理；<code>Callable</code>是一个期望有结果的任务，我们可以关心它抛出的异常。</p><p>下文《Executor框架》将会讲解任务相关的管理。</p><h3 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h3><p>网上众多讲java线程生命周期时想必都会贴出下面这么一张图，然后就人云亦云</p><p><img src="/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8EExecutor/OS%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.svg"></p><p>准确的说，上述这5个状态是从cpu角度看操作系统的线程各个阶段的状态。前文说到Java中的线程是KLT，所以Java线程在cpu角度看也是有这5个状态，但是不代表Java就是如此定义线程状态的！！！</p><p>Java<code>Thread</code>类使用内部枚举<code>State</code>来标识线程的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    </span><br><span class="line">        NEW,</span><br><span class="line"></span><br><span class="line">        RUNNABLE,</span><br><span class="line"></span><br><span class="line">        BLOCKED,</span><br><span class="line"></span><br><span class="line">        WAITING,</span><br><span class="line"></span><br><span class="line">        TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到总共有6个状态，下面一一举例</p><ol><li><p>NEW：新生态，线程对象被创建时处于该状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>();</span><br><span class="line">        System.out.println(t.getState());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>RUNNABLE：运行态，线程正在运行其线程栈内代码（指令）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (System.currentTimeMillis() - start &gt; <span class="number">1000</span> * <span class="number">3</span>) <span class="comment">// 循环3秒以上</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);<span class="comment">// sleep 1秒</span></span><br><span class="line">        System.out.println(t.getState());<span class="comment">// 此时线程t未结束，正在执行其循环代码</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>BLOCKED：阻塞状态，线程想获取不到synchronized同步锁时，进入阻塞状态，如下线程t2获取target对象的锁时，因为线程t1还未释放，所以t2进入阻塞状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (target) &#123;<span class="comment">// 获取target的锁</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (System.currentTimeMillis() - start &gt; <span class="number">1000</span> * <span class="number">3</span>) <span class="comment">// 循环3秒</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">    </span><br><span class="line">    Thread.sleep(<span class="number">100L</span>);<span class="comment">// 等t1线程启动</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (target) &#123;<span class="comment">// 获取target的锁</span></span><br><span class="line">                System.out.println(<span class="string">&quot;--- run ---&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);<span class="comment">// 等两个线程都启动</span></span><br><span class="line">        System.out.println(t2.getState());<span class="comment">// 此时线程t1 t2 都未结束</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>WAITING：等待状态，准确的说是死等，线程调用object.wait()方法，等待其它线程调用object.notify()或object. notifyall()方法，此时该线程进入等待状态。或调用<code>LockSupport.park()</code>方法线程也会进入该状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (target) &#123;<span class="comment">// 获取target的锁</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    target.wait();<span class="comment">// 调用wait()方法</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        System.out.println(t1.getState());<span class="comment">// 由于没有线程调用target.notifyAll()或target.notify()，此时线程t1一直处于等待状态，</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>TIMED_WAITING： 等待未超时，线程调用object.wait(long)方法，等待其它线程调用object.notify()或object. notifyall()方法，不过只会等待指定的时间，未超时之前该线程进入等待未超时状态。或线程进入通过sleep方法进行“睡眠”时，也会进入等待未超时状态。或调用<code>LockSupport.parkNanos(Object, long)</code>方法、<code>LockSupport.parkUntil(Object, long)</code>方法线程也会进入该状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (target) &#123;<span class="comment">// 获取target的锁</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    target.wait(<span class="number">3000L</span>);<span class="comment">// 调用wait()方法，等待其它线程调用target.notifyAll()或target.notify()，不过只等待3秒</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        <span class="comment">// 由于没有线程调用target.notifyAll()或target.notify()，3秒内（此时过去了1秒）线程t1一直处于等待未超时状态</span></span><br><span class="line">        System.out.println(t1.getState());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        <span class="comment">// 线程t1依旧在睡眠，其处于等待未超时状态</span></span><br><span class="line">        System.out.println(t1.getState());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>TERMINATED：终止（死亡）状态，代码执行结束或外部干涉导致线程终止，进入死亡状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">           System.out.println(<span class="string">&quot;--- run ---&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);<span class="comment">//</span></span><br><span class="line">        <span class="comment">// 过了1秒，线程t1已经执行完，其处于死亡状态</span></span><br><span class="line">        System.out.println(t1.getState());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="线程状态的获取"><a href="#线程状态的获取" class="headerlink" title="线程状态的获取"></a>线程状态的获取</h3><p>通过调用<code>Thread#getState</code>方法获取到当前线程的状态。</p><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>java线程优先级范围：1~10，优先级从低到高。</p><p>优先级越高，越容易得到cpu时间片。</p><p>相关方法：</p><ul><li>获取线程的优先级：<code>Thread#getPriority</code></li><li>设置线程优先级：<code>Thread#setPriority</code></li></ul><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><ul><li>java中线程分为<strong>用户线程（User Thread ）</strong>和<strong>守护线程（Daemon Thread ）</strong></li><li>虚拟机必须确保用户线程执行完毕</li><li>虚拟机可以不等待守护线程执行完毕</li><li>通过调用<code>Thread#setDaemon(true)</code>方法将线程设置为守护线程</li></ul><p>守护线程最典型的应用就是 GC (垃圾回收器)。用户线程和守护线程两者几乎没有区别，唯一的不同之处就在于，当用户线程全部执行结束，只剩下守护线程存在了，虚拟机也就退出了， 因为没有了被守护者，守护线程也就没有工作可做了，也就没有继续运行程序的必要了。</p><h3 id="停止线程的方法"><a href="#停止线程的方法" class="headerlink" title="停止线程的方法"></a>停止线程的方法</h3><ul><li><p><code>Thread#stop</code>方法，过时，不建议使用</p></li><li><p><code>Thread#destroy</code>方法，废弃</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置某种标志位，结束线程代码的执行，正常停止线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;运行&quot;</span>);</span><br><span class="line">            <span class="comment">//... do something</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 对外提供停止方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doStop</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">myRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(myRunnable).start();</span><br><span class="line">        Thread.sleep(<span class="number">800</span>);</span><br><span class="line">        myRunnable.doStop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h3><p>调用<code>Thread.sleep</code>方法使当前线程进入阻塞状态，线程结束休眠后进入就绪态；</p><p><strong>线程通过<code>Thread.sleep</code>方法进入休眠时，不会释放对象锁</strong></p><h3 id="线程礼让"><a href="#线程礼让" class="headerlink" title="线程礼让"></a>线程礼让</h3><p>调用<code>Thread.yield()</code>方法使当前线程让出cpu时间片，使线程从运行态重新进入就绪态。值得注意的是：A线程让出cpu时间片，不代表B线程就可以获取到cpu时间片，下一次获取cpu时间片的线程可能还是A。</p><h3 id="线程“插队”"><a href="#线程“插队”" class="headerlink" title="线程“插队”"></a>线程“插队”</h3><p>如在线程A的代码中，调用B线程对象的<code>Thread#join</code>方法，将B线程加入到A线程，A线程需要等待B线程执行完之后才能继续执行自己的代码。好比插队，可传入等待时间表示允许插队的最长时间，超过该时间，B线程还未执行结束，则不再等待。</p><h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><p>下面一一引出Executor框架相关的类或接口</p><h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>前文我们将<code>Runnable</code> 和<code>Callable</code>称之为任务，那么任务有了，就要有对应的任务执行者和管理者，如果不进行管理，直接使用new Thread()的方法创建线程有很多缺点：</p><ul><li>new Thread()耗费性能</li><li>调用new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制创建，之间相互竞争，会导致过多占用系统资源</li><li>不利于扩展，比如如定时执行、定期执行、线程中断等</li></ul><p>所以任务（线程）的管理是必须的。</p><p>对于<code>Runnable</code>，我们不期望有结果（无返回值），只管执行，所以<code>Executor</code>接口出现了。</p><p><img src="/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8EExecutor/Executor%E6%8E%A5%E5%8F%A3.png"></p><p>通过<code>Executor</code>的<code>executor</code>方法来启动任务（子线程），更加便捷，并且可以避免“<strong>this逃逸</strong>”问题</p><h4 id="this逃逸问题"><a href="#this逃逸问题" class="headerlink" title="this逃逸问题"></a>this逃逸问题</h4><p>this逃逸是指在构造函数返回之前其他线程就持有该对象的引用，调用尚未构造完全的对象的方法可能引发奇怪的错误。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="comment">// 在构造方法创建并启动线程</span></span><br><span class="line">        <span class="type">EscapeRunnable</span> <span class="variable">er</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EscapeRunnable</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(er).start();<span class="comment">// 危险，构造可能未完成，但是 er 对象已经能调用正在构造的Woker对象的doWork方法</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//... do something</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">EscapeRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">            Worker.<span class="built_in">this</span>.doWork();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 可修改如下规避this逃逸</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Thread thread;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在构造方法创建创建但未启动线程</span></span><br><span class="line">        thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>.<span class="keyword">new</span> <span class="title class_">EscapeRunnable</span>());</span><br><span class="line">         <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 给外部调用者提供初始化操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//... do something</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">EscapeRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">            Worker.<span class="built_in">this</span>.doWork();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h3><p>对于<code>Callable</code>，也需要有一个执行者和管理者，于是<code>ExecutorService</code>出现了，无论是<code>Callable</code>还是<code>Runnable</code>，这些任务都涉及管理和扩展方面的优化，<code>ExecutorService</code>索性直接扩展<code>Executor</code>增加对<code>Callable</code>支持。</p><p><code>ExecutorService</code>提供了任务生命周期管理等功能 ，实际开发中用的更多的是<code>ExecutorService</code>，它的底层实现就是<strong>线程池</strong>。</p><p><img src="/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8EExecutor/Executor.png"></p><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>任务提交后，我们肯定需要知道任务执行得怎么样了，而<code>ExecutorService</code>使用<code>Future</code>来跟踪任务，通过<code>ExecutorService</code>提交任务后就可以得到<code>Future</code>对象。</p><p><code>Future</code>接口的主要方法如下：</p><ul><li><p><code>boolean cancel(boolean mayInterruptIfRunning);</code></p><p>尝试取消任务，成功则返回true，失败false（任务已经完成、已经被取消或由于其他原因无法取消）</p><p>mayInterruptIfRunning 参数：是否中断任务，true，中断任务且取消任务，false，允许任务继续执行到结束，但是获取结果时会抛异常。</p></li><li><p><code>boolean isCancelled();</code></p><p>任务是否已经取消</p></li><li><p><code>boolean isDone();</code></p><p>任务是否执行结束</p></li><li><p><code>V get() throws InterruptedException, ExecutionException;</code></p><p>获取任务执行结果，获取不到结果之前会一直等待，如果任务已经取消了则抛出异常</p></li><li><p><code>V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;</code></p><p>获取任务执行结果，但只会等待指定的时间，超时则抛出异常。</p><p>timeout 参数：时间数量</p><p>unit 参数：时间单位</p></li></ul><h3 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h3><p><code>Executors</code>类是<code>Executor</code>体系相关的工具类，通过它可以很方便的操作<code>Executor</code>体系相关的接口示例，如创建线程池。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上就是Executor框架的主要知识点，总结一下，Executor框架要由三大部分组成：</p><ol><li>任务(Runnable &#x2F;Callable)</li><li>任务的执行(Executor)</li><li>异步计算的结果(Future)</li></ol><p>Executor 框架的使用</p><p>主线程首先要创建实现<code>Runnable</code>或者<code>Callable</code>接口的任务对象，把任务对象交给<code>ExecutorService</code>执行，得到结果对象<code>Future</code>，最后，主线程可以通过对象<code>Future</code>来获取任务结果或取消任务。</p><hr><p><strong>本文参考B站UP主“狂神说Java”<a target="_blank" rel="noopener" href="https://space.bilibili.com/95256449/%E7%9A%84Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%95%99%E5%AD%A6%E8%A7%86%E9%A2%91%E8%BF%9B%E8%A1%8C%E6%95%B4%E7%90%86%E3%80%82">https://space.bilibili.com/95256449/的Java多线程教学视频进行整理。</a></strong></p><p><strong>感谢成长路上为在下传道受业解惑之人</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Java多线程" scheme="https://blog.windshadow.cn/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>MyBatis源码一 MyBatis执行器与缓存实现</title>
    <link href="https://blog.windshadow.cn/MyBatis%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/"/>
    <id>https://blog.windshadow.cn/MyBatis%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-06-25T12:11:10.029Z</published>
    <updated>2024-08-12T17:18:08.859Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>开门见山，上菜：MyBatis执行器脑图，阅读过程中反复食用即可理解<code>（ ’ - ’ * )</code> </p><p><img src="/MyBatis%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/MyBatis%E6%89%A7%E8%A1%8C%E5%99%A8%E8%84%91%E5%9B%BE.svg" alt="MyBatis执行器脑图"></p><h2 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h2><p><code>SqlSession</code>接口上的注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The primary Java interface for working with MyBatis. Through this interface you can execute</span></span><br><span class="line"><span class="comment"> * commands, get mappers and manage transactions.</span></span><br><span class="line"><span class="comment"> * Author: Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SqlSession</span> <span class="keyword">extends</span> <span class="title class_">Closeable</span> &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>翻译一下：使用MyBatis的主要Java接口。通过这个接口，您可以执行命令、获取映射器和管理事务</p><p><code>SqlSession</code>接口定义了如：<code>&lt;T&gt; T selectOne(String statement);</code>、<code>&lt;E&gt; List&lt;E&gt; selectList(String statement);</code>、<code>&lt;K, V&gt; Map&lt;K, V&gt; selectMap(String statement, String mapKey);</code>、<code>int insert(String statement);</code>、<code>int update(String statement);</code>、<code>int delete(String statement, Object parameter);</code>、<code>void commit();</code>等的一系列增删改查和事务提交&#x2F;回滚接口，方便开发者调用，MyBatis提供的<code>SqlSession</code>接口实现之一是<code>DefaultSqlSession</code>，实际工作干活的就是它。</p><p>根据MyBatis执行器脑图可知其内部又是通过<code>Executor</code>执行器去干活的<img src="/MyBatis%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/sqlsession%E6%89%A7%E8%A1%8C%E5%99%A8.png"></p><p><code>SqlSession</code>的增删改查无论是怎么查，怎么改，怎么删、怎么加，最终都是调用<code>Executor</code>的“<code>update</code>改”和“<code>query</code>查”两个接口（见下文），这就是<code>SqlSession</code>使用的设计模式：<strong>门面模式</strong>，对外提供友好的api方法，内部屏蔽了调用<code>Executor</code>方法的复杂性。</p><h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><p>Executor（<code>org.apache.ibatis.executor.Executor</code>）是一个接口，称之为sql执行器。</p><p>其定义update(增、改、删)、query(查)、commit(提交事务)、rollback(回滚事务)等操作。</p><p>几个重要的方法：</p><ul><li><p>增、改、删</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增、改、删</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException</span><br></pre></td></tr></table></figure><p>参数含义如下</p><ul><li><code>MappedStatement ms</code>：SQL映射语句（Mapper.xml文件每一个方法对应一个MappedStatement对象）</li><li><code>Object parameter</code>：参数，通常是List</li></ul></li><li><p>查询方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询方法</span></span><br><span class="line">&lt; E&gt; List&lt; E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span><br></pre></td></tr></table></figure><p>参数含义（不赘述出现过的参数类型）如下</p><ul><li><code>RowBounds</code>：行边界，主要保存分页参数（limit、offset）</li><li><code>ResultHandler resultHandler</code>：结果处理器，入参时一般为null，实际的结果处理器由<code>Configuration</code>配置对象和<code>MappedStatement</code>对象生成</li></ul></li><li><p>可提供缓存key的查询方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可提供缓存key的查询方法</span></span><br><span class="line">&lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey cacheKey, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException;</span><br></pre></td></tr></table></figure><p>参数含义（不赘述出现过的参数类型）如下：</p><ul><li><code>CacheKey</code>：缓存的key对象</li><li><code>BoundSql boundSql</code>：可以通过该对象获取SQL语句，MyBatis保存sql语句的对象。</li></ul></li><li><p>创建缓存Key（MyBatis一二级缓存的缓存Key）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建缓存Key（MyBatis一二级缓存的缓存Key）</span></span><br><span class="line">CacheKey <span class="title function_">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObj, RowBounds bounds, BoundSql bSql)</span></span><br></pre></td></tr></table></figure><p>可以看出缓存Key由上述参数（SQL映射语句<code>MappedStatement</code>、参数<code>Object</code>、行边界<code>RowBounds</code>、sql语句对象<code>BoundSql</code>）来决定。</p></li></ul><p>下面一一介绍Executor的实现类：<code>BaseExecutor</code>、<code>SimpleExecutor</code>、<code>ReuseExecutor</code>、<code>BatchExecutor</code>、<code>CachingExecutor</code>，其实还有一个<code>ClosedExecutor</code>，代表已经关闭的<code>Executor</code>，是<code>ResultLoaderMap</code>的私有内部类，此处不展开阐述。</p><h3 id="BaseExecutor"><a href="#BaseExecutor" class="headerlink" title="BaseExecutor"></a>BaseExecutor</h3><p><code>Executor</code>的抽象实现，实现执行器的公共操作：<strong>一级缓存、连接获取</strong>等，<strong>查询、更新具体的实现由其子类来实现</strong></p><ul><li>具体的查询操作：<code>doQuery</code>方法</li><li>具体的更新操作：<code>doUpdate</code>方法（包括增删改）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新操作，抽象方法，子类实现</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">doUpdate</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line"><span class="comment">// 查询操作，抽象方法，子类实现</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span></span><br><span class="line">      <span class="keyword">throws</span> SQLException;</span><br></pre></td></tr></table></figure><h3 id="SimpleExecutor"><a href="#SimpleExecutor" class="headerlink" title="SimpleExecutor"></a>SimpleExecutor</h3><p>简单执行器，继承<code>BaseExecutor</code>，无论执行的sql如何，每次都会生成预编译<code>java.sql.PreparedStatement</code>对象。</p><p><img src="/MyBatis%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/simpleExecutor.png"></p><h3 id="ReuseExecutor"><a href="#ReuseExecutor" class="headerlink" title="ReuseExecutor"></a>ReuseExecutor</h3><p>可重用执行器，继承<code>BaseExecutor</code>，相同的sql（肯定是带占位符的）只进行一次预编译（缓存），即预编译对象可重用。</p><p>缓存大致原理：</p><p>内部维护一个map（key: sql, value: Statement对象）作为预编译对象的缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReuseExecutor</span> <span class="keyword">extends</span> <span class="title class_">BaseExecutor</span> &#123;</span><br><span class="line"><span class="comment">// 缓存 Statement 的 map，【key: sql, value: Statement对象】</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Statement&gt; statementMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行<code>doUpdate</code>或<code>doQuery</code>方法时先查缓存，为命中则生成新的预编译对象且加入缓存map中（如图）<img src="/MyBatis%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/reuseExecutor%E7%BC%93%E5%AD%98.png"><img src="/MyBatis%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/reuseExecutor%E7%BC%93%E5%AD%982.png"></p><h3 id="BatchExecutor"><a href="#BatchExecutor" class="headerlink" title="BatchExecutor"></a>BatchExecutor</h3><p>批处理执行器，继承<code>BaseExecutor</code>，该执行器专为批处理场景设计；</p><p><em>（解释一下批处理场景：</em></p><p><em>假设我们需要遍历一个用户对象集合，对每个用户年龄进行加1操作然后更新，假设我们使用<code>ReuseExecutor</code>，那么每个用户的更新操作都会向数据库发送一次sql，而批处理操作便是一次性向数据库发送多条sql。）</em></p><p><code>BatchExecutor</code>属性成员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BatchExecutor</span> <span class="keyword">extends</span> <span class="title class_">BaseExecutor</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BATCH_UPDATE_RETURN_VALUE</span> <span class="operator">=</span> Integer.MIN_VALUE + <span class="number">1002</span>;</span><br><span class="line">  <span class="comment">// Statement集合，批处理的sql对应的Statement都会存在这里</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Statement&gt; statementList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">// 批处理执行的结果集合</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;BatchResult&gt; batchResultList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">// 当前维护的sql（肯定带占位符的）</span></span><br><span class="line">  <span class="keyword">private</span> String currentSql;</span><br><span class="line">  <span class="comment">// 当前维护的MappedStatement</span></span><br><span class="line">  <span class="keyword">private</span> MappedStatement currentStatement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是：</p><ol><li>对查询操作，同简单执行器<code>SimpleExecutor</code>一样，批处理执行器每次都会生成预编译对象</li><li>对于更新操作(增删改)，<code>BatchExecutor</code>对象本身会记录当前的sql和<code>MappedStatement</code>，如果下一次更新操作的sql和<code>MappedStatement</code>与维护的sql和<code>MappedStatement</code>都相同，则直接复用，否则替换掉当前维护的sql和<code>MappedStatement</code></li><li><strong><code>BatchExecutor</code>需要调用<code>flushStatements()</code>方法刷新statement，数据库内的数据修改才会生效。</strong></li><li><strong>执行<code>BatchExecutor</code>的<code>doQuery</code>方法时，会先执行<code>flushStatements()</code>方法，再进行查询操作</strong></li></ol><p>下面贴出<code>BatchExecutor</code>实现<code>doUpdate</code>方法的源码，并加以注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BatchExecutor</span> <span class="keyword">extends</span> <span class="title class_">BaseExecutor</span> &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doUpdate</span><span class="params">(MappedStatement ms, Object parameterObject)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> ms.getConfiguration();</span><br><span class="line">       <span class="keyword">final</span> <span class="type">StatementHandler</span> <span class="variable">handler</span> <span class="operator">=</span> configuration.newStatementHandler(<span class="built_in">this</span>, ms, parameterObject, RowBounds.DEFAULT, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">       <span class="keyword">final</span> <span class="type">BoundSql</span> <span class="variable">boundSql</span> <span class="operator">=</span> handler.getBoundSql();</span><br><span class="line">       <span class="keyword">final</span> <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> boundSql.getSql();</span><br><span class="line">       <span class="keyword">final</span> Statement stmt;</span><br><span class="line">       <span class="keyword">if</span> (sql.equals(currentSql) &amp;&amp; ms.equals(currentStatement)) &#123;<span class="comment">// 当前维护的sql和ms与要执行的sql和ms比较，若都相同</span></span><br><span class="line">         <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> statementList.size() - <span class="number">1</span>;</span><br><span class="line">         stmt = statementList.get(last);<span class="comment">// 取出statement列表最后一个元素作为当前的statement</span></span><br><span class="line">         applyTransactionTimeout(stmt);</span><br><span class="line">         handler.parameterize(stmt);</span><br><span class="line">         <span class="type">BatchResult</span> <span class="variable">batchResult</span> <span class="operator">=</span> batchResultList.get(last); <span class="comment">// 取出最后一个批处理执行结果</span></span><br><span class="line">         batchResult.addParameterObject(parameterObject);     <span class="comment">// 并添加当前的参数对象到该批处理执行结果</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;<span class="comment">// 当前维护的sql和ms与要执行的只要有一个不同</span></span><br><span class="line">         <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> getConnection(ms.getStatementLog());</span><br><span class="line">         stmt = handler.prepare(connection, transaction.getTimeout());<span class="comment">// 获取新的statement</span></span><br><span class="line">         handler.parameterize(stmt);  </span><br><span class="line">         currentSql = sql;<span class="comment">// 顶替掉维护的sql</span></span><br><span class="line">         currentStatement = ms;<span class="comment">// 顶替掉维护的ms</span></span><br><span class="line">         statementList.add(stmt);<span class="comment">// 添加新的statement到statement列表</span></span><br><span class="line">         batchResultList.add(<span class="keyword">new</span> <span class="title class_">BatchResult</span>(ms, sql, parameterObject));<span class="comment">// 添加新的批处理结果到列表</span></span><br><span class="line">       &#125;</span><br><span class="line">       handler.batch(stmt);</span><br><span class="line">       <span class="keyword">return</span> BATCH_UPDATE_RETURN_VALUE;</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通过阅读<code>BatchExecutor</code>的成员变量和<code>doUpdate</code>方法的源码，不难发现，以下几点：</p><ul><li><p>通过statement列表保存要执行的sql操作</p></li><li><p><code>BatchExecutor</code>内部通过维护一个sql和一个<code>MappedStatement</code>来减少statement的生成，连续相同的sql和<code>MappedStatement</code>不会生成新的statement</p></li><li><p>通过批处理结果对象（<code>BatchResult</code>）列表，维护批处理结果，其中批处理结果对象维护了<code>MappedStatement</code>、sql以及不同参数的列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BatchResult</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MappedStatement mappedStatement;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String sql;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; parameterObjects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>statement列表和批处理结果对象（<code>BatchResult</code>）列表，它们下标对应的元素是一一对应有关联的</p></li></ul><h3 id="CachingExecutor"><a href="#CachingExecutor" class="headerlink" title="CachingExecutor"></a>CachingExecutor</h3><p>缓存执行器，实现Executor接口，实现二级缓存，详情见下文。</p><h2 id="一缓存实现原理"><a href="#一缓存实现原理" class="headerlink" title="一缓存实现原理"></a>一缓存实现原理</h2><p><strong>首先要明确一级缓存存在的意义（需求）：同一个事务内，多次相同的查询每次都查询数据库性能是不高的，所以要做缓存</strong></p><p>所以sql执行器<code>Executor</code>接口干净利落的定义了一级缓存（也叫localCache）相关的接口，因为一级缓存是一个逻辑上必然应该存在的功能。</p><p>前文讲到MyBatis的一级缓存是由<code>BaseExecutor</code>实现的，<code>BaseExecutor</code>通过内部的<code>PerpetualCache localCache</code>缓存对象来维护缓存。<img src="/MyBatis%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/baseExecutor%E7%BC%93%E5%AD%98.png"></p><p><strong>PerpetualCache</strong> 内部通过维护一个map实现MyBatis的Cache接口（此处不展开MyBatis的缓存接口的实现体系）。<img src="/MyBatis%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/perpetualCache.png"></p><h3 id="一级缓存源码分析"><a href="#一级缓存源码分析" class="headerlink" title="一级缓存源码分析"></a>一级缓存源码分析</h3><p>我们将<code>BaseExecutor</code>实现<code>Executor</code>接口的两个query方法源码贴出并加以关键注释，即可明白<code>BaseExecutor</code>如何实现MyBatis一缓存的，如下：</p><p><strong>不带缓存key的查询方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="type">BoundSql</span> <span class="variable">boundSql</span> <span class="operator">=</span> ms.getBoundSql(parameter);<span class="comment">// 通过MappedStatement对象获取sql</span></span><br><span class="line">    <span class="type">CacheKey</span> <span class="variable">key</span> <span class="operator">=</span> createCacheKey(ms, parameter, rowBounds, boundSql);<span class="comment">// 创建缓存key</span></span><br><span class="line">    <span class="keyword">return</span> query(ms, parameter, rowBounds, resultHandler, key, boundSql);<span class="comment">// 调用带缓存key的查询方法</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>带缓存key的查询方法（重点）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing a query&quot;</span>).object(ms.getId());</span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">    clearLocalCache();</span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;E&gt; list;<span class="comment">// 定义查询结果引用</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    queryStack++;</span><br><span class="line">     <span class="comment">// 1、满足resultHandler == null则走缓存获取查询结果</span></span><br><span class="line">    list = resultHandler == <span class="literal">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (list != <span class="literal">null</span>) &#123;<span class="comment">// 2、缓存命中了，处理缓存的输出参数，可不必关心此处干了啥</span></span><br><span class="line">      handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 3、缓存未命中，从数据库查询数据</span></span><br><span class="line">      list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    queryStack--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">      deferredLoad.load();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    deferredLoads.clear();</span><br><span class="line">    <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">      </span><br><span class="line">      clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;<span class="comment">// 4、返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询数据库的方法<code>queryFromDatabase</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  List&lt;E&gt; list;<span class="comment">// 1、定义查询结果</span></span><br><span class="line">  localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);<span class="comment">// 2、调用子类的doQuery方法进行查询</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    localCache.removeObject(key);</span><br><span class="line">  &#125;</span><br><span class="line">  localCache.putObject(key, list);<span class="comment">// 3、缓存结果，一级缓存的写入操作！！！</span></span><br><span class="line">  <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">    localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;<span class="comment">// 4、返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一级缓存清除时机</strong></p><p><code>BaseExecutor</code>更新操作（方法）被调用时，清除执行器缓存的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing an update&quot;</span>).object(ms.getId());</span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  clearLocalCache(); <span class="comment">// 1、清除该执行器的一级缓存</span></span><br><span class="line">  <span class="keyword">return</span> doUpdate(ms, parameter);<span class="comment">// 2、调用子类的doUpdate方法执行更新操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据一级缓存的需求，事务提交后，缓存应该就要被清空，这一点在<code>BaseExecutor</code>的 <code>commit</code>方法中体现</p><p><img src="/MyBatis%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/baseExcutor%E6%8F%90%E4%BA%A4.png"></p><h3 id="BaseExecutor实现一级缓存总结"><a href="#BaseExecutor实现一级缓存总结" class="headerlink" title="BaseExecutor实现一级缓存总结"></a><code>BaseExecutor</code>实现一级缓存总结</h3><ul><li>如何维护：通过<code>PerpetualCache localCache</code>成员变量维护一级缓存</li><li>写入时机：实现<code>Executor</code>接口的<code>query</code>方法时，先尝试从缓存中获取查询结果，获取不到则调用子类的<code>doQuery</code>方法从数据库获取查询结果，获取到数据后写入缓存再返回</li><li>清除时机：【1】执行<code>BaseExecutor</code>实现<code>Executor</code>执行器接口的<code>update</code>更新方法时，先清除一级缓存的所有数据，再调用子类的<code>doUpdate</code>方法执行更新操作；【2】<code>BaseExecutor</code>的<code>commit</code>方法被调用时清除一级缓存的所有数据</li></ul><h2 id="二级缓存实现原理"><a href="#二级缓存实现原理" class="headerlink" title="二级缓存实现原理"></a>二级缓存实现原理</h2><p><strong>同样，先明确二级缓存存在的意义（需求）：我们希望数据的缓存结果可以覆盖整个应用，也就是多个事务，一个事务的查询结果被缓存后，另一个事务也能读取到这个缓存结果，以减少对数据库的访问次数，加快数据查询效率。</strong></p><p>MyBatis的二级缓存是通过<code>CachingExecutor</code>实现的，需要注意的是，<code>CachingExecutor</code>在<code>Executor</code>类结构中和<code>BaseExecutor</code>是同级的，内部维护了一个<code>Executor</code>对象，通过构造方法传入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CachingExecutor</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Executor delegate;<span class="comment">// 被装饰的Executor执行器对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">TransactionalCacheManager</span> <span class="variable">tcm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionalCacheManager</span>();<span class="comment">// 事务缓存管理器</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">CachingExecutor</span><span class="params">(Executor delegate)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.delegate = delegate;</span><br><span class="line">    delegate.setExecutorWrapper(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CachingExecutor</code>专门负责二级缓存，而获取连接等执行器的基本操作则交给给内部的<code>Executor</code>对象，此处用到了设计模式中的“<strong>装饰者模式（装饰器模式）</strong>”，在不改变原有功能的基础上，增加新功能，这里的新功能就是二级缓存的功能了。</p><p><em>（有的文章说这是委派模式，<code>CachingExecutor</code>的<code>Executor delegate</code>变量名称确实是委派的意思。不过根据笔者的理解和查询其它高质量的文章之后，比较赞同该设计模式为装饰者模式，因为<code>CachingExecutor</code>确实做到了“在不改变原有功能的基础上，增加新功能”，并且委派模式中，通常“委派者”在委派任务时，通常要根据条件决定把任务交给哪个具体的实现对象，<code>CachingExecutor</code>显然不是这样的情形）</em></p><h3 id="二级缓存源码分析"><a href="#二级缓存源码分析" class="headerlink" title="二级缓存源码分析"></a>二级缓存源码分析</h3><p><code>CachingExecutor</code>实现二级缓存的操作类似于一级缓存，在实现<code>Executor</code>接口的<code>query</code>方法时先查缓存，查不到则调用内部的<code>Executor</code>对象的<code>query</code>方法获取。下面分析<code>CachingExecutor</code>的<code>query</code>方法。</p><p><strong>不带缓存key的查询方法</strong>，最终调用带缓存key的查询方法，与一级缓存相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="type">BoundSql</span> <span class="variable">boundSql</span> <span class="operator">=</span> ms.getBoundSql(parameterObject);</span><br><span class="line">    <span class="type">CacheKey</span> <span class="variable">key</span> <span class="operator">=</span> createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">    <span class="keyword">return</span> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>带缓存key的查询方法（重点）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span><br><span class="line">     <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">   <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> ms.getCache(); <span class="comment">// 1-A、从MappedStatement获取缓存对象</span></span><br><span class="line">   <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;<span class="comment">// 2、如果缓存对象不为空</span></span><br><span class="line">     flushCacheIfRequired(ms);</span><br><span class="line">     <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="literal">null</span>) &#123;<span class="comment">// 3、如果MappedStatement开启了缓存，且resultHandler == null</span></span><br><span class="line">       ensureNoOutParams(ms, boundSql);</span><br><span class="line">       <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">       List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);<span class="comment">// 4、尝试从通过事务缓存管理器对象获取查询结果</span></span><br><span class="line">       <span class="keyword">if</span> (list == <span class="literal">null</span>) &#123;<span class="comment">// 5、从缓存对象获取查询结果为空</span></span><br><span class="line">         <span class="comment">// 6、调用内部的执行器对象进行查询</span></span><br><span class="line">         list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">         tcm.putObject(cache, key, list);<span class="comment">// 7、通过事务缓存管理器对象缓存结果，二级缓存的写入操作！！！</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list;<span class="comment">// 8、返回结果</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">     <span class="comment">// 1-B、MappedStatement获取不到缓存对象则直接调用内部的执行器对象进行查询并返回</span></span><br><span class="line">   <span class="keyword">return</span> delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>二级缓存清除时机</strong></p><p><code>CachingExecutor</code>更新操作（方法）被调用时，清除所有缓存的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(MappedStatement ms, Object parameterObject)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="comment">// 1、刷新（清除）缓存，因为是更新操作，ms.isFlushCacheRequired() == true</span></span><br><span class="line">  flushCacheIfRequired(ms);</span><br><span class="line">  <span class="keyword">return</span> delegate.update(ms, parameterObject);<span class="comment">// 2、再调用装饰的执行器执行更新操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>flushCacheIfRequired</code>刷新（清除）缓存，如果可以需要的话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">flushCacheIfRequired</span><span class="params">(MappedStatement ms)</span> &#123;</span><br><span class="line">    <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> ms.getCache();</span><br><span class="line">    <span class="comment">// 1、缓存对象有效且设置了MappedStatement必须刷新缓存的开关为true，则清除MappedStatement中的缓存</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="literal">null</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">      tcm.clear(cache);<span class="comment">// 2、通过事务缓存管理器对象清空MappedStatement中的缓存</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="二级缓存跨事务使用具体实现与数据一致性原理（重点）"><a href="#二级缓存跨事务使用具体实现与数据一致性原理（重点）" class="headerlink" title="二级缓存跨事务使用具体实现与数据一致性原理（重点）"></a>二级缓存跨事务使用具体实现与数据一致性原理（重点）</h3><p>思考三个点：</p><ol><li><p>由二级缓存的需求可知，二级缓存服务于多个事务的，因为同一个事务内的多次查询已经由一级缓存来保证效率了，所以显然缓存数据的写入应该在事务提交时才会写入。</p><p>而<code>CachingExecutor</code>提交方法<code>commit</code>是直接调用事务缓存管理器对<code>TransactionalCacheManager</code>的提交方法，毫无疑问二级缓存数据的写入操作肯定与该方法有关</p><p><img src="/MyBatis%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/cachingExecutor%E6%8F%90%E4%BA%A4.png"></p></li><li><p>又通过<code>CachingExecutor</code>的<code>query</code>方法源码分析可知，二级缓存的数据的存储实际由<code>MappedStatement</code>对象的自身的cache缓存来做的，而缓存的添加和删除是调用<code>TransactionalCacheManager</code>的方法实现的</p></li><li><p>而二级缓存在得到查询结果后就直接通过事务缓存管理器对象<code>TransactionalCacheManager</code>缓存结果了，但是此时事务并没有提交。</p></li></ol><p>由以上三点可知，<code>CachingExecutor</code>通过<code>MappedStatement</code>的cache缓存和事务缓存管理器<code>TransactionalCacheManager</code>的配合来实现二级缓存</p><p>来看看事务缓存管理器<code>TransactionalCacheManager</code>管理啥了</p><p><img src="/MyBatis%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/tcm.png"></p><p>不难看出<code>TransactionalCacheManager</code>实际管理的是<code>MappedStatement</code>的cache缓存和事务缓存对象<code>TransactionalCache</code>的关系，<code>TransactionalCacheManager</code>的方法最终执行的都是<code>TransactionalCache</code>的方法。</p><p>带着这个问题阅读<code>TransactionalCache</code>的源码（读者自行阅读），理解<code>TransactionalCacheManager</code>、cache缓存、<code>TransactionalCache</code>的关系就全懂了。总结出下图</p><p><img src="/MyBatis%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/MyBatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.svg" alt="MyBatis二级缓存"></p><h4 id="TransactionalCache源码总结"><a href="#TransactionalCache源码总结" class="headerlink" title="TransactionalCache源码总结"></a>TransactionalCache源码总结</h4><ul><li><p>TransactionalCache的四个成员变量含义如上图所示</p></li><li><p>二级缓存数据添加流程：</p><ol><li><code>CachingExecutor</code>的<code>query</code>查询操作通过事务管理器（tcm）添加缓存时，tcm根据该缓存对象获取对应的事务缓存对象<code>TransactionalCache</code>（tc）</li><li>tc将要添加的二级缓存的key-value对先添加到一个由hashmap实现的暂存区</li><li>在执行<code>commit</code>方法（<code>CachingExecutor</code> -&gt; <code>TransactionalCacheManager</code> -&gt; <code>TransactionalCache</code>）时，tc将暂存区的数据添加到缓存cache（<code>MappedStatement</code>的cache）中，同时将记录过未命中缓存的key也加入到缓存cache中，这些key的value为null。</li></ol></li><li><p>二级缓存未命中时，tc记录当前未命中的key到一个由hashset实现的缓冲区中</p></li><li><p>clearOnCommit的作用：</p><ul><li><code>TransactionalCache</code>通过clearOnCommit变量标记，通知事务进行提交时，决定是否先清空二级缓存（<code>MappedStatement</code>的cache），后以当前事务的发生的缓存为最新缓存，刷新到二级缓存中。<img src="/MyBatis%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/tcCommit.png"></li><li>clearOnCommit &#x3D; true时，则认为当前二级缓存中的数据无效，调用<code>TransactionalCache</code>的<code>getObject</code>方法获取缓存中的数据必定是null<img src="/MyBatis%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/tcGet.png"></li><li><code>TransactionalCache</code>每次提交或回滚后，调用内部的<code>reset</code>方法将clearOnCommit变量设置为false（见上图commit方法），以便后续的事务可以读到二级缓存的数据。</li></ul><p>而clearOnCommit &#x3D; true 的情况只有在调用<code>TransactionalCacheManager</code> 的clear方法时（<code>TransactionalCacheManager</code> -&gt; <code>TransactionalCache</code>）才会出现</p><p><img src="/MyBatis%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/commit.jpg"></p><p>而只有在调用<code>CachingExecutor</code>的<code>flushCacheIfRequired</code>方法时可能调用<code>TransactionalCacheManager</code> 的clear方法（见前文源码），追溯到底，若想触发clearOnCommit &#x3D; true，则需要触发<code>MappedStatement#isFlushCacheRequired</code>为true，当执行更新操作时上述情况才会发生。</p></li></ul><p>得出<strong>二级缓存数据一致性原理</strong>：执行器执行更新操作时，<code>MappedStatement#isFlushCacheRequired</code>为true，对应缓存的<code>TransactionalCache</code>的clearOnCommit &#x3D; true，达到在没有事务提交或回滚前，缓存查询不命中的效果，保证数据的一致性。</p><h3 id="二级缓存命中示例"><a href="#二级缓存命中示例" class="headerlink" title="二级缓存命中示例"></a>二级缓存命中示例</h3><p>调用执行器的<code>commit</code>方法进行提交时，二级缓存中才会有数据，后续的查询操作才能命中缓存，示例代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* cachingExecutor的二级缓存</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cachingExecutorTest</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">CachingExecutor</span> <span class="variable">cachingExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CachingExecutor</span>(<span class="keyword">new</span> <span class="title class_">SimpleExecutor</span>(configuration,transaction));</span><br><span class="line">    <span class="type">MappedStatement</span> <span class="variable">ms</span> <span class="operator">=</span> configuration.getMappedStatement(<span class="string">&quot;ws.mybatis.demo.mapper.UserMapper.selectByPrimaryKey&quot;</span>);</span><br><span class="line">    <span class="comment">// 查询id为1的user</span></span><br><span class="line">    List&lt;User&gt; ls1 = cachingExecutor.query(ms, <span class="number">1L</span>,RowBounds.DEFAULT,Executor.NO_RESULT_HANDLER);</span><br><span class="line">    cachingExecutor.commit(<span class="literal">true</span>);<span class="comment">// 提交，重要！！！</span></span><br><span class="line">    <span class="comment">// 命中二级缓存</span></span><br><span class="line">    List&lt;User&gt; ls2 = cachingExecutor.query(ms, <span class="number">1L</span>,RowBounds.DEFAULT,Executor.NO_RESULT_HANDLER);</span><br><span class="line">    List&lt;User&gt; ls3 = cachingExecutor.query(ms, <span class="number">1L</span>,RowBounds.DEFAULT,Executor.NO_RESULT_HANDLER);</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>,ls1.get(<span class="number">0</span>).equals(ls2.get(<span class="number">0</span>)));<span class="comment">// true</span></span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>,ls2.get(<span class="number">0</span>).equals(ls3.get(<span class="number">0</span>)));<span class="comment">// true</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>因为二级缓存是跨线程跨连接调用的，所以需要设计成提交后数据才会写入缓存，而一级缓存是单线程内调用，所以无需提交。</p><h3 id="CachingExecutor实现二级缓存总结"><a href="#CachingExecutor实现二级缓存总结" class="headerlink" title="CachingExecutor实现二级缓存总结"></a><code>CachingExecutor</code>实现二级缓存总结</h3><ul><li><code>CachingExecutor</code>使用“装饰者模式”，装饰一级缓存的<code>Executor</code>执行器对象，增加二级缓存的功能</li><li>查询操作时，查询顺序是：二级缓存 -&gt; 一级缓存 -&gt; 数据库</li><li><code>CachingExecutor</code>本身不维护二级缓存，而是作为<code>MappedStatement</code>的缓存的调用者，所以二级缓存也被称为“Mapper级别的缓存”。事务缓存管理器对象<code>TransactionalCacheManager</code> 、<code>TransactionalCache</code>、<code>MappedStatement</code>三者的搭配实现了二级缓存底层功能。</li><li>执行<code>CachingExecutor</code>实现<code>Executor</code>执行器接口的<code>update</code>更新方法时，会先清除二级缓存的所有数据，再调用被装饰执行器的<code>update</code>方法执行更新操作</li><li>二级缓存需要手动开启，mapper.xml文件中需要指定<code>&lt;cache/&gt;</code>标签以开启二级缓存，这样生成的<code>MappedStatement</code>才会有<code>Cache</code>缓存对象，<code>MappedStatement#getCache()</code>方法返回值不是null（见<code>query</code>方法源码），<code>CachingExecutor</code>才能使用到<code>MappedStatement</code>的缓存。</li></ul><h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><ol><li><p>二级缓存线程安全吗，一级缓存呢？</p><p>二级缓存线程不安全，二级缓存是mapper级别的缓存，是跨线程跨连接的，实际的实现是<code>MappedStatement</code>来实现的，底层存储也是HashMap而不是ConcurrentHashMap，二级缓存也不用也没必要实现线程安全，因为SqlSession本身就是线程不安全的。</p><p>一级缓存肯定是线程安全的，因为一级缓存的读写只可能在一个线程，一个连接里发生。（如果你强行将<code>BaseExeCutor</code>让多个线程调用，那当我没说）</p></li><li><p>二级缓存能保证100%数据一致性吗？</p><p>不能，因为<code>MappedStatement</code>对象是SQL映射语句的封装，那么当这个sql操作过的表，在其他mapper的sql里也操作了，对应<code>MappedStatement</code>的缓存肯定是不感知的，所以二级缓存的数据一致性，需要开发者自己注意，MyBatis的<code>CachingExecutor</code>在代码层面上有效保证了数据一致性，但是实际的sql语句造成的影响需要开发者控制，这也是为什么二级缓存需要手动开启的原因。</p></li><li><p>二级缓存为什么不在<code>BaseExecutor</code>实现？</p><p>二级缓存如果在<code>BaseExecutor</code>实现，那么<code>BaseExecutor</code>必然需要怎么某种开关去控制二级缓存的开启与关闭，这就造成<code>BaseExecutor</code>的职责不单一，面向对象编程应该要让一个类职责明确。</p></li><li><p>二级缓存为什么不像一级缓存一样通过类继承实现？</p><p>如此做会造成<code>Executor</code>类体系结构过于复杂，使用装饰者模式在不改变原有功能的基础上增加二级缓存功能是很好的选择。</p></li><li><p>三级缓存甚至n级缓存如何实现？</p><p>参考二级缓存的实现，继续使用装饰者模式实现三级缓存甚至n级缓存都是ok的。</p></li></ol><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p>MyBatis源码阅读指南【鲁班大叔】：<a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv7933087">https://www.bilibili.com/read/cv7933087</a></p><hr><p><strong>本文参考B站UP主“鲁班大叔”<a target="_blank" rel="noopener" href="https://space.bilibili.com/190795407%E7%9A%84MyBatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%95%99%E5%AD%A6%E8%A7%86%E9%A2%91%E8%BF%9B%E8%A1%8C%E6%95%B4%E7%90%86%EF%BC%9B">https://space.bilibili.com/190795407的MyBatis源码分析教学视频进行整理；</a></strong></p><p><strong>感谢成长路上为在下传道受业解惑之人</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="MyBatis" scheme="https://blog.windshadow.cn/categories/MyBatis/"/>
    
    <category term="MyBatis源码" scheme="https://blog.windshadow.cn/categories/MyBatis/MyBatis%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>Nginx调优</title>
    <link href="https://blog.windshadow.cn/nginx%E8%B0%83%E4%BC%98/"/>
    <id>https://blog.windshadow.cn/nginx%E8%B0%83%E4%BC%98/</id>
    <published>2021-06-23T16:41:11.610Z</published>
    <updated>2021-06-29T15:02:05.616Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Nginx调优"><a href="#Nginx调优" class="headerlink" title="Nginx调优"></a>Nginx调优</h1><h2 id="并发数"><a href="#并发数" class="headerlink" title="并发数"></a>并发数</h2><p>基于nginx的多进程架构，通过合理配置worker_processes、worker_connections、worker_rlimit_nofile参数可调节nginx的最优并发。</p><h3 id="worker-processes"><a href="#worker-processes" class="headerlink" title="worker_processes"></a>worker_processes</h3><p>在nginx配置文件全局块中，通过 worker_processes 参数配置worker 进程数，设置为 auto时，nginx则会自动设置与cpu核心数相同的数量worker 进程。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span> auto;</span><br></pre></td></tr></table></figure><h3 id="worker-connection"><a href="#worker-connection" class="headerlink" title="worker_connection"></a>worker_connection</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个值是表示每个worker进程所能建立连接的最大值，所以，一个nginx能建立的最大连接数，应该是 worker_connections * worker_processes。当然，这里说的是最大连接数，对于HTTP请求本地资源来说，能够支持的最大并发数量是worker_connections * worker_processes，如果是支持http1.1的浏览器每次访问要占两个连接（ 并不是request和response响应占用两个连接 ），所以普通的静态访问最大并发数是：worker_connections * worker_processes &#x2F; 2，而如果是HTTP作为反向代理来说，最大并发数量应该是worker_connections * worker_processes &#x2F; 4，因为作为反向代理服务器,每个并发会建立与客户端的连接和与后端服务的连接，即2*2&#x3D;4。</p><h3 id="worker-rlimit-nofile"><a href="#worker-rlimit-nofile" class="headerlink" title="worker_rlimit_nofile"></a>worker_rlimit_nofile</h3><p>这个参数表示worker进程最多能打开的文件句柄数，基于liunx系统ulimit设置<em>（Linux一切皆文件，所有请求过来最终目的访问文件，查看系统文件句柄数最大值（<strong>用户</strong>可以打开文件的最大数目）：ulimit -n；一般root用户是65535，普通用户是1024）</em></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nginx配置文件全局块</span></span><br><span class="line"><span class="comment"># 配置nginx worker进程最大打开文件数</span></span><br><span class="line"><span class="attribute">worker_rlimit_nofile</span> <span class="number">65535</span>; </span><br></pre></td></tr></table></figure><p>worker_rlimit_nofile 理论值应该是最多打开文件数（ulimit -n）与nginx worker进程进程数相除，但是nginx分配请求并不是那么均匀，所以与ulimit -n的值保持一致为优。</p><p>所以 worker_connections 值不能超过 worker_rlimit_nofile ，否则在高并发下可能会出现“too many open files”的异常。</p><h2 id="nginx长连接"><a href="#nginx长连接" class="headerlink" title="nginx长连接"></a>nginx长连接</h2><h3 id="保持和客户端的长连接"><a href="#保持和客户端的长连接" class="headerlink" title="保持和客户端的长连接"></a>保持和客户端的长连接</h3><p>一般情况下，nginx已经自动开启了对客户端（浏览器）连接的keep alive（http1.1）支持。</p><p>同时可设置以下两个配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">120s</span> <span class="number">120s</span>;</span><br><span class="line">    <span class="attribute">keepalive_requests</span> <span class="number">10000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>keepalive_timeout<br>指令格式：keepalive_timeout timeout [header_timeout];</p><p>timeout ：设置keep-alive客户端连接在服务器端保持开启的超时值（默认75s）；值为0即禁用keep-alive客户端连接；<br>header_timeout：可选，在响应的header域中设置一个值“Keep-Alive: timeout&#x3D;time”；通常可不设置；<br>timeout默认75s，一般情况下也够用，对于一些请求比较大的内部服务器通讯的场景，适当加大。</p></li><li><p>keepalive_requests<br>keepalive_requests指令用于设置一个keep-alive连接上可以服务的请求的最大数量，当最大请求数量达到时，连接被关闭，默认为100。</p><p>该参数的工作机制：一个keep alive建立之后，nginx就会为这个连接设置一个计数器，记录这个keep alive的长连接上已经接收并处理的客户端请求的数量。如果达到这个参数设置的最大值时，则nginx会强行关闭这个长连接，逼迫客户端不得不重新建立新的长连接。</p></li></ul><h3 id="保持和server的长连接"><a href="#保持和server的长连接" class="headerlink" title="保持和server的长连接"></a>保持和server的长连接</h3><p>nginx访问后端server（nginx称为upstream，上游服务器）默认用的是短连接的HTTP1.0协议，客户端请求到达时，nginx与后端建立连接，后端响应完毕后主动关闭该连接。</p><p>为了让nginx和后端server之间保持长连接，一般指明nginx请求后端服务的协议为http1.1</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">upstream</span>  BACK_SERVER &#123;</span><br><span class="line">        <span class="attribute">server</span>   <span class="number">10.0.0.1:8080</span>  weight=<span class="number">1</span> max_fails=<span class="number">2</span> fail_timeout=<span class="number">30s</span>;</span><br><span class="line">        <span class="attribute">server</span>   <span class="number">10.0.0.2:8080</span>  weight=<span class="number">1</span> max_fails=<span class="number">2</span> fail_timeout=<span class="number">30s</span>;</span><br><span class="line">        <span class="attribute">keepalive</span> <span class="number">300</span>;        // 设置空闲连接的最大数量</span><br><span class="line">    &#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line">        <span class="attribute">server_name</span> www.myapp.com;</span><br><span class="line">        <span class="section">location</span> /  &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://BACK_SERVER ;</span><br><span class="line">          <span class="comment"># 其它配置...</span></span><br><span class="line">            <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;// 指明请求后端的协议</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;&quot;</span>; // 清理来自客户端的Connection请求头</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>proxy_set_header Connection &quot;&quot;;</code>指令作用时清理来自客户端的Connection请求头，因为http1.1保持开启的长连接的关键是Connection请求头， 因为如果客户端和nginx之间是短连接（http1.0），我们把Connection请求头也带到后端，那么nginx与后端就不会开启长连接了，所以此处需要清除。</p><h3 id="upstream块的keepalive"><a href="#upstream块的keepalive" class="headerlink" title="upstream块的keepalive"></a>upstream块的keepalive</h3><p>官方解释：设置到upstream服务器的空闲keepalive连接的最大数量， 当这个数量被突破时，最近使用最少的连接将被关闭，keepalive指令不会限制一个nginx worker进程到upstream服务器连接的总数量。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span>  BACK_SERVER &#123;</span><br><span class="line">        <span class="attribute">server</span>   <span class="number">10.0.0.1:8080</span>  weight=<span class="number">1</span> max_fails=<span class="number">2</span> fail_timeout=<span class="number">30s</span>;</span><br><span class="line">        <span class="attribute">server</span>   <span class="number">10.0.0.2:8080</span>  weight=<span class="number">1</span> max_fails=<span class="number">2</span> fail_timeout=<span class="number">30s</span>;</span><br><span class="line">        <span class="attribute">keepalive</span> <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说白了就是nginx往后端服务器发的请求的空闲连接的最大数量，假设keepalive设置为30，此时来了100个请求，nginx新建了100个线程去请求后端，那么请求结束后，nginx会关闭100-30&#x3D;70个线程，此时又再来了100个请求，nginx必须再新建70个线程去请求后端，之前30个线程被复用。所以合理配置keepalive是很有必要的。</p><p><strong>一般把upstream块的keepalive配置和保持和server长连接的配置结合使用。</strong></p><h2 id="持续更新……"><a href="#持续更新……" class="headerlink" title="持续更新……"></a>持续更新……</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Nginx" scheme="https://blog.windshadow.cn/categories/Nginx/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker容器数据卷</title>
    <link href="https://blog.windshadow.cn/docker%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7/"/>
    <id>https://blog.windshadow.cn/docker%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7/</id>
    <published>2021-05-26T12:01:46.804Z</published>
    <updated>2024-08-12T17:13:15.482Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我们知道docker容器相当于一个小型linux系统，docker容器被删除后，这个系统也就消失了，如果数据都在容器中，那么删除容器后数据就会丢失，如mysql容器中数据库表数据，docker提供了数据卷来对容器内的数据进行持久化。</p><h2 id="数据卷挂载"><a href="#数据卷挂载" class="headerlink" title="数据卷挂载"></a>数据卷挂载</h2><p><img src="/docker%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7/docker-volume.webp"></p><p>作用：将容器内的文件映射（挂载）到宿主机，类似硬链接。</p><p>数据卷是一个可供容器使用的特殊目录，它绕过文件系统，可以提供很多有用的特性：</p><ol><li>数据卷可以在容器之间共享和重用。</li><li>对数据卷的更改会立即生效。</li><li>对数据卷的更新不会影响镜像。</li><li>和容器的生命周期是分离的，数据卷会一直存在，除非被清理。</li><li>数据卷的变化不会影响镜像的更新。数据卷是独立于联合文件系统，镜像是基于联合文件系统。镜像与数据卷之间不会相互影响。</li></ol><p>上图表示了docker挂载卷的3种方式：volume、bind mount、tmpfs mounts；</p><h3 id="volume挂载方式"><a href="#volume挂载方式" class="headerlink" title="volume挂载方式"></a>volume挂载方式</h3><p>volume意思为“卷”，可在执行<code>docker run</code>命令时使用<code>-v</code>选项挂载卷，docker管理数据卷的目录一般为<code>/var/lib/docker/volumes/</code></p><p><img src="/docker%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7/docker-volumes.png"></p><h5 id="匿名挂载"><a href="#匿名挂载" class="headerlink" title="匿名挂载"></a>匿名挂载</h5><p>命令示例：<code>docker run -v &lt;容器内路径&gt; centos</code>；此方式为<strong>匿名挂载</strong>，docker将分配一个匿名的数据卷（如上图16进制字符构成的文件夹），将容器内的路径硬链接到该卷下的_data目录。</p><h5 id="具名挂载"><a href="#具名挂载" class="headerlink" title="具名挂载"></a>具名挂载</h5><p>命令示例：<code>docker run -v &lt;卷名称&gt;:&lt;容器内路径&gt; centos</code>；此方式为<strong>具名挂载</strong>，docker将分配一个有具体名称的数据卷（如上图mycentos-v文件夹），如果该名称卷已经存在则直接使用而不再创建，将容器内的路径硬链接到该卷下的_data目录。</p><p>数据卷挂载文件覆盖问题：</p><ul><li>如果容器内路径不存在则被创建</li><li>如果挂载一个空的数据卷到容器中的一个非空目录中，那么这个目录下的文件会被复制到数据卷中。</li><li>如果挂载一个非空的数据卷到容器中的一个目录中，那么容器中的目录中会显示数据卷中的数据。如果原来容器中的目录中有数据，那么这些原始数据会被隐藏掉。</li></ul><p>这两个规则都非常重要，灵活利用第一个规则可以帮助我们初始化数据卷中的内容。掌握第二个规则可以保证挂载数据卷后的数据总是你期望的结果。</p><p>除此之外，也可以在通过Dockerfile构建镜像时指定挂载出匿名数据卷。</p><h3 id="bind-mounts绑定挂载"><a href="#bind-mounts绑定挂载" class="headerlink" title="bind mounts绑定挂载"></a>bind mounts绑定挂载</h3><p>绑定文件系统的文件。</p><p>命令示例：<code>docker run -v &lt;宿主机路径&gt;:&lt;容器内路径&gt; centos</code> ；此方式为指定路径挂载，此挂载方式，docker直接将容器内的路径硬链接到指定的宿主机目录，有以下几点值得注意：</p><ul><li>且宿主机路径必须是绝对路径</li><li>无论宿主机路径还是容器内路径，路径不存在则被创建</li><li>文件覆盖规则：【宿主机 -&gt; 容器内】</li><li>此种挂载方式无法通过<code>docker volume</code>管理卷。</li></ul><h3 id="只读挂载"><a href="#只读挂载" class="headerlink" title="只读挂载"></a>只读挂载</h3><p>过ro选项指定挂载的数据卷是只读的，意味着容器无法对挂载的文件进行修改，只能读，即挂载的文件只允许宿主机单向修改。rw便是可读可写，默认卷读写性质为rw。</p><ul><li><p>匿名挂载的只读：匿名挂载不支持只读，即使使用<code>--read-only</code>选项进行只读限定，也不会生效，卷读写性质依旧为rw</p></li><li><p>具名挂载的只读：命令示例：<code>docker run -v &lt;卷名称&gt;:&lt;容器内路径&gt;:ro centos</code></p></li><li><p>bind mounts挂载的只读：命令示例：<code>docker run -v &lt;宿主机路径&gt;:&lt;容器内路径&gt;:ro centos</code>；文件覆盖情况【宿主机 -&gt; 容器内】且是强制覆盖，且容器无法对该目录的文件进行修改</p></li></ul><h3 id="tmpfs临时文件系统"><a href="#tmpfs临时文件系统" class="headerlink" title="tmpfs临时文件系统"></a>tmpfs临时文件系统</h3><p>volume挂载方式（卷挂载）和bind mounts挂载方式（绑定挂载）允许在主机和容器之间共享文件，以便即使在容器停止后也可以保留数据。Linux上运行的Docker，有第三个挂载方式选择：tmpfs，即临时的文件系统。</p><p>以tmpfs挂载方式创建容器时，容器可以在容器的可写层外创建文件。与卷和绑定挂载相反，tmpfs挂载是临时的，并且仅保留在主机内存中。当容器停止时，将tmpfs删除。这对于临时存储不希望在主机或容器可写层中保留的敏感文件很有用。</p><p>tmpfs挂载的限制：</p><ul><li>与卷和绑定挂载不同，tmpfs无法在容器之间共享</li><li>只有在Linux上运行的Docker才能使用此功能</li></ul><p>命令实例：<code>docker run --rm -it --tmpfs /root  centos</code>；</p><p>tmpfs挂载允许两个配置选项，都不是必需的。如果需要指定这些选项，则必须使用该<code>--mount</code>选项，因为该–tmpfs选项不支持它们：</p><ul><li>tmpfs-size：tmpfs挂载的大小（单位：字节），默认无限</li><li>tmpfs-mode：tmpfs的文件模式，为八进制，即linux系统下的文件读写权限的数字标识，例如700或0770，默认值为1777（全局可写）</li></ul><p>命令实例：<code>docker run --rm -it --mount type=tmpfs,destination=/root,tmpfs-mode=1770  centos</code></p><p>关于<code>--mount</code>与<code>--tmpfs</code>的区别：<a target="_blank" rel="noopener" href="https://docs.docker.com/storage/tmpfs/#use-a-tmpfs-mount-in-a-container">https://docs.docker.com/storage/tmpfs/#use-a-tmpfs-mount-in-a-container</a></p><h2 id="数据卷管理"><a href="#数据卷管理" class="headerlink" title="数据卷管理"></a>数据卷管理</h2><h3 id="docker-volume"><a href="#docker-volume" class="headerlink" title="docker volume"></a>docker volume</h3><p>作用：可以通过<code>docker volume</code>命令管理数据卷</p><p>常见命令格式：<code>docker volume &lt;option&gt;</code></p><ul><li><code>docker volume ls</code>：查看所有数据卷</li><li><code>docker volume rm &lt;卷名称&gt;</code>：删除数据卷，还有容器使用的数据卷不可被删除</li><li><code>docker volume inspect &lt;卷名称&gt;</code>：查看数据卷详情</li><li><code>docker volume create &lt;卷名称&gt;</code>：创建一个数据卷</li></ul><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>容器挂载数据卷，其它容器通过挂载这个（父容器）实现数据共享，这个挂载数据卷的“父”容器称之为数据卷容器；</p><p>因为数据卷会存在直到没有容器使用为止（除非手动强制删除），像多个数据库容器场景下，容器之间需要传递共享数据卷，使用容器维护数据卷，这就是数据卷容器。</p><p><img src="/docker%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7/volumes-from.jpg"></p><h3 id="–volumes-from"><a href="#–volumes-from" class="headerlink" title="–volumes-from"></a>–volumes-from</h3><p>可在执行<code>docker run</code>命令时使用<code>--volumes-from</code>选项从其它容器挂载卷。</p><p>命令示例：<code>docker run -it --volumes-from=&lt;容器id或容器名&gt; centos</code>，数据覆盖情况：【卷 -&gt; 容器内】；</p><p>我们可以把<code>--volumes-from</code>选项比作继承，上图中，容器X挂载出volume1、volume2，数据卷容器A和容器B继承自容器X，容器C继承容器A，容器D继承容器B，最终ABCD容器都挂载了volume1、volume2，无论哪个容器对数据卷内的文件进行修改，其它容器都能同步更新到，容器X便是数据卷容器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Docker" scheme="https://blog.windshadow.cn/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker网络</title>
    <link href="https://blog.windshadow.cn/docker%E7%BD%91%E7%BB%9C/"/>
    <id>https://blog.windshadow.cn/docker%E7%BD%91%E7%BB%9C/</id>
    <published>2021-05-26T12:01:46.401Z</published>
    <updated>2024-08-12T17:12:55.830Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="docker0网卡"><a href="#docker0网卡" class="headerlink" title="docker0网卡"></a>docker0网卡</h2><p>服务器安装了docker，就会有一个网卡docker0，docker0网卡使用nat直连到服务器的物理网卡。</p><p><img src="/docker%E7%BD%91%E7%BB%9C/docker-veth-pair.jpg"></p><h3 id="evth-pair"><a href="#evth-pair" class="headerlink" title="evth-pair"></a>evth-pair</h3><p>evth-pari 是一种虚拟网络设备，是一对的虚拟设备接口，它们都是成对出现的，一端连着内核协议栈 ，一端彼此相连着，一个设备收到协议栈的数据发送请求后，会将数据发送到另一个设备上去，正因为这个特性，evth-pair 充当一个桥梁，连接各种虚拟网络设备；OpenStack，Docker容器之间的连接, OVS的连接，都是使用 evth-pair 技术。</p><p>上图中，docker0扮演的角色可以比作容器依赖的路由器，容器不指定网络的情况下，都是通过docker0路由的，docker会给容器分配一个默认的可用ip，只要容器被删除，对应的evth-pari接口就没了 。docker中通过evth-pair连接到docker0的网络连接模式称之为<strong>桥接</strong>模式，该模式下的任意容器之间是可以相互ping通的。</p><p>桥接到docker0网卡的方式缺点也很明显，无法预知容器IP，且在容器重启后IP可能会发生变化，导致容器内的应用之间存在依赖时，不方便配置，如数据库IP等。</p><h3 id="docker0-IP分配方式"><a href="#docker0-IP分配方式" class="headerlink" title="docker0 IP分配方式"></a>docker0 IP分配方式</h3><p>需要注意的是，docker0分配IP的方式是按顺序分配，如已经分配了容器A（172.17.0.1）、容器B（172.17.0.2），下一个容器C的IP为172.17.0.3，如果此时容器B停止或被删除，再新建容器D时，其IP为172.17.0.2。</p><h2 id="link方式连接"><a href="#link方式连接" class="headerlink" title="link方式连接"></a>link方式连接</h2><p>容器桥接到docker0的网络连接方式显然不能满足部署需求，如果能使用容器名进行网络连接，就不必担心容器重启后IP改变的问题了，docker提供了link方式的网络连接；</p><p>在<code>docker run</code>启动容器时使用<code>--link</code>选项连接到其它容器：命令示例：<code>docker run -it --link &lt;容器id或容器名&gt;:[alias] centos</code>；</p><ul><li><code>docker run -it --name=mycentos --link mysql-dev centos</code>：启动一个名为mycentos的容器，且连接到名为mysql-dev的容器，此时在mycentos容器内可以使用<code>ping mysql-dev</code>的方式ping通名为mysql-dev的容器</li><li><code>docker run -it --name=mycentos --link mysql-dev:db centos</code>：alias是容器在link模式下的别名，同上，在mycentos容器内还可以使用<code>ping db</code>的方式ping通名为mysql-dev的容器</li></ul><h3 id="link方式连接原理"><a href="#link方式连接原理" class="headerlink" title="link方式连接原理"></a>link方式连接原理</h3><p>在源容器的hosts文件写入目标容器名、目标容器link下的别名、目标容器id，均指向目标容器的IP，当目标容器的IP发生变化时，hosts文件的配置也跟着发生变化，这是通过docker容器的环境变量完成的。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>显然的，源容器通过link方式连接到目标容器时，可以通过容器名访问目标容器，反过来则不行，因为是通过写hosts的形式去实现的。</li><li>当目标容器被删除时，源容器的hosts配置还存在，此时新的容器“占据”旧目标容器IP时（依据docker0的 IP分配方式），源容器的hosts配置并不会发生改变，故而连接到新的容器。</li></ul><p>官方已经已经不推荐使用link方式去设计容器的网络了。</p><h2 id="自定义网络（核心）"><a href="#自定义网络（核心）" class="headerlink" title="自定义网络（核心）"></a>自定义网络（核心）</h2><p>既然docker通过容器模拟了一个小型的linux操作系统，自然也少不了计算机网络。docker提供<code>docker network</code>命令来管理网络，使用docker创建网络的主要参数有：网络名称，网络模式，子网，网关。</p><h3 id="docker的网络模式"><a href="#docker的网络模式" class="headerlink" title="docker的网络模式"></a>docker的网络模式</h3><ul><li><p>bridge</p><p>桥接模式，docker默认的网络模式，该模式下容器桥接到docker0网卡</p></li><li><p>none</p><p>不配置网络</p></li><li><p>host</p><p>和宿主机共享网络，即使用宿主机的IP端口</p></li><li><p>container</p><p>容器网络连通（用得少，局限大）</p></li></ul><h3 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h3><h4 id="docker-network-create"><a href="#docker-network-create" class="headerlink" title="docker network create"></a>docker network create</h4><p>作用：创建网络；</p><p>命令格式：<code>docker network create [options] &lt;网络名&gt;</code>；</p><p>常见命令格式：<code>docker network create --driver &lt;网络模式&gt; --subnet &lt;子网&gt; --gateway &lt;网关地址&gt; &lt;网络名称&gt; </code>；</p><p>常用option选项：</p><ul><li><code>--driver</code>：指定网络模式，不指定默认为桥接模式(driver)，一般使用桥接模式较多</li><li><code>--subnet</code>：指定子网，写法为网段 + 掩码，如10.0.0.0&#x2F;16</li><li><code>--gateway</code>：指定网关地址</li><li><code>--ip-range</code>：指定ip网络内可动态分配的IP范围，写法为网段 + 掩码，如10.0.0.0&#x2F;16</li></ul><p>示例：<code>docker network create --driver bridge --subnet 10.0.0.0/16 --gateway 10.0.0.254 mynet</code>，该命令创建了一个网络，名称为”mynet”，网络模式为桥接模式（bridge ），子网为10.0.0.0&#x2F;16，网关为10.0.0.254，此时宿主机网络情况如下</p><p><img src="/docker%E7%BD%91%E7%BB%9C/mynet.svg"></p><h4 id="docker-network-ls"><a href="#docker-network-ls" class="headerlink" title="docker network ls"></a>docker network ls</h4><p>查看当前所有网络；常见命令格式：<code>docker network ls [option]</code>；</p><p>示例：<code>docker network ls -f &#39;driver=bridge&#39;</code>：查看所有网络中网络模式为桥接的网络。</p><h4 id="docker-network-inspect"><a href="#docker-network-inspect" class="headerlink" title="docker network inspect"></a>docker network inspect</h4><p>查看网络详情；常见命令格式：<code>docker network inspect &lt;网络id或网络名称&gt;</code>；</p><p>该命令可查看网络创建时的基本信息和使用该网络的容器信息等。</p><h4 id="docker-network-rm"><a href="#docker-network-rm" class="headerlink" title="docker network rm"></a>docker network rm</h4><p>删除网络；常见命令格式：<code>docker network rm &lt;网络id或网络名称&gt;</code>；</p><h3 id="容器连接或断开网络"><a href="#容器连接或断开网络" class="headerlink" title="容器连接或断开网络"></a>容器连接或断开网络</h3><p>可以使用<code>docker run</code>新建容器时可使用<code>--network</code>或<code>--net</code>将容器连接到指定的网络：<code>docker run -it --net &lt;网络id或网络名&gt; centos</code>，另一种便是使用<code>docker network connect</code>命令。</p><h3 id="docker-network-connect"><a href="#docker-network-connect" class="headerlink" title="docker network connect"></a>docker network connect</h3><p>作用：将容器连接到网络；</p><p>常见的命令格式：<code>docker network connect &lt;网络id或网络名称&gt; [options] &lt;容器名&gt;</code>；</p><p>option选项：</p><ul><li><code>--alias</code> ：指定该容器在该网络中的别名</li><li><code>--ip</code>：指定IP地址（常用）</li><li><code>--ip6</code>：指定IPv6地址</li><li><code>--link</code>：链接到另一个容器</li><li><code>--link-local-ip</code>：添加容器的链接本地地址</li></ul><p><code>docker network connect</code>的选项几乎全都可在<code>docker run</code>时使用。</p><h3 id="docker-network-disconnect"><a href="#docker-network-disconnect" class="headerlink" title="docker network disconnect"></a>docker network disconnect</h3><p>作用：将容器与网络断开；</p><p>常见的命令格式：<code>docker network disconnect [option] &lt;网络id或网络名称&gt; &lt;容器名&gt;</code>；</p><p>断开条件：容器必须正在运行才能将其与网络断开连接；</p><p>option选项：</p><ul><li><code>-f</code>：强制断开容器与网络的连接</li></ul><p>容器连接到网络之后，容器内都有一个默认的DNS服务器配置，这样任意容器之间均可通过容器名互相访问，而不需要像link方式般由hsots文件维护容器名与IP的关系。</p><h3 id="停止、暂停或重启容器对网络的影响"><a href="#停止、暂停或重启容器对网络的影响" class="headerlink" title="停止、暂停或重启容器对网络的影响"></a><strong>停止、暂停或重启容器对网络的影响</strong></h3><p>暂停、重新启动和停止连接到网络的容器，容器在运行时会连接到其配置的网络：</p><ul><li>若未容器指定IP（动态IP），容器启动时自动获取网络内可分配的IP</li><li>若未容器指定了IP（静态IP），容器启动时应用容器的 IP 地址，如果 IP 地址不再可用，则容器无法启动。</li></ul><p>保证 IP 地址可用的一种方法：</p><p>使用<code>--ip-range</code>指定一个网络自动分配的IP的范围，使用<code>--ip</code>给容器指定该范围之外的IP地址（静态IP），可确保在此容器不在网络上时不会将 IP 地址提供给另一个容器。</p><p>如：<code>docker network create --driver bridge --subnet 10.0.0.0/24 --ip-range 10.0.0.0/25 --gateway 10.0.0.254 mynet</code>，创建一个网络名叫”mynet”，子网为10.0.0.0&#x2F;24，可动态分配的地址范围为10.0.0.0&#x2F;25，网关为10.0.0.254，新建容器A、容器B、容器C且都加入mynet网络，容器C使用<code>--ip</code>指定IP地址。</p><p><img src="/docker%E7%BD%91%E7%BB%9C/docker%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C.svg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Docker" scheme="https://blog.windshadow.cn/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker基础</title>
    <link href="https://blog.windshadow.cn/docker%E5%9F%BA%E7%A1%80/"/>
    <id>https://blog.windshadow.cn/docker%E5%9F%BA%E7%A1%80/</id>
    <published>2021-05-21T12:31:15.199Z</published>
    <updated>2024-08-14T15:01:24.584Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Docker基础知识"><a href="#Docker基础知识" class="headerlink" title="Docker基础知识"></a>Docker基础知识</h2><h3 id="Docker的基本组成"><a href="#Docker的基本组成" class="headerlink" title="Docker的基本组成"></a>Docker的基本组成</h3><p><img src="/docker%E5%9F%BA%E7%A1%80/docker.png"></p><ul><li><p>镜像（image)：</p><p>docker镜像就好比是一个模板，可以通过这个模板来创建容器对外提供服务，如通过tomcat镜像创建一个tomcat容器，容器内的tomcat运行我们的war包对外提供服务，而一个镜像可以创建多个容器，我们不需要像传统部署一样每次都手动部署war，修改端口配置等。</p></li><li><p>容器(container)：</p><p>Docker利用容器技术，独立运行一个或者一组应用，容器通过镜像来创建。对容器的基本操作有启动，停止，删除等，可以把这个容器理解为就是一个简易的Linux系统。</p></li><li><p>仓库(repository)：</p><p>仓库就是存放镜像的地方，仓库分为公有仓库和私有仓库，类似GitHub，DockerHub便是镜像仓库。</p></li></ul><h3 id="Docker如何工作"><a href="#Docker如何工作" class="headerlink" title="Docker如何工作"></a>Docker如何工作</h3><p>Docker是一个Client-Server结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端访问！Docker-Server接收到Docker-Client的指令并执行。</p><p><img src="/docker%E5%9F%BA%E7%A1%80/docker-cs.png"></p><h3 id="为什么Docker比VM快"><a href="#为什么Docker比VM快" class="headerlink" title="为什么Docker比VM快"></a>为什么Docker比VM快</h3><ol><li><p>docker有着比虚拟机更少的抽象层。由于docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。</p><p><img src="/docker%E5%9F%BA%E7%A1%80/docker-vs-vm.png"></p></li><li><p>docker利用的是宿主机的内核,而不需要Guest OS。</p></li></ol><p>当docker新建一个容器时，docker不需要和虚拟机一样重新加载一个操作系统内核，避免了引导、加载操作系统内核返个比较费时费资源的过程。VM新建一个虚拟机时，虚拟机软件需要加载GuestOS，而docker由于直接利用宿主机的操作系统,则省略了这个复杂的过程</p><ul><li>Hypervisor：虚拟机监视器（virtual machine monitor，缩写为 VMM），是用来建立与执行虚拟机器的软件、固件或硬件。</li><li>GuestOS： VM（虚拟机）里的的系统（OS）</li><li>HostOS：物理机里的系统（OS）</li></ul><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><p>Docker的安装要求Linux在内核3.0以上</p><p>官方安装文档：<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/">https://docs.docker.com/engine/install/ </a></p><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示docker版本</span></span><br><span class="line">docker version</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看镜像容器数量等信息</span></span><br><span class="line">dcoker info </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">帮助命令，查看某个命令如何使用</span></span><br><span class="line">docker &lt;命令&gt; --help</span><br></pre></td></tr></table></figure><p>docker全部命令官方文档：<a target="_blank" rel="noopener" href="https://docs.docker.com/reference/">https://docs.docker.com/reference/</a></p><h2 id="操作镜像"><a href="#操作镜像" class="headerlink" title="操作镜像"></a>操作镜像</h2><h3 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h3><p>作用：查看镜像</p><ul><li><p><code>docker images</code>查看当前系统的镜像（默认隐藏中间的镜像）</p></li><li><p><code>docker images -a</code>查看全部镜像，包括中间层的镜像</p></li><li><p><code>docker images -q</code>查看镜像，仅显示镜像id</p></li><li><p><code>docker images -f &lt;key=valu&gt;</code>查看镜像，根据条件过滤</p><p>key的范围：</p><ul><li>dangling：显示标记为<code>&lt;none&gt;</code>的镜像，取值范围：true | false，如：<code>docker images -f dangling=true</code></li><li>label：根据标签进行过滤，其中lable的值，是docker在编译的时候配置的或者在Dockerfile中配置的</li><li>before：根据某个镜像的构建时间进行过滤，before的value表示某个镜像构建时间之前的镜像列表，如：<code>docker images -f before=mysql</code></li><li>since：跟before正好相反，表示的是在某个镜像构建之后构建的镜像</li><li>reference：添加正则进行匹配，如：<code>docker images -f reference=&quot;*:latest&quot;</code>（查询版本为最新版本的镜像）</li></ul></li></ul><h3 id="docker-search"><a href="#docker-search" class="headerlink" title="docker search"></a>docker search</h3><p>作用：搜索远程仓库的镜像</p><p>如：<code>docker search mysql -f STARS=3000</code>（查询远程仓库镜像,查询mysql的镜像，且stars数量大于等于3000）</p><h3 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h3><p>作用：从远程仓库拉取镜像</p><p>格式<code>docker pull &lt;镜像名[:版本]&gt;</code>，等价于<code>docker image pull &lt;镜像名[:版本]&gt;</code>，如<code>docker pull mysql</code>（拉取mysql镜像，默认拉取最新版，latest），<code>docker pull mysql:5.7</code>（拉取mysql5.7镜像）</p><h3 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a>docker rmi</h3><p>作用：删除镜像</p><p>格式：<code>docker rmi &lt;镜像名或镜像ID&gt;</code> ，等价于<code>docker image rm &lt;镜像名或镜像ID&gt;</code> 。镜像删除时，docker默认不允许删除正在运行的容器所引用的镜像，除非指定-f选项。</p><ul><li><code>docker rmi mysql</code>（删除mysql的镜像）</li><li>删除时可通过<code>镜像名:tag</code>指定版本（标签）。如：<code>docker rmi mysql:5.7</code>这实际上只会删除mysql镜像为5.7的标签，除非该镜像仅有此标签，那么镜像就真的被删除</li><li><code>docker rmi -f mysql</code>：强制删除镜像</li><li><code>docker rmi -f $(docker images -aq)</code> （强制删除全部镜像，先查出id后删除）</li><li><code>docker images -q|xargs docker rmi</code>：使用管道符传参进行删除</li><li><code>docker rmi -no-prune</code>：不移除该镜像的过程镜像，默认移除</li><li>同一镜像有多个tag情况下，执行 <code>docker rmi &lt;镜像ID&gt;</code> 指令无法删除</li></ul><h2 id="操作容器"><a href="#操作容器" class="headerlink" title="操作容器"></a>操作容器</h2><p>扫盲：容器通过镜像创建而来，镜像与容器为1对多的关系。</p><h3 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h3><p>作用：新建并运行容器</p><p><code>docker run</code>等价于<code>docker container run</code></p><p>常见命令格式：<code>docker run [option1][option2] &lt;镜像id或名称&gt;</code>，如：<code>docker run --name=mysql-test mysql:5.7</code>（使用mysql5.7镜像新建并运行一个容器，容器名为“mysql-test”）。</p><p>docker run 命令支持的option非常多，介绍部分option：</p><ul><li>–name：指定容器名称</li><li>-i：以交互模式运行容器，通常与 -t 同时使用</li><li>-t：为容器重新分配一个伪终端，通常与 -i 使用</li><li>-d：以后台模式运行容器，并返回容器id，即启动守护式容器</li><li>-v：挂载卷（此处不展开讲，见下文）</li><li>-P：随机映射宿主机一个端口到容器内的一个端口</li><li>-p：指定端口映射，模式如下：<ul><li><code>ip:&lt;宿主机端口&gt;:&lt;容器端口&gt;</code>：宿主机IP+端口映射到容器内端口（如多网卡时）</li><li><code>ip::&lt;容器端口&gt;</code>：自动选择宿主机端口（包含宿主机所有IP）映射到容器内端口</li><li><code>&lt;宿主机端口&gt;:&lt;容器端口&gt;</code>：宿主机端口映射到容器内端口</li></ul></li><li>–rm：容器停止时删除容器</li></ul><h3 id="docker-create"><a href="#docker-create" class="headerlink" title="docker create"></a>docker create</h3><p>作用：新建容器，但不启动</p><p>常见命令格式：<code>docker create[option1][option2] &lt;镜像id或名称&gt;</code>，option选项参数含义与run类似但不是全都支持</p><h3 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h3><p>作用：查看容器的运行状况，类似linux的ps命令查看进程的运行状态</p><p><code>docker ps</code>等价于<code>docker container list</code>等价于<code>docker container ls</code></p><ul><li><code>docker ps</code>：列出正在运行的容器</li><li><code>docker ps -a</code>：列出全部容器，包括历史记录中已经停止的容器</li><li><code>docker ps -q</code>：列出正在运行的容器，仅显示容器id</li><li><code>docker ps -n=?</code>：列出最近创建的?个容器</li><li><code>docker ps -l</code>：列出最近创建的上个容器，即<code>docker ps -n=1</code></li></ul><h3 id="docker-stop"><a href="#docker-stop" class="headerlink" title="docker stop"></a>docker stop</h3><p>作用：停止正在运行的容器</p><p>常见命令格式：<code>docker stop &lt;容器id或容器名&gt;</code>，如：</p><ul><li><code>docker stop mysql-test</code>：停止容器名为mysql-test的容器</li><li><code>docker stop d29f876f66d5</code>：停止容器id为d29f876f66d5的容器</li></ul><h3 id="docker-kill"><a href="#docker-kill" class="headerlink" title="docker kill"></a>docker kill</h3><p>作用：强制停止正在运行的容器，类似linux的kill命令</p><p>常见命令格式：<code>docker kill &lt;容器id或容器名&gt;</code>，如：</p><ul><li><code>docker kill mysql-test</code>：强制停止容器名为mysql-test的容器</li></ul><h3 id="docker-start"><a href="#docker-start" class="headerlink" title="docker start"></a>docker start</h3><p>作用：启动容器</p><p>常见命令格式：<code>docker start &lt;容器id或容器名&gt;</code>，如：</p><ul><li><code>docker start mysql-test</code>：启动容器名为mysql-test的容器</li></ul><h3 id="docker-restart"><a href="#docker-restart" class="headerlink" title="docker restart"></a>docker restart</h3><p>作用：重启容器</p><p>常见命令格式：<code>docker restart &lt;容器id或容器名&gt;</code>，如：</p><ul><li><code>docker restartmysql-test</code>：重启容器名为mysql-test的容器</li></ul><h3 id="docker-rm"><a href="#docker-rm" class="headerlink" title="docker rm"></a>docker rm</h3><p>作用：删除容器</p><p>正常情况下正在运行的容器不可删除。</p><p>常见命令格式：<code>docker rm &lt;容器id或容器名&gt;</code>，如：</p><ul><li><code>docker rm mysql-test</code>：删除容器名为mysql-test的容器</li><li><code>docker rm -f mysql-test</code>：强制删除容器名为mysql-test的容器，即使该容器正在运行</li></ul><h2 id="与容器交互"><a href="#与容器交互" class="headerlink" title="与容器交互"></a>与容器交互</h2><h3 id="docker-attach"><a href="#docker-attach" class="headerlink" title="docker attach"></a>docker attach</h3><p>常见命令格式：<code>docker attach &lt;容器id或容器名&gt;</code>，此命令将进入容器正在执行的终端，如容器启动的前台进程是SpringBoot的jar（以前台模式启动），那么此方式进入容器后看到的就是SpringBoot应用的控制台打印的日志。</p><h3 id="docker-exec"><a href="#docker-exec" class="headerlink" title="docker exec"></a>docker exec</h3><p>常见命令格式：<code>docker exec [option] &lt;容器id或容器名&gt;</code>，进入当前容器后开启一个新的终端，option选项常用有：</p><ul><li>-i：即使没有附加也保持STDIN（标准输入）打开</li><li>-t：分配一个伪终端</li><li>-d：分离模式: 在后台运行</li></ul><p>选项意义与run命令的选项类似，如：</p><ul><li><code>docker exec -it mysql-test /bin/bash</code>：我们想进入容器，执行任何命令，就像平时使用linux那样，可同时指定<code>-it</code>选项。</li><li><code>docker exec -t mysql-test ls /</code>：我们想查看某一目录下的文件信息，可以仅指定<code>-t</code>选项来进行回显，执行完毕后就退出了容器。</li><li><code>docker exec -i mysql-test /bin/bash</code>：当使用<code>-i</code>选项执行<code>/bin/bash</code>时，由于标准输入打开，我们可以输入其它命令，但是此时是没有回显的。正常情况下只能用Ctr+C结束与之的交互，此时容器内由”&#x2F;bin&#x2F;bash”命令创建的进程不会被结束。</li><li><code>docker exec mysql-test ls</code>：不带option，有回显，命令执行完毕后，docker发现没有前台进程，退出容器。</li></ul><p>单独使用<code>-i</code>的场景不多，更多使用的是<code>-t</code>和<code>-it</code>。笔者这里对这几个选项的描述可能并不是特别准确，心里明白但无法用文字完美诠释，读者还是自己实操理解会好些。</p><h3 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h3><ul><li>docker attach方式进入容器：按下Ctrl+P+Q退出，如果使用exit退出终端或Ctrl+c方式结束当前前台进程，会导致容器停止！如果使用<code>docker attach --sig-proxy=false &lt;容器id或容器名&gt;</code>进入容器，则可以使用Ctrl+c方式退出</li><li>docker exec方式进入容器：按下Ctrl+P+Q退出，或以exit命令退出当前终端以退出容器。</li></ul><p>两种进入容器的方式使用Ctrl+P+Q退出时，容器不会停止，因为此种方式会保留进入容器时的执行该命令的进程，容器不会退出，如果一个容器已经后台运行，我们以<code>docker exec -it</code>进入容器时，最好以exit命令退出，容器不会保留终端进程。如果是以docker attach方式进入，此时我们来到了容器守护的前台进程，一定要以Ctrl+P+Q方式退出，否则容器会停止。</p><h2 id="容器内外的文件传输"><a href="#容器内外的文件传输" class="headerlink" title="容器内外的文件传输"></a>容器内外的文件传输</h2><h3 id="docker-cp"><a href="#docker-cp" class="headerlink" title="docker cp"></a>docker cp</h3><p>作用：从容器内拷贝文件（文件夹也是文件）到宿主机上</p><p>常见命令格式：<code>docker cp [option] &lt;srcPath&gt; &lt;destPath&gt;</code></p><ul><li>option选项：-L，以保持源目标中的链接 </li><li>srcPath与destPath分两种情况：<ul><li>容器内拷贝文件到容器外：<code>docker cp &lt;容器id或容器名&gt;:&lt;容器内路径&gt; &lt;主机路径&gt;</code></li><li>容器外拷贝文件到容器内：<code>docker cp &lt;主机目的路径&gt; &lt;容器id或容器名&gt;:&lt;容器内路径&gt; </code>，容器内的路径不存在则创建，即重命名</li></ul></li></ul><h3 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h3><p><a href="../docker%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7">《Docker容器数据卷》篇</a></p><h2 id="容器内外的网络连通"><a href="#容器内外的网络连通" class="headerlink" title="容器内外的网络连通"></a>容器内外的网络连通</h2><h3 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h3><p>使用run命令时指定端口映射，前文提到过，见<code>docker run</code>命令的<code>-p</code>与<code>-P</code>选项。</p><h3 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h3><p><a href="../docker%E7%BD%91%E7%BB%9C/">《Docker网络》篇</a></p><h2 id="容器的日志"><a href="#容器的日志" class="headerlink" title="容器的日志"></a>容器的日志</h2><h3 id="docker-logs"><a href="#docker-logs" class="headerlink" title="docker logs"></a>docker logs</h3><p>作用：查看容器运行产生的日志</p><p>命令格式：<code>docker logs [oprion1][option2] &lt;容器id或容器名&gt; </code>，常用option：</p><ul><li><code>docker logs mysql-test</code> ：查看容器名为mysql-test的日志</li><li><code>docker logs -f mysql-test</code> ：查看且跟踪容器名为mysql-test的日志</li><li><code>docker logs -f mysql-test</code> ：查看且跟踪容器名为mysql-test的日志</li><li><code>docker logs -n=100 mysql-test</code> ：查看容器名为mysql-test的最后100行日志</li><li><code>docker logs --since=2021-02-01 mysql-test</code>：查看容器名为mysql-test自2021年2月1日以来的日志</li><li><code>docker logs --since=2021-02-01T00:00 mysql-test</code>：查看容器名为mysql-test自2021年2月1日00:00以来的日志</li><li><code>docker logs --since=2021-02-01T00:00:00 mysql-test</code>：查看容器名为mysql-test自2021年2月1日00:00:00以来的日志</li></ul><h2 id="查看镜像或容器元数据"><a href="#查看镜像或容器元数据" class="headerlink" title="查看镜像或容器元数据"></a>查看镜像或容器元数据</h2><p>镜像或容器元数据：镜像或容器的详细信息，镜像元数据包括镜像完整id、构建时间等，容器元数据包括数据卷、网络等信息。</p><h3 id="docker-inspect"><a href="#docker-inspect" class="headerlink" title="docker inspect"></a>docker inspect</h3><ul><li><p><code>docker inspect &lt;镜像名或镜像ID&gt;</code>（查看镜像元数据）</p><ul><li><code>docker inspect java</code>：查看java（latest版本）的镜像元数据</li><li><code>docker inspect java:7</code>：查看java7的镜像元数据</li></ul></li><li><p><code>docker inspect &lt;容器名或容器ID&gt;</code>（查看容器元数据）</p><ul><li><code>docker inspect mysql-test</code>：查看容器名为mysql-test的容器元数据</li></ul></li></ul><h2 id="Docker镜像原理"><a href="#Docker镜像原理" class="headerlink" title="Docker镜像原理"></a>Docker镜像原理</h2><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时库、环境变量和配置文件。</p><h3 id="镜像加载原理"><a href="#镜像加载原理" class="headerlink" title="镜像加载原理"></a>镜像加载原理</h3><h4 id="UnionFS（联合文件系统）"><a href="#UnionFS（联合文件系统）" class="headerlink" title="UnionFS（联合文件系统）"></a>UnionFS（联合文件系统）</h4><p>复制粘贴一下概念：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，他支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统是 Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p><p>UFS可以类比git的commit进行理解。</p><p>docker的镜像实际上由一层一层的联合文件系统组成。</p><p><img src="/docker%E5%9F%BA%E7%A1%80/dockerUFS.png"></p><p><strong>boots</strong>(boot file system）：主要包含 bootloader和 Kernel, bootloader主要是引导加 kernel, Linux刚启动时会加bootfs文件系统，在Docker镜像的最底层是 boots。这一层与我们典型的Linux&#x2F;Unix系统是一样的，包含boot加載器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs转交给内核，此时系统也会卸载bootfs。<br><strong>rootfs</strong>（root file system)：在 bootfs之上。包含的就是典型 Linux系统中的&#x2F;dev,&#x2F;proc,&#x2F;bin,&#x2F;etc等标准目录和文件。 rootfs就是各种不同的操作系统发行版，比如 Ubuntu, Centos等等。</p><p>平时我们安装进虚拟机的CentOS都是好几个G，为什么Docker这里才200M？</p><p><img src="/docker%E5%9F%BA%E7%A1%80/docker-centos.png"></p><p>对于个精简的OS，rootfs可以很小，只需要包合最基本的命令，工具和程序库就可以了，因为底层直接用宿主机的kernel，自己只需要提供rootfs就可以了。由此可见对于不同的Linux发行版， boots基本是一致的，rootfs会有差別，因此不同的发行版可以公用bootfs。</p><h3 id="镜像的分层"><a href="#镜像的分层" class="headerlink" title="镜像的分层"></a>镜像的分层</h3><p>基于UFS的特点，大多数docker镜像都是由多层镜像“叠加”而来的，所有的 Docker镜像都起始于一个基础镜像层，当进行修改或培加新的内容时，就会在当前镜像层之上，创建新的镜像层，为什么Docker镜像要采用这种分层的结构呢？</p><p>最大的好处，莫过于资源共享了！比如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享。类似于面向对象多态的体现之一：类的继承。</p><h3 id="镜像与容器的联系"><a href="#镜像与容器的联系" class="headerlink" title="镜像与容器的联系"></a>镜像与容器的联系</h3><p>Docker 镜像都是只读的，当容器启动时，一个新的可写层加载到镜像的顶部，这一层就是我们通常说的容器层，容器之下的都叫镜像层。</p><p><img src="/docker%E5%9F%BA%E7%A1%80/container.jpg"></p><p>如果想要保存当前容器的状态，就可以通过<code>docker commit</code>来提交（此处不将commit命令），获得一个镜像，就好比我们我们使用虚拟机的快照。</p><hr><p><strong>本文参考B站UP主“狂神说Java”<a target="_blank" rel="noopener" href="https://space.bilibili.com/95256449/%E7%9A%84docker%E6%95%99%E5%AD%A6%E8%A7%86%E9%A2%91%E8%BF%9B%E8%A1%8C%E6%95%B4%E7%90%86%E3%80%82">https://space.bilibili.com/95256449/的docker教学视频进行整理。</a></strong></p><p><strong>感谢成长路上为在下传道受业解惑之人</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Docker" scheme="https://blog.windshadow.cn/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>cookie session localStorage sessionStorage</title>
    <link href="https://blog.windshadow.cn/webStore/"/>
    <id>https://blog.windshadow.cn/webStore/</id>
    <published>2021-05-12T14:18:29.509Z</published>
    <updated>2024-08-12T17:22:00.054Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><em>啰嗦的话不说，直接上干货，概念性的东西，什么产生背景啥的自己组织一下语言就好了</em></p><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>session是用来在客户端与服务器之间保持状态的一种解决方案（由于http的无状态），主要特点：</p><ul><li><p>数据保存在服务端，session存在过期时间</p></li><li><p>多数情况下session实现依赖cookie，通过cookie存放sessionId，也可通过URL编码的方式携带sessionId</p></li><li><p>session存放的数据的key不能为null（至少在java web中如此）</p></li><li><p>session存放的数据的value为null时视为删除操作（至少在java web中如此）</p><p>放源码，来自apache tomcat的session实现类<code>org.apache.catalina.session.StandardSession</code></p><p><img src="/webStore/session.png"></p></li></ul><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>cookie大小限制，最多4K。</p><p>cookie主要5大属性：</p><ul><li>name：名称</li><li>value：值</li><li>domain：作用域，默认情况下，cookie的domain是设置该cookie的web服务器的域名，如domain域为<code>.ccc.com</code>的cookie可以被<code>www.aaa.ccc.com</code>和<code>www.bbb.ccc.com</code>的网站所读取，不能将一个cookie的域设置成服务器所在的域之外的域 ；cookie的domain属性不与端口相关，即同IP不同端口的web服务有机会获取到对方的cookie（path值匹配的话）</li><li>path：路径值；服务器后端获取cookie的规则：设当前URI为：&#x2F;a&#x2F;b，cookie路径为path，服务器后端能获取到的cookie满足：<code>path.startsWith(URI) || URI.startsWith(path)</code></li><li>expires&#x2F;max-age：过期时间&#x2F;最大“年龄”；根据过期时间 max-age 有3种情况：<ul><li>max-age &gt; 0；cookie到期销毁，此时cookie存于磁盘</li><li>max-age &#x3D; 0；cookie已经过期，此时cookie销毁</li><li>max-age &lt; 0；cookie在关闭浏览器后销毁，此时cookie存于内存</li></ul></li></ul><p>另外还有两个属性值得关注：</p><ul><li><p>secure：取值范围 true | false，是否仅支持https传输</p></li><li><p>SameSite：Chrome 51 开始，浏览器的 Cookie 新增加了一个SameSite属性，限制第三方 Cookie，用来防止 CSRF 攻击和用户追踪，该属性不在服务端体现（至少目前java web是这样）。取值范围：</p><ul><li><p>Strict：完全禁止第三方 Cookie，任何跨域请求浏览器都不会发送cookie</p></li><li><p>Lax：次于Strict的限制级别，任何跨域大多数情况浏览器不会发送cookie，如下表</p><table><thead><tr><th>请求类型</th><th>示例</th><th>Lax</th></tr></thead><tbody><tr><td>链接</td><td>&lt;a href&#x3D;”…”&gt;&lt;&#x2F;a&gt;</td><td>发送 Cookie</td></tr><tr><td>预加载</td><td>&lt;link rel&#x3D;”prerender” href&#x3D;”…”&#x2F;&gt;</td><td>发送 Cookie</td></tr><tr><td>GET 表单</td><td>&lt;form method&#x3D;”GET” action&#x3D;”…”&gt;</td><td>发送 Cookie</td></tr><tr><td>POST 表单</td><td>&lt;form method&#x3D;”POST” action&#x3D;”…”&gt;</td><td>不发送</td></tr><tr><td>iframe</td><td>&lt;iframe src&#x3D;”…”&gt;&lt;&#x2F;iframe&gt;</td><td>不发送</td></tr><tr><td>ajax</td><td>$.get(“…”)</td><td>不发送</td></tr><tr><td>Image</td><td>&lt;img src&#x3D;”…”&gt;</td><td>不发送</td></tr></tbody></table></li><li><p>None：不禁止第三方 Cookie，跨域请求浏览器都会发送cookie，当secure为true时，该值才有效（此条知识点以Chrome浏览器80版本之后为前提）</p></li></ul></li></ul><h3 id="后端读写cookie"><a href="#后端读写cookie" class="headerlink" title="后端读写cookie"></a>后端读写cookie</h3><p>后端读取cookie的特点：</p><ul><li>后端通过request对象获取cookie：<code>Cookie[] cookies = request.getCookies()</code>，值得注意的是获取到的cookie数量为0时，该方法返回的是null而不是空数组。</li></ul><p>设当前访问的地址URI为 <code>/xxx/yyy</code>，写入规则如下：</p><table><thead><tr><th>属性</th><th>后端写cookie的值</th><th>描述</th><th>浏览器实际存储的值</th><th>含义</th></tr></thead><tbody><tr><td>name</td><td>“abc”</td><td></td><td>“abc”</td><td></td></tr><tr><td>name</td><td>null</td><td>null引用</td><td></td><td>后端抛IllegalArgumentException异常</td></tr><tr><td>name</td><td>“”或” “</td><td>空白字符串</td><td></td><td>后端抛IllegalArgumentException异常</td></tr><tr><td>name</td><td>“  abc”或“abc ”</td><td>空白字符开头或结尾的字符串</td><td></td><td>后端抛IllegalArgumentException异常</td></tr><tr><td>value</td><td>null</td><td>null引用</td><td>“”</td><td></td></tr><tr><td>value</td><td>“”</td><td>长度为0的字符串</td><td>“”</td><td></td></tr><tr><td>value</td><td>“ “</td><td>空白字符串</td><td></td><td>后端抛IllegalArgumentException异常</td></tr><tr><td>path</td><td>&#x2F;xxx</td><td>当前路径的或子路径</td><td>&#x2F;xxx</td><td></td></tr><tr><td>path</td><td>&#x2F;</td><td>&#x2F; 代表根</td><td>${contextPath}</td><td>web容器上下文</td></tr><tr><td>path</td><td>null</td><td>null引用</td><td>${contextPath}</td><td>web容器上下文</td></tr><tr><td>path</td><td>“”或” “</td><td>长度为0或空白字符串</td><td>${contextPath}</td><td>web容器上下文</td></tr><tr><td>path</td><td>xyz</td><td>不以斜杠开头的字符串</td><td>${contextPath}</td><td>web容器上下文</td></tr><tr><td>path</td><td>&#x2F;zzz</td><td>其它路径</td><td>&#x2F;zzz</td><td></td></tr><tr><td>expires&#x2F;max-age</td><td>age &gt; 0</td><td>过期时间大于0秒</td><td>age * 1000ms</td><td>cookie到期销毁</td></tr><tr><td>expires&#x2F;max-age</td><td>age &#x3D; 0</td><td>过期时间等于0秒</td><td>0ms</td><td>cookie已经过期，销毁</td></tr><tr><td>expires&#x2F;max-age</td><td>age &lt; 0</td><td>过期时间小于0秒</td><td>N&#x2F;A(Session)</td><td>关闭浏览器时cookie销毁</td></tr></tbody></table><ul><li><strong>当${contextPath}web容器上下文为空时，则写入浏览器的path为 &#x2F;。</strong></li></ul><h3 id="前端读写cookie"><a href="#前端读写cookie" class="headerlink" title="前端读写cookie"></a>前端读写cookie</h3><p>代码可封装如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setCookie</span>(<span class="params">name,value,age,path</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> expiresString = <span class="string">&quot;Session&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(age)) &#123;</span><br><span class="line">        <span class="comment">// age 小于0则视为Session会话级别的cookie</span></span><br><span class="line">        <span class="keyword">if</span> (age &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> expires = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">            expires.<span class="title function_">setTime</span>(expires.<span class="title function_">getTime</span>() + age * <span class="number">1000</span>);</span><br><span class="line">            expiresString = expires.<span class="title function_">toGMTString</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">cookie</span>= name + <span class="string">&quot;=&quot;</span> + value + <span class="string">&quot;; expires=&quot;</span> + expiresString + <span class="string">&quot;;path=&quot;</span> + path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前浏览器地址为 <code>/xxx/yyy</code></p><table><thead><tr><th>属性</th><th>前端写cookie的值</th><th>浏览器实际存储的值</th><th>后端接受到的值</th><th>含义</th></tr></thead><tbody><tr><td>name</td><td>“abc”</td><td>“abc”</td><td>“abc”</td><td></td></tr><tr><td>name</td><td>“”或” “</td><td>“”</td><td>${value}</td><td>name无效，后端取出的name反而为其value值</td></tr><tr><td>name</td><td>“  abc”</td><td>“abc”</td><td>“abc”</td><td>前端存cookie会处理name的首尾空白字符</td></tr><tr><td>name</td><td>null</td><td>“null”</td><td>“null”</td><td>null类型转换为”null”字符串</td></tr><tr><td>name</td><td>undefined</td><td>“undefined”</td><td>“undefined”</td><td>undefined类型转换为”undefined”字符串</td></tr><tr><td>value</td><td>“abc”</td><td>“abc”</td><td>“abc”</td><td></td></tr><tr><td>value</td><td>“”</td><td>“”</td><td>“”</td><td></td></tr><tr><td>value</td><td>“ “</td><td>“”</td><td>“”</td><td>前端存cookie会处理value的首尾空白字符</td></tr><tr><td>value</td><td>null</td><td>“null”</td><td>“null”</td><td>null类型转换为”null”字符串</td></tr><tr><td>value</td><td>undefined</td><td>“undefined”</td><td>“undefined”</td><td>undefined类型转换为”undefined”字符串</td></tr><tr><td>path</td><td>&#x2F;xxx</td><td>&#x2F;xxx</td><td>null（后端不感知path值）</td><td></td></tr><tr><td>path</td><td>&#x2F;zzz</td><td>&#x2F;zzz</td><td>null（后端不感知path值）</td><td>其它路径</td></tr><tr><td>path</td><td>&#x2F;</td><td>&#x2F;</td><td>null（后端不感知path值）</td><td>&#x2F; 根</td></tr><tr><td>path</td><td>xyz</td><td>&#x2F;xxx</td><td>null（后端不感知path值）</td><td>当前路径的前一级路径，若不存在则为 &#x2F;</td></tr><tr><td>path</td><td>undefined</td><td>&#x2F;xxx</td><td>null（后端不感知path值）</td><td>当前路径的前一级路径，若不存在则为 &#x2F;</td></tr><tr><td>path</td><td>null</td><td>&#x2F;xxx</td><td>null（后端不感知path值）</td><td>当前路径的前一级路径，若不存在则为 &#x2F;</td></tr><tr><td>path</td><td>“”</td><td>&#x2F;xxx</td><td>null（后端不感知path值）</td><td>当前路径的前一级路径，若不存在则为 &#x2F;</td></tr><tr><td>path</td><td>“ “</td><td>&#x2F;xxx</td><td>null（后端不感知path值）</td><td>当前路径的前一级路径，若不存在则为 &#x2F;</td></tr><tr><td>expires</td><td>“Session”</td><td>N&#x2F;A(Session)</td><td>-1（后端不感知过期时间）</td><td>关闭浏览器时cookie销毁（存于内存）</td></tr><tr><td>expires</td><td>t &gt; 0</td><td>过期时间大于0秒</td><td>-1（后端不感知过期时间）</td><td>cookie到期销毁（存于磁盘）</td></tr><tr><td>expires</td><td>t &lt; 0</td><td>过期时间小于0秒</td><td>-1（后端不感知过期时间）</td><td>cookie已经过期，销毁</td></tr></tbody></table><ul><li>前端js代码写cookie时，过对<code>document.cookie</code>赋值进行设置cookie</li><li>设置的属性基本都有默认值，如果设置的值是“无理”的，属性都会取默认值，path属性默认为当前路径的前一级路径，expires属性默认为”Session”。</li><li>设置的name和value属性会进行一定优化，需要主要后端取到实际值的不同</li></ul><h2 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h2><p>localStorage属性在HTML5时增加，允许在浏览器中存储 key&#x2F;value 对的数据，特点：</p><ul><li>只支持string类型的存储，key和value哪怕set时是number类型也会转成string类型</li><li>遵循同源策略</li><li>永久存在浏览器中，除非手动删除</li><li>一般浏览器支持的是5M大小，不同的浏览器中会有所不同 </li><li>浏览器发送请求时不会带上</li></ul><h2 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h2><p>sessionStorage属性在HTML5时增加，允许在浏览器中存储 key&#x2F;value 对的数据，特点：</p><ul><li>只支持string类型的存储，key和value哪怕set时是number类型也会转成string类型</li><li>数据仅在当前浏览器窗口有效</li><li>一般浏览器支持的是5M大小，不同的浏览器中会有所不同 </li><li>浏览器发送请求时不会带上</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><table><thead><tr><th></th><th>数据存放位置</th><th>非手动情况下数据销毁时机</th></tr></thead><tbody><tr><td>session</td><td>服务端（依赖cookie存放sessionId）</td><td>session过期</td></tr><tr><td>cookie</td><td>浏览器</td><td>到达过期时间</td></tr><tr><td>localStorage</td><td>浏览器</td><td>必须手动删除</td></tr><tr><td>sessionStorage</td><td>浏览器</td><td>浏览器窗口关闭</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="web基础" scheme="https://blog.windshadow.cn/categories/web%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Nginx使用ssl</title>
    <link href="https://blog.windshadow.cn/Nginx%E4%BD%BF%E7%94%A8ssl/"/>
    <id>https://blog.windshadow.cn/Nginx%E4%BD%BF%E7%94%A8ssl/</id>
    <published>2021-03-15T13:31:41.751Z</published>
    <updated>2022-10-03T10:20:28.753Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Nginx使用ssl"><a href="#Nginx使用ssl" class="headerlink" title="Nginx使用ssl"></a>Nginx使用ssl</h1><p>nginx往往通过反向代理屏蔽服务端，nginx使用ssl的可以让客户端使用https协议与nginx通信，在一定程度上保证整个链路的数据安全。</p><h2 id="证书生成"><a href="#证书生成" class="headerlink" title="证书生成"></a>证书生成</h2><p>自签CA与证书生成可参考<a href="/WindShadow/web%E5%9F%BA%E7%A1%80/TLS%E8%AF%81%E4%B9%A6%E4%B8%8E%E8%87%AA%E7%AD%BEca/">《TLS证书与自签ca》</a></p><p>于是得到</p><table><thead><tr><th>文件</th><th>用途</th></tr></thead><tbody><tr><td>ws-serverca.crt</td><td>服务端证书</td></tr><tr><td>ws-serverca.key</td><td>服务端私钥</td></tr><tr><td>ws-trust.crt</td><td>服务端可信的ca证书</td></tr></tbody></table><h2 id="nginx配置ssl"><a href="#nginx配置ssl" class="headerlink" title="nginx配置ssl"></a>nginx配置ssl</h2><p>证书与私钥配置相对路径起点为位置为nginx安装目录，假设nginx安装目录下存在ssl文件夹</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">443</span>; </span><br><span class="line">    <span class="attribute">server_name</span>  ip;<span class="comment"># ip 或域名</span></span><br><span class="line">    <span class="attribute">ssl_certificate</span>      ssl/ws-serverca.crt;<span class="comment"># 证书位置</span></span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>  ssl/ws-serverca.key;<span class="comment"># 证书私钥</span></span><br><span class="line">    <span class="attribute">ssl</span> <span class="literal">on</span>;<span class="comment"># 开启ssl</span></span><br><span class="line">    <span class="comment"># 其它配置 ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般我们还会配置http请求的80端口重定向到443端口</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  ip;<span class="comment"># ip 或域名</span></span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/(.*)$</span> https://ip:443/<span class="variable">$1</span> <span class="literal">permanent</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此配置方式为https的单向认证，一般自签证书使用这种方式较多</p><h2 id="双向认证"><a href="#双向认证" class="headerlink" title="双向认证"></a>双向认证</h2><p>前文介绍的是nginx使用ssl完成https单向认证的操作，此章节介绍双向认证。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">443</span>; </span><br><span class="line">    <span class="attribute">server_name</span>  ip;<span class="comment"># ip 或域名</span></span><br><span class="line">    <span class="attribute">ssl_certificate</span>      ssl/ws-ssl-server.crt;<span class="comment"># 证书位置</span></span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>  ssl/ws-ssl-server.key;<span class="comment"># 证书私钥</span></span><br><span class="line">    <span class="attribute">ssl</span> <span class="literal">on</span>;<span class="comment"># 开启ssl</span></span><br><span class="line">    <span class="attribute">ssl_client_certificate</span> ssl/ws-ssl-client.cer;  <span class="comment">#客户端证书</span></span><br><span class="line">    <span class="attribute">ssl_verify_client</span> <span class="literal">on</span>; <span class="comment"># 开启客户端证书验证</span></span><br><span class="line">    <span class="attribute">ssl_trusted_certificate</span> ssl/ws-trust.crt; <span class="comment"># 信任的证书</span></span><br><span class="line">    <span class="comment"># 其它配置 ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ssl常用指令"><a href="#ssl常用指令" class="headerlink" title="ssl常用指令"></a>ssl常用指令</h2><ul><li><p>ssl on | off;</p><p>为指定的虚拟主机配置是否启用ssl功能，此功能在1.15.0废弃，使用listen [ssl]替代。</p></li><li><p>ssl_certificate server.crt; </p><p>当前虚拟主机使用使用的证书文件，一般是crt文件</p></li><li><p>ssl_certificate_key server.key;</p><p>当前虚拟主机使用的私钥文件，一般是key文件</p></li><li><p>ssl_client_certificate ssl client.cer;</p><p>客户端证书</p></li><li><p>ssl_verify_client on;</p><p>开启客户端证书验证</p></li><li><p>ssl_protocols [SSLv2][SSLv3][TLSv1][TLSv1.1][TLSv1.2]</p><p>支持ssl协议版本，早期为ssl现在是TSL，默认为后三个</p></li><li><p>ssl_session_cache off | none | [builtin[:size]][shared:name:size];</p><p>配置ssl缓存：off：关闭缓存；none: 通知客户端支持ssl session cache，但实际不支持；</p><p>builtin[:size]：使用OpenSSL内建缓存，为每worker进程私有</p><p>[shared:name:size]：在各worker之间使用一个共享的缓存，需要定义一个缓存名称和缓存空间大小，一兆可以存储4000个会话信息，多个虚拟主机可以使用相同的缓存名称。</p></li><li><p>ssl_session_timeout time;</p><p>客户端连接可以复用ssl session cache中缓存的有效时长，默认5m（分钟）</p></li></ul><p>关于证书格式：其实证书格式之间的差异几乎也就编码问题，后缀也并不能完全代表什么，每个软件支持的格式可能不一样，如tomcat和nginx的差异，能用就行，不能就转换格式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Nginx" scheme="https://blog.windshadow.cn/categories/Nginx/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring框架基础能力-数据转换</title>
    <link href="https://blog.windshadow.cn/Spring%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80%E8%83%BD%E5%8A%9B-%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/"/>
    <id>https://blog.windshadow.cn/Spring%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80%E8%83%BD%E5%8A%9B-%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/</id>
    <published>2021-02-28T11:48:25.826Z</published>
    <updated>2024-08-12T17:21:31.163Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Spring的数据转换器"><a href="#Spring的数据转换器" class="headerlink" title="Spring的数据转换器"></a>Spring的数据转换器</h2><p>众所周知，在书写Spring的配置文件或者前端请求后端时，我们所有配置项的值或参数值都是字符串的形式存在（上传文件的IO流也类似），根据一定的书写规则，Spring可以将这些原本为string类型的值赋值到对应的bean上或SpringMVC控制层的方法的实参上，这得益于Spring中强大的数据转换能力，下面盘点一波“Spring的数据转换器”。</p><p>Spring中的数据转换器主要分两大派系：</p><ul><li><p>PropertyEditor（属性编辑器）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.beans;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PropertyEditor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Object value)</span>;</span><br><span class="line">    Object <span class="title function_">getValue</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isPaintable</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">paintValue</span><span class="params">(java.awt.Graphics gfx, java.awt.Rectangle box)</span>;</span><br><span class="line">    String <span class="title function_">getJavaInitializationString</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getAsText</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setAsText</span><span class="params">(String text)</span> <span class="keyword">throws</span> java.lang.IllegalArgumentException;</span><br><span class="line">    String[] getTags();</span><br><span class="line">    java.awt.Component <span class="title function_">getCustomEditor</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">supportsCustomEditor</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addPropertyChangeListener</span><span class="params">(PropertyChangeListener listener)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removePropertyChangeListener</span><span class="params">(PropertyChangeListener listener)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PropertyEditor</code>是JavaBean规范定义的接口，这是java.beans中一个接口，其设计方便对象与String之间的转换工作，而spring将其扩展，方便各种对象与String之间的转换工作。Spring所有的扩展都是通过继承<code>PropertyEditorSupport</code>，因为它只聚焦于转换上，所以只需复写setAsText()、getAsText()以及构造方法即可实现扩展。</p><p>Spring 使用PropertyEditor的接口来实现对象和字符串之间的转换，比如将 2020-01-01转化为日期类型等，可以通过注册自定义编辑器来实现此功能。</p><p>应用场景：</p><ul><li>在基于xml的配置中，我们往往通过字面值为Bean各种类型的属性提供设置值：如double、int类型，在配置文件配置字面值即可。Spring填充Bean属性时如何将这个字面值转换为对应的类型呢？我们可以隐约地感觉到一定有一个转换器在其中起作用，这个转换器就是属性编辑器。</li><li>再者便是Spring MVC框架使用多种PropertyEditor分析绑定HTTP请求的各种参数</li></ul></li><li><p>Converter（转换器）</p><p>Spring的<code>Converter</code>可以将一种类型转换成另一种类型的一个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Converter</span>&lt;S, T&gt; &#123;</span><br><span class="line"><span class="comment">// 把S转成T</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">T <span class="title function_">convert</span><span class="params">(S source)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring提供了3种converter接口：</p><ul><li><p><code>Converter</code>接口 ：使用最简单，最不灵活，1:1</p></li><li><p><code>ConverterFactory</code>接口 ：使用较复杂，比较灵活 1:N</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConverterFactory</span>&lt;S, R&gt; &#123;</span><br><span class="line">&lt;T <span class="keyword">extends</span> <span class="title class_">R</span>&gt; Converter&lt;S, T&gt; <span class="title function_">getConverter</span><span class="params">(Class&lt;T&gt; targetType)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>GenericConverter</code>接口 ：使用最复杂，也最灵活 N:N</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GenericConverter</span> &#123;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">Set&lt;ConvertiblePair&gt; <span class="title function_">getConvertibleTypes</span><span class="params">()</span>;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">Object <span class="title function_">convert</span><span class="params">(<span class="meta">@Nullable</span> Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ConvertiblePair</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>既然有了PropertyEditor，那为何还需要有Converter呢？因为Java原生的PropertyEditor存在以下两点不足：</p><ol><li>只能用于字符串和Java对象的转换，不适用于任意两个Java类型之间的转换；</li><li>对源对象及目标对象所在的上下文信息（如注解、所在宿主类的结构等）不敏感，在类型转换时不能利用这些上下文信息实施高级转换逻辑。</li></ol><p>鉴于此，Spring 3.0在核心模型中添加了一个通用的类型转换模块。Spring希望用这个类型转换体系替换Java标准的PropertyEditor。但由于历史原因，Spring将同时支持两者。在Bean配置、Spring MVC处理方法入参绑定中使用它们。</p><p>**注：如今SpringBoot是开发首先，本文所列罗的源码均来自于SpringBoot 2.3.7.RELEASE **</p><h2 id="PropertyEditor属性编辑器"><a href="#PropertyEditor属性编辑器" class="headerlink" title="PropertyEditor属性编辑器"></a>PropertyEditor属性编辑器</h2><h3 id="PropertyEditor在Bean配置上的使用"><a href="#PropertyEditor在Bean配置上的使用" class="headerlink" title="PropertyEditor在Bean配置上的使用"></a>PropertyEditor在Bean配置上的使用</h3><p>以字符串转换为自定义对象为需求；</p><p>定义一个<code>Student</code>实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Max(100)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个Student的属性编辑器，继承<code>PropertyEditorSupport</code>以实现<code>PropertyEditor</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 把“(1001,张三)” 转换成 &#123;<span class="doctag">@link</span> Student&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentEditor</span> <span class="keyword">extends</span> <span class="title class_">PropertyEditorSupport</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text 这里进来的字符串不会是空的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAsText</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">        <span class="comment">// 解析字符串过程...</span></span><br><span class="line">        <span class="built_in">this</span>.setValue(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1001</span>,<span class="string">&quot;张三&quot;</span>)); <span class="comment">// 关键的setValue方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入一个属性编辑器的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertyEditorConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class&lt;?&gt;, Class&lt;? <span class="keyword">extends</span> <span class="title class_">PropertyEditor</span>&gt;&gt; customEditors;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     *     注册属性编辑器，使IOC创建bean时拥有string类型转为目标类型的能力</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     *     注意SpringMVC进行参数绑定时是无法利用此能力的，这是&#123;<span class="doctag">@link</span> org.springframework.beans.factory.BeanFactory&#125;的能力，SpringMVC上使用需要额外注册</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> CustomEditorConfigurer&#125;实现了&#123;<span class="doctag">@link</span> org.springframework.beans.factory.config.BeanFactoryPostProcessor&#125;接口，设置为静态方法以提高优先级</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> CustomEditorConfigurer&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ws.spring.convert.controller.CustomControllerAdvice#initBinder(WebDataBinder) SpringMVC在参数绑定期间注册属性编辑器实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CustomEditorConfigurer <span class="title function_">customEditorConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">CustomEditorConfigurer</span> <span class="variable">configurer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomEditorConfigurer</span>();</span><br><span class="line">        configurer.setCustomEditors(getPropertyEditors());</span><br><span class="line">        <span class="keyword">return</span> configurer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存全部的属性编辑器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Class&lt;?&gt;, Class&lt;? <span class="keyword">extends</span> <span class="title class_">PropertyEditor</span>&gt;&gt; getPropertyEditors() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (customEditors == <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">synchronized</span> (PropertyEditorConfig.class) &#123;</span><br><span class="line">               <span class="keyword">if</span> (customEditors == <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                   customEditors = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">4</span>/<span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">                   customEditors.put(Student.class, StudentEditor.class);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> customEditors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义bean组件需要注入Student类的属性，支持校验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;custom.bean&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Student student;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">custom:</span></span><br><span class="line"> <span class="attr">bean:</span></span><br><span class="line">   <span class="attr">student:</span> <span class="string">(81,张三)</span></span><br></pre></td></tr></table></figure><p><strong>疑点</strong>：Spring如何使用到了我们注册的PropertyEditor？</p><p>因为<code>CustomEditorConfigurer</code>实现了<code>BeanFactoryPostProcessor</code>接口，往beanFactory注册了我们的PropertyEditor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory.config;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomEditorConfigurer</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span>, Ordered &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.propertyEditorRegistrars != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (PropertyEditorRegistrar propertyEditorRegistrar : <span class="built_in">this</span>.propertyEditorRegistrars) &#123;</span><br><span class="line">beanFactory.addPropertyEditorRegistrar(propertyEditorRegistrar);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.customEditors != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="built_in">this</span>.customEditors.forEach(beanFactory::registerCustomEditor); <span class="comment">// 注册 PropertyEditor</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PropertyEditor在MVC参数绑定上的使用"><a href="#PropertyEditor在MVC参数绑定上的使用" class="headerlink" title="PropertyEditor在MVC参数绑定上的使用"></a>PropertyEditor在MVC参数绑定上的使用</h3><p>首先要清楚一个概念，MVC的参数绑定看起来很像bean配置过程，基本也是从字符串到java对象的转换，但是前者是MVC模块的功能，后者是beanFactory的能力，MVC只是Spring体系中的一员，IOC中beanFactory才是整个Spring体系的核心。所以数据转换这样的基础功能，MVC的参数绑定是不能使用beanFactory的转换能力的，因为<strong>参数绑定过程不是bean的创建过程，创建的对象不是SpringBean</strong>。所以数据转换的功能在MVC模块是需要注册进去才有的，即一次编写，多处注册。</p><p>先定义一个控制层的增强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestControllerAdvice(assignableTypes = &#123;PropertyEditorController.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomControllerAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@InitBinder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initBinder</span><span class="params">(WebDataBinder binder)</span> &#123; </span><br><span class="line">        <span class="comment">// 注册属性编辑器</span></span><br><span class="line">        registerCustomEditor(binder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">registerCustomEditor</span><span class="params">(WebDataBinder binder)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        此种绑定方式看似很好，先找到对应的属性编辑器，再进行注册，但是此时 target 为 null，不知道 target的类型，也就无法“对症下药”</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        Object target = binder.getTarget();</span></span><br><span class="line"><span class="comment">        if (target == null) &#123;</span></span><br><span class="line"><span class="comment">            return;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        // 注册对应的属性编辑器到当前的绑定器，如果存在的话</span></span><br><span class="line"><span class="comment">        Class&lt;?&gt; entityClass = target.getClass();</span></span><br><span class="line"><span class="comment">        Class&lt;? extends PropertyEditor&gt; entityPropertyEditorClass = PropertyEditorConfig.getPropertyEditors().get(entityClass);</span></span><br><span class="line"><span class="comment">        if (entityPropertyEditorClass != null) &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            registerCustomEditor(binder,entityClass,entityPropertyEditorClass);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="comment">// 注册全部的属性编辑器到当前的绑定器（比较退而求其次的做法）</span></span><br><span class="line">        PropertyEditorConfig.getPropertyEditors()</span><br><span class="line">            .forEach((entityClass,entityPropertyEditorClass) -&gt; registerCustomEditor(binder,entityClass,entityPropertyEditorClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">registerCustomEditor</span><span class="params">(WebDataBinder binder,Class&lt;?&gt; entityClass, Class&lt;? extends PropertyEditor&gt; entityPropertyEditorClass)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor&lt;? <span class="keyword">extends</span> <span class="title class_">PropertyEditor</span>&gt; constructor = entityPropertyEditorClass.getConstructor();</span><br><span class="line">            <span class="type">PropertyEditor</span> <span class="variable">editor</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line">            binder.registerCustomEditor(entityClass,editor);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ReflectiveOperationException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;属性编辑器&lt;&#123;&#125;&gt;没有无参构造方法&quot;</span>,entityPropertyEditorClass.getTypeName(),e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义控制层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertyEditorController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get请求string参数转&#123;<span class="doctag">@link</span> Student&#125;，使用&#123;<span class="doctag">@link</span> RequestParam&#125;指定参数名</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;但是无法进行数据校验</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> student Get请求的String参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/property-editor-assign&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">stringToStudentAssign</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@RequestParam(&quot;student&quot;)</span> Student student)</span> &#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;student: &#123;&#125;&quot;</span>,student);</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get请求string参数转&#123;<span class="doctag">@link</span> Student&#125;，不指定参数名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> student Get请求的String参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> 无法从Get请求的String参数映射</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/property-editor-non-assign&quot;)</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">stringToStudentNonAssign</span><span class="params">(<span class="meta">@Validated</span> Student student)</span> &#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;student: &#123;&#125;&quot;</span>,student);</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(student);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>PropertyEditor是线程不安全的，一个实例对应一次String转换操作，而且在IOC启动时的bean配置和MVC参数绑定功能上需要各自注册，且MVC参数绑定增强时不能获取参数类型进行按需注册，退而求其次的做法是全部注册可能的PropertyEditor。</p><h2 id="Converter转换器"><a href="#Converter转换器" class="headerlink" title="Converter转换器"></a>Converter转换器</h2><h3 id="Converter在Bean配置上的使用"><a href="#Converter在Bean配置上的使用" class="headerlink" title="Converter在Bean配置上的使用"></a>Converter在Bean配置上的使用</h3><p>在此之前我们需要了解一个新的接口<code>ConversionService</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConversionService</span> &#123;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">canConvert</span><span class="params">(<span class="meta">@Nullable</span> Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType)</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">canConvert</span><span class="params">(<span class="meta">@Nullable</span> TypeDescriptor sourceType, TypeDescriptor targetType)</span>;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">&lt;T&gt; T <span class="title function_">convert</span><span class="params">(<span class="meta">@Nullable</span> Object source, Class&lt;T&gt; targetType)</span>;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">Object <span class="title function_">convert</span><span class="params">(<span class="meta">@Nullable</span> Object source, <span class="meta">@Nullable</span> TypeDescriptor sourceType, TypeDescriptor targetType)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顾名思义就是Converter的服务，这个接口通过管理<code>Converter</code>、<code>ConverterFactory</code>、<code>GenericConverter</code>统一对外提供转换服务，所以Spring的的Bean转换操作使用的是ConversionService，贴上<code>ConfigurableBeanFactory</code>的接口声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory.config;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConfigurableBeanFactory</span> <span class="keyword">extends</span> <span class="title class_">HierarchicalBeanFactory</span>, SingletonBeanRegistry &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Specify a Spring 3.0 ConversionService to use for converting</span></span><br><span class="line"><span class="comment"> * property values, as an alternative to JavaBeans PropertyEditors.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setConversionService</span><span class="params">(<span class="meta">@Nullable</span> ConversionService conversionService)</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看使用Converter如何实现以字符串转换为自定义对象的需求；</p><p>定义实体类Town</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Town</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Max(100)</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义转换器且加入IOC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TownConverter</span> <span class="keyword">implements</span> <span class="title class_">Converter</span>&lt;String, Town&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 &quot;100-南京&quot; 转换成&#123;<span class="doctag">@link</span> Town&#125;对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Town <span class="title function_">convert</span><span class="params">(String source)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line"><span class="comment">// 解析字符串过程...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Town</span>(<span class="number">100</span>,<span class="string">&quot;南京&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>往IOC中注入配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConverterConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * bean名称必须叫 &quot;conversionService&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ConversionServiceFactoryBean <span class="title function_">conversionService</span><span class="params">(<span class="meta">@Autowired</span> TownConverter townConverter)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ConversionServiceFactoryBean</span> <span class="variable">conversionService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConversionServiceFactoryBean</span>();</span><br><span class="line">        Set&lt;Converter&gt; converters = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        converters.add(townConverter);</span><br><span class="line">        <span class="comment">// add other</span></span><br><span class="line">        conversionService.setConverters(converters);</span><br><span class="line">        <span class="keyword">return</span> conversionService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConversionServiceFactoryBean</code>类是一个工厂bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context.support;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConversionServiceFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;ConversionService&gt;, InitializingBean &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义bean组件需要注入Town类的属性，支持校验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;custom.bean&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="keyword">private</span> Town town;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">custom:</span></span><br><span class="line"> <span class="attr">bean:</span></span><br><span class="line">   <span class="attr">town:</span> <span class="number">100</span><span class="string">-南京</span></span><br></pre></td></tr></table></figure><p><strong>疑点</strong>：为什么我们注册一个到名为”conversionService”类型为<code>ConversionService</code>的bean，Spring IOC容器在bean配置时就可以使用这个conversionService来完成属性的数据转换呢？</p><p>答案在<code>ConfigurableApplicationContext</code>和<code>AbstractApplicationContext</code>的源码里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConfigurableApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">ApplicationContext</span>, Lifecycle, Closeable &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Name of the ConversionService bean in the factory.</span></span><br><span class="line"><span class="comment"> * If none is supplied, default conversion rules apply.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.core.convert.ConversionService</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">CONVERSION_SERVICE_BEAN_NAME</span> <span class="operator">=</span> <span class="string">&quot;conversionService&quot;</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context.support;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">DefaultResourceLoader</span> <span class="keyword">implements</span> <span class="title class_">ConfigurableApplicationContext</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line"><span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">beanFactory.setConversionService(</span><br><span class="line">beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractApplicationContext在完成beanFactory的初始化工作时，会从beanFactory中获取名为”conversionService”类型为<code>ConversionService</code>的bean，将其作为后续beanFactory的转换服务。</p><h3 id="Converter在MVC参数绑定上的使用"><a href="#Converter在MVC参数绑定上的使用" class="headerlink" title="Converter在MVC参数绑定上的使用"></a>Converter在MVC参数绑定上的使用</h3><p>前面我们已经把<code>TownConverter</code>加入IOC中了，在Controller上我们可以直接享受其转换能力。</p><p>定义控制层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConvertController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get请求string参数转&#123;<span class="doctag">@link</span> Town&#125;，使用&#123;<span class="doctag">@link</span> RequestParam&#125;指定参数名</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;/converter/assign?town=1001-风雷镇</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;但是无法进行数据校验，见&#123;<span class="doctag">@link</span> CustomControllerAdvice#initBinder(WebDataBinder)&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> town Get请求的String参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ws.spring.convert.converter.TownConverter 加入IOC之后控制层直接可以进行String到&#123;<span class="doctag">@link</span> Town&#125;的转换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/converter/assign&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">stringToTown</span><span class="params">(<span class="meta">@RequestParam(&quot;town&quot;)</span> <span class="meta">@Validated</span> Town town)</span> &#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;town: &#123;&#125;&quot;</span>,town);</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(town);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get请求string参数转&#123;<span class="doctag">@link</span> Town&#125;，不指定参数名</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;/converter/non-assign?town=1001-风雷镇</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;可以进行数据校验</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> town Get请求的String参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/converter/non-assign&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">stringToTown2</span><span class="params">(<span class="meta">@Validated</span> Town town)</span> &#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;town: &#123;&#125;&quot;</span>,town);</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(town);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>疑点</strong>：为什么MVC的参数绑定可以直接使用我们加入到IOC的Converter bean的能力而不需要像PropertyEditor那样额外注册呢？</p><p>解答：</p><p>首先我们知道<code>WebMvcConfigurer</code>接口是MVC模块的配置接口，其中有一个addFormatters方法，我们可以通过FormatterRegistry注册器注册我们的Formatter（见下文）、Converter等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.servlet.config.annotation;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">addFormatters</span><span class="params">(FormatterRegistry registry)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FormatterRegistry</code>继承了<code>ConverterRegistry</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.format;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FormatterRegistry</span> <span class="keyword">extends</span> <span class="title class_">ConverterRegistry</span> &#123;</span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConverterRegistry</code>接口可以注册Converter等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConverterRegistry</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addConverter</span><span class="params">(Converter&lt;?, ?&gt; converter)</span>;</span><br><span class="line">&lt;S, T&gt; <span class="keyword">void</span> <span class="title function_">addConverter</span><span class="params">(Class&lt;S&gt; sourceType, Class&lt;T&gt; targetType, Converter&lt;? <span class="built_in">super</span> S, ? extends T&gt; converter)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addConverter</span><span class="params">(GenericConverter converter)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addConverterFactory</span><span class="params">(ConverterFactory&lt;?, ?&gt; factory)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">removeConvertible</span><span class="params">(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切入点：</p><p>在MVC的自动装配类<code>WebMvcAutoConfiguration</code>中，可以看到这样一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot.autoconfigure.web.servlet;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfiguration</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Import(EnableWebMvcConfiguration.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123; WebMvcProperties.class, ResourceProperties.class &#125;)</span></span><br><span class="line"><span class="meta">@Order(0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfigurationAdapter</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFormatters</span><span class="params">(FormatterRegistry registry)</span> &#123;</span><br><span class="line">ApplicationConversionService.addBeans(registry, <span class="built_in">this</span>.beanFactory);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>WebMvcAutoConfigurationAdapter</code>实现<code>WebMvcConfigurer</code>接口注册到IOC中，并调用<code>ApplicationConversionService.addBeans(registry, this.beanFactory);</code>方法注册了一些bean</p><p>继续跟源码 ApplicationConversionService.addBeans(registry, this.beanFactory)；可以看到beanFactory中的Converter bean被注册到FormatterRegistry中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot.convert;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationConversionService</span> <span class="keyword">extends</span> <span class="title class_">FormattingConversionService</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add &#123;<span class="doctag">@link</span> GenericConverter&#125;, &#123;<span class="doctag">@link</span> Converter&#125;, &#123;<span class="doctag">@link</span> Printer&#125;, &#123;<span class="doctag">@link</span> Parser&#125;</span></span><br><span class="line"><span class="comment"> * and &#123;<span class="doctag">@link</span> Formatter&#125; beans from the specified context.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registry the service to register beans with</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactory the bean factory to get the beans from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.2.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addBeans</span><span class="params">(FormatterRegistry registry, ListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">Set&lt;Object&gt; beans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">beans.addAll(beanFactory.getBeansOfType(GenericConverter.class).values());</span><br><span class="line">beans.addAll(beanFactory.getBeansOfType(Converter.class).values());</span><br><span class="line">beans.addAll(beanFactory.getBeansOfType(Printer.class).values());</span><br><span class="line">beans.addAll(beanFactory.getBeansOfType(Parser.class).values());</span><br><span class="line"><span class="keyword">for</span> (Object bean : beans) &#123;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> GenericConverter) &#123;</span><br><span class="line">registry.addConverter((GenericConverter) bean);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Converter) &#123;</span><br><span class="line">registry.addConverter((Converter&lt;?, ?&gt;) bean);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Formatter) &#123;</span><br><span class="line">registry.addFormatter((Formatter&lt;?&gt;) bean);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Printer) &#123;</span><br><span class="line">registry.addPrinter((Printer&lt;?&gt;) bean);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Parser) &#123;</span><br><span class="line">registry.addParser((Parser&lt;?&gt;) bean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时<code>WebMvcAutoConfigurationAdapter</code>还引入了<code>EnableWebMvcConfiguration</code>配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot.autoconfigure.web.servlet;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfiguration</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EnableWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title class_">DelegatingWebMvcConfiguration</span> <span class="keyword">implements</span> <span class="title class_">ResourceLoaderAware</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 注入 mvcConversionService，完成 RequestMappingHandlerMapping 的配置</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RequestMappingHandlerMapping <span class="title function_">requestMappingHandlerMapping</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="meta">@Qualifier(&quot;mvcContentNegotiationManager&quot;)</span> ContentNegotiationManager contentNegotiationManager,</span></span><br><span class="line"><span class="params"><span class="meta">@Qualifier(&quot;mvcConversionService&quot;)</span> FormattingConversionService conversionService,</span></span><br><span class="line"><span class="params"><span class="meta">@Qualifier(&quot;mvcResourceUrlProvider&quot;)</span> ResourceUrlProvider resourceUrlProvider)</span> &#123;</span><br><span class="line"><span class="comment">// Must be @Primary for MvcUriComponentsBuilder to work</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">super</span>.requestMappingHandlerMapping(contentNegotiationManager, conversionService,</span><br><span class="line">resourceUrlProvider);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 声明bean mvcConversionService</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> FormattingConversionService <span class="title function_">mvcConversionService</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">Format</span> <span class="variable">format</span> <span class="operator">=</span> <span class="built_in">this</span>.mvcProperties.getFormat();</span><br><span class="line"><span class="type">WebConversionService</span> <span class="variable">conversionService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebConversionService</span>(<span class="keyword">new</span> <span class="title class_">DateTimeFormatters</span>()</span><br><span class="line">.dateFormat(format.getDate()).timeFormat(format.getTime()).dateTimeFormat(format.getDateTime()));</span><br><span class="line">addFormatters(conversionService);</span><br><span class="line"><span class="keyword">return</span> conversionService;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>不难发现，MVC的数据转换服务是由名为”mvcConversionService”的ConversionService完成的，看看mvcConversionService这个bean的创建做了哪些事。</p><p>进<code>WebConversionService</code>源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot.autoconfigure.web.format;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConversionService</span> <span class="keyword">extends</span> <span class="title class_">DefaultFormattingConversionService</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">WebConversionService</span><span class="params">(DateTimeFormatters dateTimeFormatters)</span> &#123;<span class="comment">/// 构造器</span></span><br><span class="line"><span class="built_in">super</span>(<span class="literal">false</span>); <span class="comment">/// 父类构造</span></span><br><span class="line"><span class="keyword">if</span> (dateTimeFormatters.isCustomized()) &#123;</span><br><span class="line">addFormatters(dateTimeFormatters);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">addDefaultFormatters(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DefaultFormattingConversionService</code>构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.format.support;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultFormattingConversionService</span> <span class="keyword">extends</span> <span class="title class_">FormattingConversionService</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">DefaultFormattingConversionService</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">this</span>(<span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">DefaultFormattingConversionService</span><span class="params">(<span class="type">boolean</span> registerDefaultFormatters)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>(<span class="literal">null</span>, registerDefaultFormatters);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">DefaultFormattingConversionService</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="meta">@Nullable</span> StringValueResolver embeddedValueResolver, <span class="type">boolean</span> registerDefaultFormatters)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (embeddedValueResolver != <span class="literal">null</span>) &#123;</span><br><span class="line">setEmbeddedValueResolver(embeddedValueResolver);</span><br><span class="line">&#125;</span><br><span class="line">DefaultConversionService.addDefaultConverters(<span class="built_in">this</span>); <span class="comment">/// 添加默认的 Converter</span></span><br><span class="line"><span class="keyword">if</span> (registerDefaultFormatters) &#123;</span><br><span class="line">addDefaultFormatters(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结，<code>EnableWebMvcConfiguration</code>配置类提供了MVC的默认配置，并添加注册了框架默认的Converter 到mvcConversionService，利用mvcConversionService完成 <code>RequestMappingHandlerMapping</code> 的配置</p><p>如图：</p><p><img src="/Spring%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80%E8%83%BD%E5%8A%9B-%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/MVC%E6%B3%A8%E5%86%8CConverter.svg"></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Converter加入IOC可以被MVC管理，从而在参数绑定上使用其能力，但是要注意controller方法写法的区别。在Bean配置上使用Converter则需要手动注册到名为”conversionService”类型为<code>ConversionService</code>的配置bean中，IOC在bean配置时才能享受到其能力。</p><h2 id="Formatter"><a href="#Formatter" class="headerlink" title="Formatter"></a>Formatter</h2><p>数据转换中还有一个特殊的接口，<code>Formatter</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.format;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Formatter</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Printer</span>&lt;T&gt;, Parser&lt;T&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.format;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Printer</span>&lt;T&gt; &#123;</span><br><span class="line">String <span class="title function_">print</span><span class="params">(T object, Locale locale)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.format;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Parser</span>&lt;T&gt; &#123;</span><br><span class="line">T <span class="title function_">parse</span><span class="params">(String text, Locale locale)</span> <span class="keyword">throws</span> ParseException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容易想到格式化器是java对象和String之间的转换功能在不同地区语言上的加强，所以它是在MVC控制层使用的，根据不同地区信息进行数据转换。</p><h3 id="Formatter数据转换"><a href="#Formatter数据转换" class="headerlink" title="Formatter数据转换"></a>Formatter数据转换</h3><p>定义实体类User</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义格式化器，加入IOC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 实现 id-name-email 到 User的互转，此处为了演示忽略 locale */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserFormatter</span> <span class="keyword">implements</span> <span class="title class_">Formatter</span>&lt;User&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** like: &quot;id-name-email&quot; */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Pattern</span> <span class="variable">USER_STRING_PATTERN</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;[0-9]&#123;1,&#125;-[a-zA-Z\\u4e00-\\u9fa5]&#123;1,&#125;-\\S*&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">parse</span><span class="params">(String text, Locale locale)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;parse: &#123;&#125;&quot;</span>, text);</span><br><span class="line">        <span class="keyword">if</span> (!USER_STRING_PATTERN.matcher(text).matches()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ParseException</span>(<span class="string">&quot;The value [&quot;</span> + text + <span class="string">&quot;] is not matcher format &lt;id-name-email&gt;&quot;</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String[] fields = text.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(Long.valueOf(fields[<span class="number">0</span>]),fields[<span class="number">1</span>],fields[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">print</span><span class="params">(User user, Locale locale)</span> &#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;print: &#123;&#125;&quot;</span>, user);</span><br><span class="line">        <span class="keyword">return</span> user.getId() + <span class="string">&quot;-&quot;</span> + user.getName() + <span class="string">&quot;-&quot;</span> + user.getEmail();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/formatter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FormatterController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------------</span></span><br><span class="line">    <span class="comment">// Formatter 的转换器效果</span></span><br><span class="line">     <span class="comment">//-------------------------------</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get参数(String类型)直接解析为&#123;<span class="doctag">@link</span> User&#125;，指定参数名</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;/formatter/user-request-query-assign?user=100-tom-123qq.com</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;但无法进行&#123;<span class="doctag">@link</span> Validated&#125;校验</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ws.spring.convert.formatter.UserFormatter#parse(String, Locale)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user-request-query-assign&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">formatUserWhenQueryParamAssign</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@RequestParam(&quot;user&quot;)</span> User user)</span> &#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;user: &#123;&#125;&quot;</span>,user);</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get参数(String类型)直接解析为&#123;<span class="doctag">@link</span> User&#125;，不指定参数名</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;/formatter/user-request-query-non-assign?user=100-tom-123qq.com</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;可以进行&#123;<span class="doctag">@link</span> Validated&#125;校验</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ws.spring.convert.formatter.UserFormatter#parse(String, Locale)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user-request-query-non-assign&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">formatUserWhenQueryParamNonAssign</span><span class="params">(<span class="meta">@Validated</span> User user)</span> &#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;user: &#123;&#125;&quot;</span>,user);</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Formatter-view视图格式化"><a href="#Formatter-view视图格式化" class="headerlink" title="Formatter view视图格式化"></a>Formatter view视图格式化</h3><p>在MVC后端视图渲染时，我们可以通过格式化来指定数据在视图中的呈现内容，比如有一个pojo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberWrapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NumberSeparate</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="meta">@NumberSeparate(&#x27;=&#x27;)</span></span><br><span class="line">    <span class="meta">@Max(100)</span></span><br><span class="line">    <span class="keyword">private</span> Long number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们希望，视图中使用NumberWrapper的code属性时，将code数值进行单个拆分，如”123” -&gt; “1-2-3”，将number也进行拆分，并指定分隔符为”&#x3D;”，如如”123” -&gt; “1&#x3D;2&#x3D;3”，分隔符通过<code>NumberSeparate</code>注解指定。</p><p>在controller中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/formatter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FormatterController</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在jsp视图中格式化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> model</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/number-print&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">numberWrapperPrint</span><span class="params">(Model model)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">NumberWrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumberWrapper</span>(<span class="number">123</span>,<span class="number">456L</span>);</span><br><span class="line">        log.info(<span class="string">&quot;wrapper: &#123;&#125;&quot;</span>,wrapper);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;wrapper&quot;</span>,wrapper);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;show&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>show.jsp内容</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;form&quot;</span> uri=<span class="string">&quot;http://www.springframework.org/tags/form&quot;</span> %&gt;</span><br><span class="line">&lt;%@ taglib uri=<span class="string">&quot;http://www.springframework.org/tags&quot;</span> prefix=<span class="string">&quot;spring&quot;</span> %&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;from&quot;</span> uri=<span class="string">&quot;http://www.springframework.org/tags/form&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;welcome&lt;/title&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form:form modelAttribute=<span class="string">&quot;wrapper&quot;</span>&gt;</span><br><span class="line">    &lt;%--  <span class="number">1</span>-<span class="number">2</span>-<span class="number">3</span>  --%&gt;</span><br><span class="line">    &lt;h6&gt;&lt;from:input path=<span class="string">&quot;code&quot;</span>/&gt;&lt;/h6&gt;</span><br><span class="line">    &lt;%--  <span class="number">4</span>=<span class="number">5</span>=<span class="number">6</span>  --%&gt;</span><br><span class="line">    &lt;h6&gt;&lt;from:input path=<span class="string">&quot;number&quot;</span>/&gt;&lt;/h6&gt;</span><br><span class="line">&lt;/form:form&gt;</span><br><span class="line">&lt;H1&gt;JSP&lt;/H1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>效果</p><p><img src="/Spring%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80%E8%83%BD%E5%8A%9B-%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/show.jsp.png"></p><p><strong>代码实现</strong></p><p>定义注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NumberSeparate &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">    <span class="type">char</span> <span class="title function_">separator</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(&quot;separator&quot;)</span></span><br><span class="line">    <span class="type">char</span> <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现一个注解格式化工厂<code>AnnotationFormatterFactory</code>，且加入IOC容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberSeparateAnnotationFormatterFactory</span> <span class="keyword">implements</span> <span class="title class_">AnnotationFormatterFactory</span>&lt;NumberSeparate&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 支持的类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getFieldTypes() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Arrays.asList(Integer.class,Long.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Printer&lt;?&gt; getPrinter(NumberSeparate annotation, Class&lt;?&gt; fieldType) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> <span class="variable">separator</span> <span class="operator">=</span> annotation.separator();</span><br><span class="line">        <span class="keyword">return</span> getFormatter(separator,fieldType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Parser&lt;?&gt; getParser(NumberSeparate annotation, Class&lt;?&gt; fieldType) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> <span class="variable">separator</span> <span class="operator">=</span> annotation.separator();</span><br><span class="line">        <span class="keyword">return</span> getFormatter(separator,fieldType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Formatter&lt;?&gt; getFormatter(<span class="type">char</span> separator, Class&lt;?&gt; clazz) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Integer.class.equals(clazz)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NumberSeparateFormatter</span>&lt;&gt;(separator, Integer::valueOf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Long.class.equals(clazz)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NumberSeparateFormatter</span>&lt;&gt;(separator, Long::valueOf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;不支持的类型&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 实现格式化器完成 &quot;123&quot; -&gt; “1-2-3” 的互转，继承Formatter以便同时实现  Printer 和 Parser */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NumberSeparateFormatter</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="keyword">implements</span> <span class="title class_">Formatter</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> separator;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Function&lt;String,T&gt; converter;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">NumberSeparateFormatter</span><span class="params">(<span class="type">char</span> separator, Function&lt;String,T&gt; converter)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.separator = separator;</span><br><span class="line">            <span class="built_in">this</span>.converter = converter;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">print</span><span class="params">(T object, Locale locale)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">char</span>[] chars = object.toString().toCharArray();</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> aChar : chars) &#123;</span><br><span class="line">                sb.append(aChar).append(separator);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sb.substring(<span class="number">0</span>,sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">parse</span><span class="params">(String text, Locale locale)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">replace</span> <span class="operator">=</span> text.replace(String.valueOf(separator), <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> converter.apply(replace);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ParseException</span>(<span class="string">&quot;格式错误&quot;</span>,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以在view视图上使用Formatter 的格式化能力</p><p>同时在参数绑定上也可以完成字符串到java对象转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/formatter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FormatterController</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在参数绑定时解析参数到注解上的属性</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; /formatter/number-parse?code=1-2-3&amp;number=4=5=6 即 /formatter/number-parse?code=1-2-3&amp;number=4%3D5%3D6</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; 但是不经过参数校验，&#123;<span class="doctag">@link</span> NumberWrapper#number&#125;上的注解不会得到校验</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> wrapper wrapper</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/number-parse&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">numberWrapperParse</span><span class="params">(NumberWrapper wrapper)</span> &#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;wrapper: &#123;&#125;&quot;</span>,wrapper);</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(wrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>疑点</strong>：为什么Formatter在MVC参数绑定上拥有和Converter一样的效果？</p><p>还记得MVC的自动装配中，名为”mvcConversionService”类型为 <code>WebConversionService</code> 的bean吗，其继承关系如图，看的出其继承<code>FormattingConversionService</code>实现了ConversionService 接口</p><p><img src="/Spring%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80%E8%83%BD%E5%8A%9B-%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/WebConversionService.png"></p><p>而<code>FormattingConversionService</code>在注册Formatterr时，通过内部类<code>PrinterConverter</code>和<code>ParserConverter</code>进行封装，实际注册的是它俩，所以MVC才拥有了数据转换的能力，故表面上看Formatter拥有和Converter一样的效果，源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.format.support;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FormattingConversionService</span> <span class="keyword">extends</span> <span class="title class_">GenericConversionService</span> <span class="keyword">implements</span> <span class="title class_">FormatterRegistry</span>, EmbeddedValueResolverAware &#123;</span><br><span class="line">    <span class="comment">/** 添加 Printer */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addPrinter</span><span class="params">(Printer&lt;?&gt; printer)</span> &#123;</span><br><span class="line">Class&lt;?&gt; fieldType = getFieldType(printer, Printer.class);</span><br><span class="line">addConverter(<span class="keyword">new</span> <span class="title class_">PrinterConverter</span>(fieldType, printer, <span class="built_in">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 添加 Parser */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addParser</span><span class="params">(Parser&lt;?&gt; parser)</span> &#123;</span><br><span class="line">Class&lt;?&gt; fieldType = getFieldType(parser, Parser.class);</span><br><span class="line">addConverter(<span class="keyword">new</span> <span class="title class_">ParserConverter</span>(fieldType, parser, <span class="built_in">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 添加 Formatter */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFormatter</span><span class="params">(Formatter&lt;?&gt; formatter)</span> &#123;</span><br><span class="line">addFormatterForFieldType(getFieldType(formatter), formatter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFormatterForFieldType</span><span class="params">(Class&lt;?&gt; fieldType, Formatter&lt;?&gt; formatter)</span> &#123;</span><br><span class="line">addConverter(<span class="keyword">new</span> <span class="title class_">PrinterConverter</span>(fieldType, formatter, <span class="built_in">this</span>));</span><br><span class="line">addConverter(<span class="keyword">new</span> <span class="title class_">ParserConverter</span>(fieldType, formatter, <span class="built_in">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFormatterForFieldType</span><span class="params">(Class&lt;?&gt; fieldType, Printer&lt;?&gt; printer, Parser&lt;?&gt; parser)</span> &#123;</span><br><span class="line">addConverter(<span class="keyword">new</span> <span class="title class_">PrinterConverter</span>(fieldType, printer, <span class="built_in">this</span>));</span><br><span class="line">addConverter(<span class="keyword">new</span> <span class="title class_">ParserConverter</span>(fieldType, parser, <span class="built_in">this</span>));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 封装 Printer 实现 GenericConverter */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PrinterConverter</span> <span class="keyword">implements</span> <span class="title class_">GenericConverter</span> &#123;</span><br><span class="line">         <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; fieldType;</span><br><span class="line">         <span class="keyword">private</span> <span class="keyword">final</span> TypeDescriptor printerObjectType;</span><br><span class="line">         <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">         <span class="keyword">private</span> <span class="keyword">final</span> Printer printer;</span><br><span class="line">         <span class="keyword">private</span> <span class="keyword">final</span> ConversionService conversionService;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">     &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/** 封装 Parser 实现 GenericConverter */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ParserConverter</span> <span class="keyword">implements</span> <span class="title class_">GenericConverter</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; fieldType;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Parser&lt;?&gt; parser;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConversionService conversionService;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>Formatter用于数据对不同地区的语言信息进行格式化，如MVC视图的数据呈现格式化，同时因为FormattingConversionService内部对Formatter进行了增强，所以Formatter有了数据转换的能力，而且可以根据语言信息进行不同的转换。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Spring" scheme="https://blog.windshadow.cn/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot常用注解</title>
    <link href="https://blog.windshadow.cn/SpringBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
    <id>https://blog.windshadow.cn/SpringBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</id>
    <published>2021-02-28T11:06:07.934Z</published>
    <updated>2024-08-12T17:19:44.437Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>话不多说，过一下配置文件</p><h2 id="yml配置文件主要写法"><a href="#yml配置文件主要写法" class="headerlink" title="yml配置文件主要写法"></a>yml配置文件主要写法</h2><p>参数写法</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mystarter.config:</span></span><br><span class="line">  <span class="comment"># 布尔类型</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 数字或基本类型</span></span><br><span class="line"><span class="comment">#  size: $&#123;random.int&#125; 随机数</span></span><br><span class="line">  <span class="attr">size:</span> <span class="number">18</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 字符串</span></span><br><span class="line"><span class="comment">#  address: &quot;beijing \n aaa&quot; 加双引号不会转义</span></span><br><span class="line"><span class="comment">#  address: &#x27;beijing \n aaa&#x27; 加单引号会转义</span></span><br><span class="line">  <span class="attr">address:</span> <span class="string">beijing</span></span><br><span class="line">  <span class="comment"># 时间date</span></span><br><span class="line">  <span class="attr">date:</span> <span class="number">2021</span><span class="string">/01/01</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 自定义bean map</span></span><br><span class="line"><span class="comment">#  user: &#123;username: root, password: 123456&#125; 行内写法</span></span><br><span class="line">  <span class="attr">user:</span></span><br><span class="line"><span class="comment">#    username: $&#123;mystarter.config.address&#125;  引用其它配置，不存在则为 &quot;$&#123;mystarter.config.address&#125;&quot;字符串</span></span><br><span class="line"><span class="comment">#    username: $&#123;mystarter.config.address: testuser&#125;  引用其它配置，不存在则使用缺省值</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">  <span class="attr">map:</span></span><br><span class="line">    <span class="attr">ip:</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">loginName:</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 数组 list set</span></span><br><span class="line"><span class="comment">#    array: [aaa,bbb,ccc] 行内写法</span></span><br><span class="line">  <span class="attr">array:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">aaa</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">bbb</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ccc</span></span><br><span class="line">  <span class="attr">list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ddd</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">eee</span></span><br><span class="line">  <span class="attr">set:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">fff</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ggg</span></span><br></pre></td></tr></table></figure><p>激活配置文件或配置块</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">demo-test</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line"><span class="comment"># 配置文件激活</span></span><br><span class="line"><span class="comment"># 1、创建配置文件时名称为 application-&#123;name&#125;.yml 可使用 spring.profiles.active=&#123;name&#125;去激活，找不到则使用默认主配置</span></span><br><span class="line"><span class="comment">#   激活后配置内容 = 配置文件交集 + 激活文件非交集部分</span></span><br><span class="line"><span class="comment"># 2、也可激活块部分，yml文档块 spring.profiles.active=dev1</span></span><br><span class="line"><span class="comment"># 3、使用命令行激活 --spring.profiles.active=dev1</span></span><br><span class="line"><span class="comment"># 4、使用jvm参数 -Dspring.profiles.active=dev1</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev1</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="string">---</span> <span class="comment"># 新的块</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev1</span></span><br><span class="line"><span class="string">---</span> <span class="comment"># 新的块</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev2</span></span><br><span class="line"><span class="comment">#  spring boot启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件</span></span><br><span class="line"><span class="comment">#  file:./config/</span></span><br><span class="line"><span class="comment">#  file:./</span></span><br><span class="line"><span class="comment">#  classpath:/config(- classpath:/</span></span><br><span class="line"><span class="comment">#  以上是按照优先级从高到低的顺序，所有位置的文件都会被加载，高优先级配置内容会覆盖低优先级配置内容。</span></span><br><span class="line"><span class="comment">#  我们也可以通过配置spring.config.location来改变默认配置</span></span><br></pre></td></tr></table></figure><p>另外，properties文件，特殊#—注释用于标记文档拆分</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span>=<span class="string">MyApp</span></span><br><span class="line"><span class="comment">#---</span></span><br><span class="line"><span class="attr">spring.config.activate.on-cloud-platform</span>=<span class="string">kubernetes</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">MyCloudApp</span></span><br></pre></td></tr></table></figure><h2 id="外部配置加载顺序"><a href="#外部配置加载顺序" class="headerlink" title="外部配置加载顺序"></a>外部配置加载顺序</h2><p>SpringBoot也可以从以下位置加载配置﹔优先级从高到低﹔高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置，以下列举实用的外部配置，<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config">官网文档</a></p><ol><li><p>命令行参数，多个参数用空格分开</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar spring-boot-xxx-0.0.1-SNAPSHOT.jar --server.port=9090</span><br></pre></td></tr></table></figure></li><li><p>来自java:comp&#x2F;env的JNDI属性</p></li><li><p>Java系统属性( System.getProperties() )</p></li><li><p>操作系统环境变量</p></li><li><p>RandomValuePropertySource配置的random.*属性值</p></li><li><p>jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件</p></li><li><p>jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件</p></li><li><p>jar包外部的application.properties或application.yml(不带spring.profile)配置文件</p></li><li><p>jar包内部的application.properties或application.yml(不带spring.profile)配置文件</p></li><li><p>@Configuration注解类上的@PropertySource</p></li><li><p>通过SpringApplication.setDefaultProperties指定的默认属性</p></li></ol><p>优先级从 1 &gt; 2 &gt; … &gt; 11，jar包外 &gt; jar包内，带{profile} &gt; 不带{profile} ；</p><h2 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h2><p>从配置文件给bean配置属性</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>搭配组件型注解，如<code>@Component</code>，指定前缀，以属性名进行赋值，依赖于空构造函数；</p><ol><li><p>ignoreInvalidFields</p><p>当配置文件中的值无法映射给bean的属性。如字符串给数字赋值等，SpringBoot应用会抛异常而起动失败，而ignoreInvalidFields属性设置为true（默认为false）时可以使应用不会停止，即使用属性默认的值。</p></li><li><p>ignoreUnknownFields</p><p>忽略位置属性；当配置文件中出现了类中没有定义的属性时，即出现了未知的属性，SpringBoot默认时忽略它的（ignoreUnknownFields默认为true），ignoreUnknownFields设为false时，表示要对未知属性“斤斤计较”，结果自然是启动失败。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;ordinary.bind&quot;, ignoreInvalidFields = true, ignoreUnknownFields = false)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrdinaryPropertiesBindExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Boolean</span> <span class="variable">enable</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-Spring-Boot-Configuration-Processor自动补全"><a href="#使用-Spring-Boot-Configuration-Processor自动补全" class="headerlink" title="使用 Spring Boot Configuration Processor自动补全"></a>使用 Spring Boot Configuration Processor自动补全</h3><p>pom.xml中加入Spring Boot Configuration Processor的依赖，并重新build之后，IDEA中编写配置文件时就可以自动补全了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/SpringBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8.png" alt="自动补全"></p><h4 id="标记配置属性为-Deprecated"><a href="#标记配置属性为-Deprecated" class="headerlink" title="标记配置属性为 Deprecated"></a>标记配置属性为 Deprecated</h4><p>使用<code>@DeprecatedConfigurationProperty</code>注解作用与属性的get方法上，表示该属性已经过时，重新build之后，属性对应的自动补全提示也会发生改变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;ordinary.bind&quot;, ignoreInvalidFields = true, ignoreUnknownFields = false)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrdinaryPropertiesBindExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Boolean</span> <span class="variable">enable</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeprecatedConfigurationProperty(reason = &quot;我已经过时&quot;, replacement = &quot;none&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">getEnable</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.enable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/SpringBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8-%E8%BF%87%E6%97%B6.png" alt="自动补全-过时"></p><h3 id="搭配-ConstructorBinding"><a href="#搭配-ConstructorBinding" class="headerlink" title="搭配@ConstructorBinding"></a>搭配@ConstructorBinding</h3><p><code>@ConstructorBinding</code>注解，顾名思义，构造绑定，通过构造方法，从配置文件获取值给bean设置属性。使用此方式时，需要通过<code>@EnableConfigurationProperties</code>注解修饰的配置类来扫描该类加入IOC，不能对通过常规Spring机制创建的bean使用构造函数绑定，即不能添加组件型注解（如<code>@Component</code>）这样的注解加入IOC，原因也很简单，这里不作解释。</p><p>搭配<code>@ConstructorBinding</code>的配置方式，一般在给类内为 final的属性初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConstructorBinding</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;constructor.bind&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstructorPropertiesBindExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;<span class="comment">// 一般用于运行时不可变的配置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConstructorPropertiesBindExample</span><span class="params">(String name)</span> &#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;构造方法被调用&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(ConstructorPropertiesBindExample.class)</span><span class="comment">// 激活</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstructorPropertiesBindExampleActive</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="搭配-Bean"><a href="#搭配-Bean" class="headerlink" title="搭配@Bean"></a>搭配<code>@Bean</code></h3><p>搭配<code>@Bean</code>注解时，不依赖该bean的无参构造，仅在bean实例化后进行属性设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConfigurationProperties(&quot;atbean.bind&quot;)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ExampleBean <span class="title function_">exampleBean</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExampleBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 定义一个pojo</span></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ExampleBean</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String examName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ConfigurationPropertiesBinding与自定义转换器"><a href="#ConfigurationPropertiesBinding与自定义转换器" class="headerlink" title="@ConfigurationPropertiesBinding与自定义转换器"></a>@ConfigurationPropertiesBinding与自定义转换器</h2><p>实现<code>org.springframework.core.convert.converter.Converter</code>接口实现自定义转换器，使用<code>@ConfigurationPropertiesBinding</code>声名为Spring可用的转换器</p><p>设置性别类。不设置枚举是因为Spring默认支持枚举的字符串配置了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sex</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Sex</span> <span class="variable">MAN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sex</span>(<span class="string">&quot;man&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Sex</span> <span class="variable">WOMAN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sex</span>(<span class="string">&quot;woman&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Sex</span><span class="params">(String value)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现性别类的转换器，接收不符合规则的String抛出<code>IllegalArgumentException</code>异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationPropertiesBinding</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SexConverter</span> <span class="keyword">implements</span> <span class="title class_">Converter</span>&lt;String,Sex&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String,Sex&gt; SEX_VALUE_SET =</span><br><span class="line">            Arrays.stream(<span class="keyword">new</span> <span class="title class_">Sex</span>[]&#123;Sex.MAN,Sex.WOMAN&#125;).collect(Collectors.toMap(Sex::getValue,sex -&gt; sex));</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Sex <span class="title function_">convert</span><span class="params">(String source)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (SEX_VALUE_SET.containsKey(source)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> SEX_VALUE_SET.get(source);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;The sex string value must in &quot;</span> + SEX_VALUE_SET.keySet().toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立一个pojo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;sexbean&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleSexBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Sex sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>yml文件如下配置即可达到目的，配置的值不是 man或woman则抛出异常</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义转换器</span></span><br><span class="line"><span class="attr">sexbean:</span></span><br><span class="line">  <span class="attr">sex:</span> <span class="string">man</span></span><br></pre></td></tr></table></figure><p>一般来说像上面这种情况使用枚举即可，这里为了举例不使用枚举。</p><h2 id="条件注入"><a href="#条件注入" class="headerlink" title="条件注入"></a>条件注入</h2><p>仅列举常用的条件注入（有必要的话，可以取去了解<code>SpringBootCondition</code>）</p><h3 id="ConditionalOnProperty"><a href="#ConditionalOnProperty" class="headerlink" title="@ConditionalOnProperty"></a>@ConditionalOnProperty</h3><p>根据【配置文件是否存在对应的键值对】作为注入条件</p><p>以下配置可理解为：配置文件存在 “ex.config.flag&#x3D;true”时注入bean，若不存在该key值则默认为false（不注入）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;ex.config&quot;, name = &quot;flag&quot;, havingValue = &quot;1&quot;, matchIfMissing = false)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConditionalOnBean"><a href="#ConditionalOnBean" class="headerlink" title="@ConditionalOnBean"></a>@ConditionalOnBean</h3><p>根据【容器内是否存在符合条件的bean】作为注入条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConditionalOnBean &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要作为条件的类的Class对象数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要作为条件的类的Name,Class.getName()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] type() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  (用指定注解修饰的bean)条件所需的注解类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;[] annotation() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * spring容器中bean的名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] name() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 搜索容器层级,当前容器，父容器，全部</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SearchStrategy <span class="title function_">search</span><span class="params">()</span> <span class="keyword">default</span> SearchStrategy.ALL;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可能在其泛型参数中包含指定bean类型的其他类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt;[] parameterizedContainer() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnBean(value = SpringbootAnnotationApplication.class)</span></span><br><span class="line"><span class="comment">//@ConditionalOnBean(name = &quot;springbootAnnotationApplication&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleConditionalOnBean</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConditionalOnClass"><a href="#ConditionalOnClass" class="headerlink" title="@ConditionalOnClass"></a>@ConditionalOnClass</h3><p>根据【工程中引入是否存在该class】作为注入条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass(SpringbootAnnotationApplication.class)</span></span><br><span class="line"><span class="comment">//@ConditionalOnClass(name = &quot;ws.springboot.springbootannotation.SpringbootAnnotationApplication&quot;) // 类全限定名</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleConditionalOnClass</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConditionalOnJava"><a href="#ConditionalOnJava" class="headerlink" title="@ConditionalOnJava"></a>@ConditionalOnJava</h3><p>根据【当前使用的java版本与配置的版本对比结果】作为注入条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnJava(</span></span><br><span class="line"><span class="meta">        value = JavaVersion.EIGHT, // java 1.8</span></span><br><span class="line"><span class="meta">        range = ConditionalOnJava.Range.EQUAL_OR_NEWER)</span><span class="comment">// 大于或等于 ConditionalOnJava.Range.OLDER_THAN 为小于</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleConditionalOnJava</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConditionalOnExpression"><a href="#ConditionalOnExpression" class="headerlink" title="@ConditionalOnExpression"></a>@ConditionalOnExpression</h3><p>根据【spel表达式结果】作为注入条件，注解内值不符合表达式规则则抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnExpression(&quot;1 + 1 == 2&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleConditionalOnExpression</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConditionalOnMissingBean"><a href="#ConditionalOnMissingBean" class="headerlink" title="@ConditionalOnMissingBean"></a>@ConditionalOnMissingBean</h3><p>根据【容器内是否不存在符合条件的bean】作为注入条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Conditional(OnBeanCondition.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConditionalOnMissingBean &#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要检查的 bean 的 class 类型。当 ApplicationContext 不包含每一个被指定的 class 时条件匹配。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;;    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要检查的 bean 的 class 类型名称(Java全限定名)。当 ApplicationContext 不包含每一个被指定的 class 时条件匹配。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] type() <span class="keyword">default</span> &#123;&#125;;    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 识别匹配 bean 时，可以被忽略的 bean 的 class 类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt;[] ignored() <span class="keyword">default</span> &#123;&#125;;    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 识别匹配 bean 时，可以被忽略的 bean 的 class 类型名称(Java全限定名)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] ignoredType() <span class="keyword">default</span> &#123;&#125;;    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 装饰需要检查的 bean 的注解。当 ApplicationContext 不包含带有这些注解的 bean 时条件匹配。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;[] annotation() <span class="keyword">default</span> &#123;&#125;;    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要检查的 bean 的 name。当 ApplicationContext 不包含任意指定的每一个的 class 时条件匹配。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] name() <span class="keyword">default</span> &#123;&#125;;    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 搜索容器层级,当前容器，父容器，全部</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SearchStrategy <span class="title function_">search</span><span class="params">()</span> <span class="keyword">default</span> SearchStrategy.ALL;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnMissingBean(name = &quot;springbootAnnotationApplication999&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleConditionalOnMissingBean</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConditionalOnMissingClass"><a href="#ConditionalOnMissingClass" class="headerlink" title="@ConditionalOnMissingClass"></a>@ConditionalOnMissingClass</h3><p>根据【容器内是否不存在该class的bean】作为注入条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnMissingClass(&quot;ws.springboot.springbootannotation.SpringbootAnnotationApplication999&quot;)</span> <span class="comment">// 类全限定名</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleConditionalOnMissingClass</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConditionalOnMissingFilterBean"><a href="#ConditionalOnMissingFilterBean" class="headerlink" title="@ConditionalOnMissingFilterBean"></a>@ConditionalOnMissingFilterBean</h3><p>根据【容器内是否不存在该过滤器】作为注入条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnMissingFilterBean(CorsFilter.class)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleConditionalOnMissingFilterBean</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConditionalOnCloudPlatform"><a href="#ConditionalOnCloudPlatform" class="headerlink" title="@ConditionalOnCloudPlatform"></a>@ConditionalOnCloudPlatform</h3><p>根据【应用所处云平台】作为注入条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleConditionalOnCloudPlatform</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">CloudPlatform</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无（无平台，返回false，bean不会被注入）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">NONE,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 云计算平台</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CLOUD_FOUNDRY,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Heroku平台</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">HEROKU,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SAP 云平台.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SAP,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * K8S.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">KUBERNETES </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConditionalOnWebApplication"><a href="#ConditionalOnWebApplication" class="headerlink" title="@ConditionalOnWebApplication"></a>@ConditionalOnWebApplication</h3><p>根据【应用是否所处于web环境】作为注入条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.ANY)</span> <span class="comment">// 任何web环境</span></span><br><span class="line"><span class="comment">//@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET) // 基于servlet的web应用</span></span><br><span class="line"><span class="comment">//@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.REACTIVE) // 基于响应式的web应用（猜测可能是webflux）</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleConditionalOnWebApplication</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ConditionalOnNotWebApplication"><a href="#ConditionalOnNotWebApplication" class="headerlink" title="@ConditionalOnNotWebApplication"></a>@ConditionalOnNotWebApplication</h3><p>根据【应用是否所不处于web环境】作为注入条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnNotWebApplication</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleConditionalOnNotWebApplication</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConditionalOnResource"><a href="#ConditionalOnResource" class="headerlink" title="@ConditionalOnResource"></a>@ConditionalOnResource</h3><p>根据【资源是否存在】作为注入条件，如日志的相关配置等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnResource(resources = &quot;classpath:application.yml&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleConditionalOnResource</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConditionalOnSingleCandidate"><a href="#ConditionalOnSingleCandidate" class="headerlink" title="@ConditionalOnSingleCandidate"></a>@ConditionalOnSingleCandidate</h3><p>根据【容器内是否存在该class的bean，且只有一个实例或为首选的】作为注入条件，即容器中存在该class的bean的实例，且只有一个时注入条件为true，当存在多个实例时，有一个实例为首选的（如加上了<code>@Primary</code>注解），注入条件也为true，即在其它bean中注入该class的bean时，如使用<code>@Autowired</code>且不指定bean名称时，不会发生依赖注入失败，这个时候，以这个calss为value的<code>@ConditionalOnResource</code>注解条件匹配结果就是true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnSingleCandidate(value = I.class)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleConditionalOnSingleCandidate</span> &#123; <span class="comment">// 不可注入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">I</span>&#123;&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">I</span>&#123;&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">I</span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnSingleCandidate(value = I.class)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleConditionalOnSingleCandidate</span> &#123; <span class="comment">// 可注入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">I</span>&#123;&#125;</span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">I</span>&#123;&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">I</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="条件注入的组合"><a href="#条件注入的组合" class="headerlink" title="条件注入的组合"></a>条件注入的组合</h2><h3 id="组合条件-AND"><a href="#组合条件-AND" class="headerlink" title="组合条件 AND"></a>组合条件 AND</h3><ol><li><p>在类上使用多个@ConditionalOnXxxx</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass(name = &quot;ws.springboot.springbootannotation.SpringbootAnnotationApplication&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnJava(value = JavaVersion.EIGHT, range = ConditionalOnJava.Range.EQUAL_OR_NEWER)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleConditionalAnd1</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义注解上使用其它条件注入注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(name = &quot;ws.springboot.springbootannotation.SpringbootAnnotationApplication&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnJava(value = JavaVersion.EIGHT, range = ConditionalOnJava.Range.EQUAL_OR_NEWER)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyConditionalAndAnno &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用到要进行条件注入的组件上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyConditionalAndAnno</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleConditionalAnd3</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>继承<code>AllNestedConditions</code>类封装条件，使用静态内部类标注条件，所有条件将进行【逻辑与】操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * and条件注入</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> WindShadow</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/2/3</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConditionalAnd</span> <span class="keyword">extends</span> <span class="title class_">AllNestedConditions</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyConditionalAnd</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(ConfigurationPhase.PARSE_CONFIGURATION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConditionalOnClass(name = &quot;ws.springboot.springbootannotation.SpringbootAnnotationApplication&quot;)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OnClass</span>&#123;&#125;</span><br><span class="line">    <span class="meta">@ConditionalOnJava(value = JavaVersion.EIGHT, range = ConditionalOnJava.Range.EQUAL_OR_NEWER)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OnJava</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Conditional(MyConditionalAnd.class)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleConditionalAnd2</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>ConfigurationPhase</code>枚举的两个值意义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">ConfigurationPhase</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 配置类解析阶段，如果条件为false，配置类将不会被解析</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        PARSE_CONFIGURATION,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * bean注册阶段，如果为false，bean将不会被注册</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">REGISTER_BEAN</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="组合条件-OR"><a href="#组合条件-OR" class="headerlink" title="组合条件 OR"></a>组合条件 OR</h3><p>   继承<code>AnyNestedCondition</code>类封装条件，使用静态内部类标注条件，所有条件将进行【逻辑或】操作</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConditionalOr</span> <span class="keyword">extends</span> <span class="title class_">AnyNestedCondition</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyConditionalOr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(ConfigurationPhase.PARSE_CONFIGURATION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConditionalOnClass(name = &quot;ws.springboot.springbootannotation.SpringbootAnnotationApplication&quot;)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OnClass</span>&#123;&#125;</span><br><span class="line">    <span class="meta">@ConditionalOnJava(value = JavaVersion.NINE, range = ConditionalOnJava.Range.EQUAL_OR_NEWER)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OnJava</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Conditional(MyConditionalOr.class)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleConditionalOr</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合条件-NOT"><a href="#组合条件-NOT" class="headerlink" title="组合条件 NOT"></a>组合条件 NOT</h3><p>   继承<code>NoneNestedConditions</code>类封装条件，使用静态内部类标注条件，所有条件将进行【逻辑非】操作</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConditionalNot</span> <span class="keyword">extends</span> <span class="title class_">NoneNestedConditions</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyConditionalNot</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(ConfigurationPhase.PARSE_CONFIGURATION);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@ConditionalOnClass(name = &quot;ws.springboot.springbootannotation.SpringbootAnnotationApplication999&quot;)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OnClass</span>&#123;&#125;</span><br><span class="line">    <span class="meta">@ConditionalOnJava(value = JavaVersion.NINE, range = ConditionalOnJava.Range.EQUAL_OR_NEWER)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OnJava</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Conditional(MyConditionalNot.class)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleConditionalNot</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Servlet组件的扫描"><a href="#Servlet组件的扫描" class="headerlink" title="Servlet组件的扫描"></a>Servlet组件的扫描</h2><h3 id="ServletComponentScan"><a href="#ServletComponentScan" class="headerlink" title="ServletComponentScan"></a>ServletComponentScan</h3><p>在<code>@SpringBootApplication</code>上使用<code>@ServletComponentScan</code>注解后，Servlet、Filter、Listener可以直接通过<code>@WebServlet</code>、<code>@WebFilter</code>、<code>@WebListener</code>注解自动注册，无需其他代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServletComponentScan</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="SpringBoot" scheme="https://blog.windshadow.cn/categories/SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>Nginx原理初探</title>
    <link href="https://blog.windshadow.cn/Nginx%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2/"/>
    <id>https://blog.windshadow.cn/Nginx%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2/</id>
    <published>2021-02-28T11:06:07.931Z</published>
    <updated>2021-06-22T13:25:02.574Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Nginx-多进程架构"><a href="#Nginx-多进程架构" class="headerlink" title="Nginx 多进程架构"></a>Nginx 多进程架构</h2><p>Nginx 多进程架构：<strong>一个master进程和多个worker进程</strong>；</p><ul><li>master进程：主要负责有轻而巧的工作，通过进程间通信对worker 进程发号施令或是处理来自bash的start,stop,reload等用户指令</li><li>worker进程：主要负责重而笨的工作，处理来自客户端的连接等，多个worker共享一个监听套接字；</li><li>worker进程由master进程fork而来</li><li>客户端请求处理机制：请求争抢；客户端请求到达nginx时，多个worker进程进行请求争抢</li></ul><p>在Linux下，Nginx 使用 epoll 的 I&#x2F;O 多路复用模型（常见的&#x2F;O 多路复用模型包括： select 模型、 poll模型、 epoll 模型）</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">   <span class="comment"># 默认使用epoll </span></span><br><span class="line">   <span class="attribute">use</span> <span class="literal">epoll</span>;</span><br><span class="line">   <span class="comment"># 每个worker允许连接的最大数</span></span><br><span class="line">   <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>拓展：</em></p><p><em>在TCP Socket 服务开发中，多进程或多线程共享监听套接字时会面临“惊群问题”（有兴趣了解一下）；</em></p><p><em>对于主流的linux版本, accept 阻塞调用,已经不存在惊群问题，也就是说多个进程同时accept 同一个 监听套接字,只有一个进程获的连接；</em></p><p><em>Nginx 在linux系统中使用epoll_wait 非阻塞式的方式，对于epoll_wait 非阻塞式的创建连接方式，依旧存在惊群问题。</em></p><p>多进程架构好处：</p><ul><li><p>热部署，可以使用nginx -s reload热部署</p></li><li><p>每个woker是独立的进程，如果有其中的一个woker出现问题，其他woker独立的继续进行争抢,实现请求过程,不会造成服务中断</p></li><li><p>首先，对于每个worker进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方便很多。其次，采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master进程则很快启动新的worker进程。当然，worker进程的异常退出，肯定是程序有bug了，异常退出，会导致当前worker上的所有请求失败，不过不会影响到所有请求，所以降低了风险。</p></li><li><p>Nginx同redis，类似都<strong>采用了io多路复用机制</strong>,每个worker都是一个独立的进程，但每个进程里只有一个主线程，通过<strong>异步非阻塞</strong>的方式来处理请求，即使是千上万个请求也不在话下。每个worker的线程可以把一个cpu的性能发挥到极致。所以 worker数和服务器的cpu数相等是最为适宜的。设置少了会浪费cpu性能，设多了会造成cpu频繁切换上下文带来损耗。</p><p>在nginx配置文件全局块中，通过 worker_processes 参数配置worker 进程数，设置为 auto时，nginx则会自动设置与cpu核心数相同的数量worker 进程。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span> auto;</span><br></pre></td></tr></table></figure></li></ul><h2 id="推荐文章"><a href="#推荐文章" class="headerlink" title="推荐文章"></a>推荐文章</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/spivic/article/details/15501359?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">初探Nginx架构之进程模型与事件处理机制</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Nginx" scheme="https://blog.windshadow.cn/categories/Nginx/"/>
    
    
  </entry>
  
</feed>
